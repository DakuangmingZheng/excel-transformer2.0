Index: mattermost-server-7.8.1/.gitlab-ci.yml
===================================================================
--- mattermost-server-7.8.1/.gitlab-ci.yml	(revision 4484)
+++ mattermost-server-7.8.1/.gitlab-ci.yml	(revision 4485)
@@ -11,8 +11,10 @@
   stage: build
   script:
     - source /usr/local/nvm/nvm.sh
-    - ls -la ../
-    - ls -la ../mattermost-plugin-playbooks/dist
+    #- ls -la ../
+    #- ls -la ../mattermost-plugin-playbooks/dist
+    #- ls -la ../focalboard/mattermost-plugin/dist
+    - cp ../focalboard/mattermost-plugin/dist/* ../focalboard/mattermost-plugin/webapp/dist/
     - >-
       cd ../ && mkdir -p mattermost-webapp/dist &&
       curl --insecure --header "PRIVATE-TOKEN: ${READONLY_CI_ACCESS_TOKEN}" "${CI_API_V4_URL}/projects/142/packages/generic/mattermost-webapp-7.8.1/${VERSION}/mattermost-webapp.tar.gz" -O &&
@@ -22,6 +24,7 @@
       cd ${CI_PROJECT_DIR} &&
       make MMCTL_REL_TO_DOWNLOAD=$MMCTL_REL_TO_DOWNLOAD BUILD_NUMBER=$CI_COMMIT_SHORT_SHA build &&
       make MMCTL_REL_TO_DOWNLOAD=$MMCTL_REL_TO_DOWNLOAD BUILD_NUMBER=$CI_COMMIT_SHORT_SHA package
+    - rm -rf focalboard/mattermost-plugin/webapp/dist/*
   artifacts:
     paths:
       - ./dist/mattermost-team-*
Index: mattermost-server-7.8.1/api4/api.go
===================================================================
--- mattermost-server-7.8.1/api4/api.go	(revision 4484)
+++ mattermost-server-7.8.1/api4/api.go	(revision 4485)
@@ -28,6 +28,29 @@
 	Bots *mux.Router // 'api/v4/bots'
 	Bot  *mux.Router // 'api/v4/bots/{bot_user_id:[A-Za-z0-9]+}'
 
+	/* Ryobi Systems CloudOffice Meeting Mod 20210325 START */
+	Meetings        *mux.Router // 'api/v4/meetings'
+	Meeting         *mux.Router // 'api/v4/meetings/{meeting_id:[A-Za-z0-9]+}'
+	MeetingByUserId *mux.Router // 'api/v4/meetings/userid/{user_id:[A-Za-z0-9]+}'
+	/* Ryobi Systems CloudOffice Meeting Mod 20210325 END */
+
+	/* Ryobi Systems CloudOffice Meeting Mod 20210615 START */
+	MeetingMng       *mux.Router // 'api/v4/MeetingMng'
+	MeetingMngDetail *mux.Router // 'api/v4/MeetingMngDetail'
+	MeetingMngDelete *mux.Router // 'api/v4/MeetingMngDelete'
+	/* Ryobi Systems CloudOffice Meeting Mod 20210615 END */
+
+	/* Ryobi Systems CloudOffice MeetingStatus Mod 20210913 START */
+	MeetingStatus *mux.Router // 'api/v4/MeetingStatus'
+	MeetingEnd    *mux.Router // 'api/v4/MeetingEnd'
+	/* Ryobi Systems CloudOffice MeetingStatus Mod 20210913 END */
+
+	/* Ryobi Systems CloudOffice CronChat Mod 20211129 START */
+	CronChat        *mux.Router // 'api/v4/CronChat'
+	Chat            *mux.Router // 'api/v4/Chat'
+	ChannelSettings *mux.Router // 'api/v4/ChannelSettings'
+	/* Ryobi Systems CloudOffice CronChat Mod 20211129 END */
+
 	Teams              *mux.Router // 'api/v4/teams'
 	TeamsForUser       *mux.Router // 'api/v4/users/{user_id:[A-Za-z0-9]+}/teams'
 	Team               *mux.Router // 'api/v4/teams/{team_id:[A-Za-z0-9]+}'
@@ -58,7 +81,11 @@
 	PostForUser     *mux.Router // 'api/v4/users/{user_id:[A-Za-z0-9]+}/posts/{post_id:[A-Za-z0-9]+}'
 
 	Files *mux.Router // 'api/v4/files'
-	File  *mux.Router // 'api/v4/files/{file_id:[A-Za-z0-9]+}'
+	/* Ryobi Systems CloudOffice Files Mod 20211103 START */
+	FilePermiission *mux.Router // 'api/v4/getfilepermission'
+	FileTotalSize   *mux.Router // 'api/v4/getfiletotalsize'
+	/* Ryobi Systems CloudOffice Files Mod 20211103 END */
+	File *mux.Router // 'api/v4/files/{file_id:[A-Za-z0-9]+}'
 
 	Uploads *mux.Router // 'api/v4/uploads'
 	Upload  *mux.Router // 'api/v4/uploads/{upload_id:[A-Za-z0-9]+}'
@@ -170,7 +197,29 @@
 
 	api.BaseRoutes.Bots = api.BaseRoutes.APIRoot.PathPrefix("/bots").Subrouter()
 	api.BaseRoutes.Bot = api.BaseRoutes.APIRoot.PathPrefix("/bots/{bot_user_id:[A-Za-z0-9]+}").Subrouter()
+	/* Ryobi Systems CloudOffice Meeting Mod 20210325 START */
+	api.BaseRoutes.Meetings = api.BaseRoutes.APIRoot.PathPrefix("/meetings").Subrouter()
+	api.BaseRoutes.Meeting = api.BaseRoutes.APIRoot.PathPrefix("/meetings/{meeting_item_id:[A-Za-z0-9]+}").Subrouter()
+	api.BaseRoutes.MeetingByUserId = api.BaseRoutes.Meetings.PathPrefix("/userid/{user_id:[A-Za-z0-9]+}").Subrouter()
+	/* Ryobi Systems CloudOffice Meeting Mod 20210325 END */
 
+	/* Ryobi Systems CloudOffice Meeting Mod 20210325 START */
+	api.BaseRoutes.MeetingMng = api.BaseRoutes.APIRoot.PathPrefix("/meeting_mng").Subrouter()
+	api.BaseRoutes.MeetingMngDetail = api.BaseRoutes.APIRoot.PathPrefix("/meeting_mng_detail").Subrouter()
+	api.BaseRoutes.MeetingMngDelete = api.BaseRoutes.APIRoot.PathPrefix("/meeting_mng_delete").Subrouter()
+	/* Ryobi Systems CloudOffice Meeting Mod 20210325 END */
+
+	/* Ryobi Systems CloudOffice MeetingStatus Mod 20210913 START */
+	api.BaseRoutes.MeetingStatus = api.BaseRoutes.APIRoot.PathPrefix("/meeting_status").Subrouter()
+	api.BaseRoutes.MeetingEnd = api.BaseRoutes.APIRoot.PathPrefix("/meeting_end").Subrouter()
+	/* Ryobi Systems CloudOffice MeetingStatus Mod 20210913 END */
+
+	/* Ryobi Systems CloudOffice CronChat Mod 20211129 START */
+	api.BaseRoutes.CronChat = api.BaseRoutes.APIRoot.PathPrefix("/cron_chat").Subrouter()
+	api.BaseRoutes.Chat = api.BaseRoutes.APIRoot.PathPrefix("/chat").Subrouter()
+	api.BaseRoutes.ChannelSettings = api.BaseRoutes.APIRoot.PathPrefix("/channel_settings").Subrouter()
+	/* Ryobi Systems CloudOffice CronChat Mod 20211129 END */
+
 	api.BaseRoutes.Teams = api.BaseRoutes.APIRoot.PathPrefix("/teams").Subrouter()
 	api.BaseRoutes.TeamsForUser = api.BaseRoutes.User.PathPrefix("/teams").Subrouter()
 	api.BaseRoutes.Team = api.BaseRoutes.Teams.PathPrefix("/{team_id:[A-Za-z0-9]+}").Subrouter()
@@ -201,6 +250,10 @@
 	api.BaseRoutes.PostForUser = api.BaseRoutes.PostsForUser.PathPrefix("/{post_id:[A-Za-z0-9]+}").Subrouter()
 
 	api.BaseRoutes.Files = api.BaseRoutes.APIRoot.PathPrefix("/files").Subrouter()
+	/* Ryobi Systems CloudOffice Files Mod 20211103 START */
+	api.BaseRoutes.FilePermiission = api.BaseRoutes.APIRoot.PathPrefix("/getfilepermission").Subrouter()
+	api.BaseRoutes.FileTotalSize = api.BaseRoutes.APIRoot.PathPrefix("/getfiletotalsize").Subrouter()
+	/* Ryobi Systems CloudOffice Files Mod 20211103 ENDRemove */
 	api.BaseRoutes.File = api.BaseRoutes.Files.PathPrefix("/{file_id:[A-Za-z0-9]+}").Subrouter()
 	api.BaseRoutes.PublicFile = api.BaseRoutes.Root.PathPrefix("/files/{file_id:[A-Za-z0-9]+}/public").Subrouter()
 
@@ -279,7 +332,19 @@
 
 	api.InitUser()
 	api.InitBot()
+	/* Ryobi Systems CloudOffice Meeting Mod 20210325 START */
+	api.InitMeeting()
+	/* Ryobi Systems CloudOffice Meeting Mod 20210325 END */
+	/* Ryobi Systems CloudOffice Meeting Mod 20210615 START */
+	api.InitMeetingMng()
+	/* Ryobi Systems CloudOffice Meeting Mod 20210615 END */
 	api.InitTeam()
+	/* Ryobi Systems CloudOffice MeetingStatus Mod 20210913 START */
+	api.InitMeetingStatus()
+	/* Ryobi Systems CloudOffice MeetingStatus Mod 20210913 END */
+	/* Ryobi Systems CloudOffice CronChat Mod 20211129 START */
+	api.InitCronChat()
+	/* Ryobi Systems CloudOffice CronChat Mod 20211129 END */
 	api.InitChannel()
 	api.InitPost()
 	api.InitFile()
Index: mattermost-server-7.8.1/api4/config.go
===================================================================
--- mattermost-server-7.8.1/api4/config.go	(revision 4484)
+++ mattermost-server-7.8.1/api4/config.go	(revision 4485)
@@ -4,11 +4,16 @@
 package api4
 
 import (
+	/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 START */
 	"encoding/json"
+	/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 START */
 	"fmt"
 	"net/http"
 	"reflect"
 	"strings"
+	/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 START */
+	"io/ioutil"
+	/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 END */
 
 	"github.com/mattermost/mattermost-server/v6/audit"
 	"github.com/mattermost/mattermost-server/v6/config"
@@ -17,6 +22,56 @@
 	"github.com/mattermost/mattermost-server/v6/utils"
 )
 
+/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 START */
+type ConfigData struct {
+	PluginSettings PluginSettingsData `json:"PluginSettings"`
+}
+
+type PluginSettingsData struct {
+	Plugins      PluginsDate      `json:"Plugins"`
+	PluginStates PluginStatesDate `json:"PluginStates"`
+	Directory    string           `json:"Directory"`
+}
+
+type PluginStatesDate struct {
+	Plugindefaultteams plugindefaultteamsDate `json:"plugindefaultteam"`
+}
+
+type plugindefaultteamsDate struct {
+	Enable bool `json:"Enable"`
+}
+
+type PluginsDate struct {
+	Plugindefaultteam PlugindefaultteamDate `json:"plugindefaultteam"`
+	Jitsi             JitsiDate             `json:"jitsi"`
+}
+
+type JitsiDate struct {
+	Jitsiurl string `json:"jitsiurl"`
+}
+
+type PlugindefaultteamDate struct {
+	Defaultteam string `json:"defaultteam"`
+}
+
+func GetDefaultTeamNameConfig() string {
+	var Name string
+	var data ConfigData
+	Name = ""
+	content, err := ioutil.ReadFile("/mattermost-server/config/config.json")
+	if err != nil {
+		return Name
+	}
+	err = json.Unmarshal([]byte(content), &data)
+	if err != nil {
+		return Name
+	}
+	Name = data.PluginSettings.Plugins.Plugindefaultteam.Defaultteam
+	return Name
+}
+
+/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 END */
+
 var writeFilter func(c *Context, structField reflect.StructField) bool
 var readFilter func(c *Context, structField reflect.StructField) bool
 var permissionMap map[string]*model.Permission
@@ -183,6 +238,23 @@
 		c.Err = appErr
 		return
 	}
+	Name := ""
+	/* Ryobi Systems DefaultTeamaSetUp Mod 20221025 START */
+	/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 START */
+	if Plugindefaultteam, ok := newCfg.PluginSettings.Plugins["plugindefaultteam"]; ok {
+		if defatulTeam, isOk := Plugindefaultteam["defaultteam"]; isOk {
+			Name = fmt.Sprintf("%v", defatulTeam)
+		}
+	}
+	if Name != "" {
+		if cfg.PluginSettings.PluginStates["plugindefaultteam"].Enable {
+			c.App.SaveDefaultTeamforName(Name)
+		} else {
+			c.App.DeleteDefaultTeam()
+		}
+	}
+	/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 END */
+	/* Ryobi Systems DefaultTeamaSetUp Mod 20221025 END */
 
 	diffs, err := config.Diff(oldCfg, newCfg)
 	if err != nil {
Index: mattermost-server-7.8.1/api4/cron_chat.go
===================================================================
--- mattermost-server-7.8.1/api4/cron_chat.go	(nonexistent)
+++ mattermost-server-7.8.1/api4/cron_chat.go	(revision 4485)
@@ -0,0 +1,77 @@
+//Copyright 2021 Ryobi Systems Co., Ltd. All Rights Reserved.
+
+package api4
+
+import (
+	"fmt"
+	"github.com/mattermost/mattermost-server/v6/model"
+	"github.com/mattermost/mattermost-server/v6/shared/i18n"
+	"github.com/mattermost/mattermost-server/v6/shared/mlog"
+	"net/http"
+)
+
+func (api *API) InitCronChat() {
+	api.BaseRoutes.CronChat.Handle("/delete", api.APISessionRequired(setCronChatDelete)).Methods("PUT")
+	api.BaseRoutes.Chat.Handle("/get_channel_settings", api.APISessionRequired(getChannelChatSettings)).Methods("GET")
+	api.BaseRoutes.ChannelSettings.Handle("/edit", api.APISessionRequired(setChannelChatSettings)).Methods("POST")
+}
+
+//削除バッチを設定
+func setCronChatDelete(c *Context, w http.ResponseWriter, r *http.Request) {
+	cronChatFromJsonData := model.CronSettingsDataFromJson(r.Body)
+
+	err := c.App.CronDeleteChat(c.AppContext, cronChatFromJsonData.CronTime)
+	if err != nil {
+		mlog.Error(fmt.Sprintln(err))
+		return
+	}
+	return
+}
+
+//チャンネルの設定を取得
+func getChannelChatSettings(c *Context, w http.ResponseWriter, r *http.Request) {
+	channelId := r.URL.Query().Get("channel_id")
+
+	T := i18n.GetUserTranslations(getUserLocale(c, c.AppContext.Session().UserId))
+
+	// //会議を取得
+	channelSettingsToJson, err := c.App.GetChannelChatSettings(channelId)
+	if err != nil {
+		responseResult := makeChannelSettingsErrResponse(T)
+		w.Write([]byte(responseResult.ToJson()))
+		return
+	}
+
+	//会議の取得に成功
+	w.Write([]byte(model.ChannelSettingsDetailInfoToJson(makeChannelSettingsResponse(channelSettingsToJson))))
+	return
+}
+
+//チャンネルの設定を格納
+func setChannelChatSettings(c *Context, w http.ResponseWriter, r *http.Request) {
+	channelChatFromJsonData := model.ChannelChatSaveSettingsDataFromJson(r.Body)
+	err := c.App.SetChannelChatSettings(c.AppContext, channelChatFromJsonData)
+	if err != nil {
+		mlog.Error(fmt.Sprintln(err))
+		return
+	}
+	return
+}
+
+//成功応答
+func makeChannelSettingsResponse(channelSettingsToJson *model.ChannelSettingsToJson) model.ResponseChannelSettingsDetail {
+	var responseResult model.ResponseChannelSettingsDetail
+	responseResult.Status = "OK"
+	responseResult.Type = "SERVER"
+	responseResult.ChannelData = channelSettingsToJson
+	return responseResult
+}
+
+//サーバエラー応答
+func makeChannelSettingsErrResponse(T i18n.TranslateFunc) model.ResponseResult {
+	var responseResult model.ResponseResult
+	responseResult.Status = "NG"
+	responseResult.Type = "SERVER"
+	responseResult.Message = T("api.meeting.search.app_error")
+	return responseResult
+}
Index: mattermost-server-7.8.1/api4/file.go
===================================================================
--- mattermost-server-7.8.1/api4/file.go	(revision 4484)
+++ mattermost-server-7.8.1/api4/file.go	(revision 4485)
@@ -7,11 +7,14 @@
 	"bytes"
 	"crypto/subtle"
 	"encoding/json"
+	"github.com/mattermost/mattermost-server/v6/shared/i18n"
 	"io"
 	"mime"
 	"mime/multipart"
+	"net"
 	"net/http"
 	"strconv"
+	"strings"
 	"time"
 
 	"github.com/mattermost/mattermost-server/v6/app"
@@ -25,8 +28,11 @@
 const (
 	FileTeamId = "noteam"
 
-	PreviewImageType   = "image/jpeg"
-	ThumbnailImageType = "image/jpeg"
+	PreviewImageType      = "image/jpeg"
+	ThumbnailImageType    = "image/jpeg"
+	userPermissonNone     = "none"
+	userPermissonDownload = "download"
+	userPermissonReadonly = "readonly"
 )
 
 const maxMultipartFormDataBytes = 10 * 1024 // 10Kb
@@ -33,6 +39,10 @@
 
 func (api *API) InitFile() {
 	api.BaseRoutes.Files.Handle("", api.APISessionRequired(uploadFileStream)).Methods("POST")
+	/* Ryobi Systems CloudOffice Files Mod 20211103 START */
+	api.BaseRoutes.FilePermiission.Handle("", api.APISessionRequired(getFilePermission)).Methods("GET")
+	api.BaseRoutes.FileTotalSize.Handle("", api.APISessionRequired(getFileTotalSize)).Methods("GET")
+	/* Ryobi Systems CloudOffice Files Mod 20211103 END */
 	api.BaseRoutes.Files.Handle("/search", api.APISessionRequired(searchFilesForUser)).Methods("POST")
 	api.BaseRoutes.File.Handle("", api.APISessionRequiredTrustRequester(getFile)).Methods("GET")
 	api.BaseRoutes.File.Handle("/thumbnail", api.APISessionRequiredTrustRequester(getFileThumbnail)).Methods("GET")
@@ -77,6 +87,18 @@
 }
 
 func uploadFileStream(c *Context, w http.ResponseWriter, r *http.Request) {
+	/* Ryobi Systems CloudOffice Files Mod 20211103 START */
+	// 権限取得
+	ip := ClientIP(r)
+	filePermission, _ := c.App.GetFilePermission(ip)
+	if !filePermission.UserPermissionUpload {
+		c.Err = model.NewAppError("uploadFileStream",
+			"api.file.upload_file.not_upload_permission.app_error",
+			nil, "", http.StatusUnauthorized)
+		return
+	}
+	/* Ryobi Systems CloudOffice Files Mod 20211103 END */
+
 	if !*c.App.Config().FileSettings.EnableFileAttachments {
 		c.Err = model.NewAppError("uploadFileStream",
 			"api.file.attachments.disabled.app_error",
@@ -124,6 +146,11 @@
 		return
 	}
 
+	/* Ryobi Systems CloudOffice Files Mod 20211103 START */
+	//　ファイルサイズをセット
+	_ = c.App.SetFileTotalSize()
+	/* Ryobi Systems CloudOffice Files Mod 20211103 END */
+
 	// Write the response values to the output upon return
 	w.WriteHeader(http.StatusCreated)
 	if err := json.NewEncoder(w).Encode(fileUploadResponse); err != nil {
@@ -450,6 +477,26 @@
 		return
 	}
 
+	/* Ryobi Systems CloudOffice Files Mod 20211103 START */
+	// 既存権限取得
+	if !*c.App.Config().FileSettings.EnableFileAttachments {
+		c.Err = model.NewAppError("getFile",
+			"api.file.upload_file.not_download_permission.app_error",
+			nil, "", http.StatusUnauthorized)
+		return
+	}
+
+	// 権限取得
+	ip := ClientIP(r)
+	filePermission, _ := c.App.GetFilePermission(ip)
+	if filePermission.UserPermissionDownload == userPermissonNone {
+		c.Err = model.NewAppError("getFile",
+			"api.file.upload_file.not_download_permission.app_error",
+			nil, "", http.StatusUnauthorized)
+		return
+	}
+	/* Ryobi Systems CloudOffice Files Mod 20211103 END */
+
 	forceDownload, _ := strconv.ParseBool(r.URL.Query().Get("download"))
 
 	auditRec := c.MakeAuditRecord("getFile", audit.Fail)
@@ -457,6 +504,26 @@
 	auditRec.AddEventParameter("force_download", forceDownload)
 
 	info, err := c.App.GetFileInfo(c.Params.FileId)
+
+	/* Ryobi Systems CloudOffice Files Mod 20211103 START */
+
+	if filePermission.UserPermissionDownload == userPermissonReadonly {
+		isImage := strings.HasPrefix(info.MimeType, "image")
+		//　参照のみの場合、ダウンロード（imageのダウンロードはできる）
+		if forceDownload && !isImage {
+			c.Err = model.NewAppError("getFile",
+				"api.file.upload_file.not_download_permission.app_error",
+				nil, "", http.StatusUnauthorized)
+			return
+		}
+		if !forceDownload && len(r.URL.Query()) == 1 { // アプリの参照のみの場合
+			c.Err = model.NewAppError("getFile",
+				"api.file.upload_file.not_download_permission.app_error",
+				nil, "", http.StatusUnauthorized)
+			return
+		}
+	}
+	/* Ryobi Systems CloudOffice Files Mod 20211103 END */
 	if err != nil {
 		c.Err = err
 		setInaccessibleFileHeader(w, err)
@@ -751,6 +818,85 @@
 	}
 }
 
+/* Ryobi Systems CloudOffice Files Mod 20211103 START */
+func getFilePermission(c *Context, w http.ResponseWriter, r *http.Request) {
+	T := i18n.GetUserTranslations(getUserLocale(c, c.AppContext.Session().UserId))
+
+	// 権限取得
+	ip := ClientIP(r)
+	filePermission, err := c.App.GetFilePermission(ip)
+	if err != nil {
+		responseResult := makeServerFileErrResponse(T)
+		w.Write([]byte(responseResult.ToJson()))
+		return
+	}
+
+	filePermissionToJson := makeServerFilePermissionResponse(filePermission)
+
+	w.Write([]byte(filePermissionToJson.ToJson()))
+}
+func getFileTotalSize(c *Context, w http.ResponseWriter, r *http.Request) {
+	T := i18n.GetUserTranslations(getUserLocale(c, c.AppContext.Session().UserId))
+
+	// 権限取得
+	fileTotalSize, err := c.App.GetFileTotalSize()
+	if err != nil {
+		responseResult := makeServerFileErrResponse(T)
+		w.Write([]byte(responseResult.ToJson()))
+		return
+	}
+
+	fileTotalSizeToJson := makeServerFileTotalSizeResponse(fileTotalSize)
+
+	w.Write([]byte(fileTotalSizeToJson.ToJson()))
+}
+func ClientIP(r *http.Request) string {
+	xForwardedFor := r.Header.Get("X-Forwarded-For")
+	ip := strings.TrimSpace(strings.Split(xForwardedFor, ",")[0])
+	if ip != "" {
+		return ip
+	}
+
+	ip = strings.TrimSpace(r.Header.Get("X-Real-Ip"))
+	if ip != "" {
+		return ip
+	}
+
+	if ip, _, err := net.SplitHostPort(strings.TrimSpace(r.RemoteAddr)); err == nil {
+		return ip
+	}
+
+	return ""
+}
+
+//ファイルパーミッション応答
+func makeServerFilePermissionResponse(filePermission *model.FilePermission) model.ResponseFilePermission {
+	var responseResult model.ResponseFilePermission
+	responseResult.Status = "OK"
+	responseResult.Type = "SERVER"
+	responseResult.User = filePermission
+	return responseResult
+}
+
+//ファイルサイズ応答
+func makeServerFileTotalSizeResponse(fileTotaSize float64) model.ResponseFileTotalSize {
+	var responseResult model.ResponseFileTotalSize
+	responseResult.Status = "OK"
+	responseResult.Type = "SERVER"
+	responseResult.TotalSize = fileTotaSize
+	return responseResult
+}
+
+//サーバエラー応答
+func makeServerFileErrResponse(T i18n.TranslateFunc) model.ResponseResultFile {
+	var responseResult model.ResponseResultFile
+	responseResult.Status = "NG"
+	responseResult.Type = "SERVER"
+	responseResult.Message = T("api.meeting.server.app_error")
+	return responseResult
+}
+
+/* Ryobi Systems CloudOffice Files Mod 20211103 END */
 func setInaccessibleFileHeader(w http.ResponseWriter, appErr *model.AppError) {
 	// File is inaccessible due to cloud plan's limit.
 	if appErr.Id == "app.file.cloud.get.app_error" {
Index: mattermost-server-7.8.1/api4/meeting.go
===================================================================
--- mattermost-server-7.8.1/api4/meeting.go	(nonexistent)
+++ mattermost-server-7.8.1/api4/meeting.go	(revision 4485)
@@ -0,0 +1,1088 @@
+//Copyright 2021 Ryobi Systems Co., Ltd. All Rights Reserved.
+
+package api4
+
+import (
+	"bytes"
+	"io"
+	"net/http"
+	"net/mail"
+	"strconv"
+	"strings"
+	"time"
+
+	"github.com/jaytaylor/html2text"
+	"github.com/mattermost/mattermost-server/v6/model"
+	"github.com/mattermost/mattermost-server/v6/shared/i18n"
+	mailservice "github.com/mattermost/mattermost-server/v6/shared/mail"
+	"github.com/mattermost/mattermost-server/v6/utils"
+)
+
+const (
+	meetingMailNotSend = iota
+	meetingMailTypeInvite
+	meetingMailTypeChange
+	meetingMailTypeTerminate
+)
+
+type mailResult struct {
+	mailAddr   string
+	sendResult bool
+}
+
+func (api *API) InitMeeting() {
+	api.BaseRoutes.Meetings.Handle("", api.APISessionRequired(createMeeting)).Methods("POST")
+	api.BaseRoutes.MeetingByUserId.Handle("", api.APISessionRequired(getMeetingsByUserId)).Methods("GET")
+	api.BaseRoutes.Meeting.Handle("", api.APISessionRequired(getMeeting)).Methods("GET")
+	api.BaseRoutes.Meeting.Handle("", api.APISessionRequired(updateMeeting)).Methods("PUT")
+	api.BaseRoutes.Meeting.Handle("", api.APISessionRequired(deleteMeeting)).Methods("DELETE")
+}
+
+//会議を作成
+func createMeeting(c *Context, w http.ResponseWriter, r *http.Request) {
+	T := i18n.GetUserTranslations(getUserLocale(c, c.AppContext.Session().UserId))
+	var responseResult model.ResponseResult
+
+	meetingData := model.MeetingDataFromJson(r.Body)
+	if meetingData == nil {
+		responseResult = makeServerErrResponse(T)
+		w.Write([]byte(responseResult.ToJson()))
+		return
+	}
+
+	meeting, meetingUsersFromJson := formatMeetingData(meetingData)
+
+	if userMailCheck(meetingUsersFromJson) == false {
+		responseResult = makeMailFormatErrResponse(T)
+		w.Write([]byte(responseResult.ToJson()))
+		return
+	}
+
+	//会議を作成
+	meetingMailInfo, meetingUsers, err := c.App.CreateMeeting(meeting, meetingUsersFromJson)
+	if err != nil {
+		responseResult = makeServerErrResponse(T)
+		w.Write([]byte(responseResult.ToJson()))
+		return
+	}
+	/* Ryobi Systems CloudOffice Meeting Mod 20220424 START */
+	//メールを送るかどうか
+	isSendMail := sendMailCheck(c)
+	meetingUsersForMail := setMeetingUsersForMail(meetingUsers, meetingMailTypeInvite, c)
+	if isSendMail {
+		//会議招待メールを送る、主催者メールを追加
+		successMailAddrs, failedMailAddrs := sendMultiThreadMail(c, meetingUsersForMail, meetingMailInfo)
+
+		//送信成功の招待者はtrueに更新
+		if len(successMailAddrs) != 0 && len(meetingUsers) != 0 {
+			err = c.App.UpdateValidMeetingUsers(meetingUsers[0].MeetingItemId, successMailAddrs, 1)
+			if err != nil {
+				responseResult = makeServerErrResponse(T)
+				w.Write([]byte(responseResult.ToJson()))
+				return
+			}
+		}
+
+		//送信に失敗
+		if len(failedMailAddrs) != 0 {
+			responseResult = makeMailErrResponse(T, failedMailAddrs)
+			w.Write([]byte(responseResult.ToJson()))
+			return
+		}
+	} else {
+		var AllMailAddrs []string
+		for _, meetingUserForMail := range meetingUsersForMail {
+			AllMailAddrs = append(AllMailAddrs, meetingUserForMail.UserMail)
+		}
+
+		if len(AllMailAddrs) != 0 && len(meetingUsers) != 0 {
+			err = c.App.UpdateValidMeetingUsers(meetingUsers[0].MeetingItemId, AllMailAddrs, 1)
+			if err != nil {
+				responseResult = makeServerErrResponse(T)
+				w.Write([]byte(responseResult.ToJson()))
+				return
+			}
+		}
+
+	}
+	/* Ryobi Systems CloudOffice Meeting Mod 20220424 END */
+
+	//会議の作成に成功
+	responseResult.Status = "OK"
+	w.Write([]byte(responseResult.ToJson()))
+	return
+}
+
+//会議を取得(ユーザIDを使用)
+func getMeetingsByUserId(c *Context, w http.ResponseWriter, r *http.Request) {
+	T := i18n.GetUserTranslations(getUserLocale(c, c.AppContext.Session().UserId))
+	var responseResult model.ResponseResult
+
+	//インターフェースパラメータのチェック
+	meetingAfter := r.URL.Query().Get("meeting_after")
+	_, strErr := strconv.ParseInt(meetingAfter, 10, 64)
+	if strErr != nil {
+		responseResult = makeServerErrResponse(T)
+		w.Write([]byte(responseResult.ToJson()))
+		return
+	}
+	meetingBefore := r.URL.Query().Get("meeting_before")
+	_, strErr = strconv.ParseInt(meetingBefore, 10, 64)
+	if strErr != nil {
+		responseResult = makeServerErrResponse(T)
+		w.Write([]byte(responseResult.ToJson()))
+		return
+	}
+
+	//ユーザーIDを使用して、指定した時間範囲に会議を照会
+	meetingList, err := c.App.GetMeetingsByUserId(c.Params.UserId, meetingAfter, meetingBefore)
+	if err != nil {
+		responseResult = makeServerErrResponse(T)
+		w.Write([]byte(responseResult.ToJson()))
+		return
+	}
+
+	//除外された単条重複会議を照会
+	meetingItemIds := getMeetingItemIdsInMeetingList(meetingList)
+	deletedMeetingInfo, err := c.App.GetDeletedMeetingInfoByMeetingItemIds(meetingItemIds)
+	if err != nil {
+		responseResult = makeServerErrResponse(T)
+		w.Write([]byte(responseResult.ToJson()))
+		return
+	}
+
+	//すべての会議をフォーマット
+	allMeetings := formatAllMeetings(meetingList, deletedMeetingInfo)
+
+	//会議の取得に成功
+	w.Write([]byte(model.AllMeetingsToJson(allMeetings)))
+	return
+}
+
+//繰り返し会議の会議IDを取得
+func getMeetingItemIdsInMeetingList(meetingList []*model.RepeatMeetingToJson) []string {
+	var meetingItemIds []string
+	for _, meeting := range meetingList {
+		if meeting.IsRepeat == true {
+			meetingItemIds = append(meetingItemIds, meeting.MeetingItemId)
+		}
+	}
+	return meetingItemIds
+}
+
+//すべての会議をフォーマット
+func formatAllMeetings(meetingList []*model.RepeatMeetingToJson, deletedMeetingInfo []*model.DeleteParamsToJson) *model.AllMeetings {
+	var allMeetings model.AllMeetings
+	var singleMeetings []*model.MeetingToJson
+	var repeatMeetings []*model.RepeatMeetingToJson
+
+	for _, meeting := range meetingList {
+		if meeting.IsRepeat == true {
+			repeatMeetings = append(repeatMeetings, meeting)
+		} else {
+			var item model.MeetingToJson
+			item.MeetingItemId = meeting.MeetingItemId
+			item.MeetingUrl = meeting.MeetingUrl
+			item.MeetingName = meeting.MeetingName
+			item.StartAt = meeting.StartAt
+			item.EndAt = meeting.EndAt
+			item.TimeZone = meeting.TimeZone
+			item.HostId = meeting.HostId
+			item.HostName = meeting.HostName
+			item.Users = meeting.Users
+
+			singleMeetings = append(singleMeetings, &item)
+		}
+	}
+
+	allMeetings.SingleMeetings = singleMeetings
+	allMeetings.RepeatMeetings = repeatMeetings
+	allMeetings.DeletedMeetingInfo = deletedMeetingInfo
+
+	return &allMeetings
+}
+
+//会議を取得(会議項目IDを使用)
+func getMeeting(c *Context, w http.ResponseWriter, r *http.Request) {
+	T := i18n.GetUserTranslations(getUserLocale(c, c.AppContext.Session().UserId))
+
+	//会議を取得
+	meeting, err := c.App.GetMeeting(c.Params.MeetingItemId)
+	if err != nil {
+		responseResult := makeServerErrResponse(T)
+		w.Write([]byte(responseResult.ToJson()))
+		return
+	}
+
+	//会議に存在しない
+	if meeting == nil {
+		responseResult := makeMeetingNotExistErrResponse(T)
+		w.Write([]byte(responseResult.ToJson()))
+		return
+	}
+
+	//会議の取得に成功
+	w.Write([]byte(model.MeetingInfoToJson(meeting)))
+	return
+}
+
+//会議を更新
+func updateMeeting(c *Context, w http.ResponseWriter, r *http.Request) {
+	T := i18n.GetUserTranslations(getUserLocale(c, c.AppContext.Session().UserId))
+	var responseResult model.ResponseResult
+
+	meetingData := model.MeetingDataFromJson(r.Body)
+	if meetingData == nil {
+		responseResult = makeServerErrResponse(T)
+		w.Write([]byte(responseResult.ToJson()))
+		return
+	}
+
+	meeting, meetingUsersFromJson := formatMeetingData(meetingData)
+	meeting.MeetingItemId = c.Params.MeetingItemId
+
+	if userMailCheck(meetingUsersFromJson) == false {
+		responseResult = makeMailFormatErrResponse(T)
+		w.Write([]byte(responseResult.ToJson()))
+		return
+	}
+
+	//会議を更新
+	meetingMailInfo, meetingItemId, err := c.App.UpdateMeeting(meeting, meetingUsersFromJson, meetingData.IsAddMeeting)
+	if err != nil {
+		responseResult = makeServerErrResponse(T)
+		w.Write([]byte(responseResult.ToJson()))
+		return
+	}
+
+	//会議に存在しない
+	if meetingMailInfo == nil {
+		responseResult := makeMeetingNotExistErrResponse(T)
+		w.Write([]byte(responseResult.ToJson()))
+		return
+	}
+
+	/* Ryobi Systems CloudOffice Meeting Mod 20220424 START */
+	//メールを送るかどうか
+	isSendMail := sendMailCheck(c)
+	if len(meetingUsersFromJson) != 0 {
+		if isSendMail {
+			//会議メールを送る
+			successMailAddrs, failedMailAddrs := sendMultiThreadMail(c, meetingUsersFromJson, meetingMailInfo)
+
+			//中止メールの送信に成功したユーザーは無効に設定
+			var invalidMailAddrs []string
+			for _, meetingUserFromJson := range meetingUsersFromJson {
+				if meetingUserFromJson.SendMailMode == meetingMailTypeTerminate {
+					for _, successMailAddr := range successMailAddrs {
+						if meetingUserFromJson.UserMail == successMailAddr {
+							invalidMailAddrs = append(invalidMailAddrs, successMailAddr)
+						}
+					}
+				}
+			}
+
+			err = c.App.UpdateValidMeetingUsers(meetingItemId, invalidMailAddrs, 0)
+			if err != nil {
+				responseResult = makeServerErrResponse(T)
+				w.Write([]byte(responseResult.ToJson()))
+				return
+			}
+
+			//送信に失敗
+			if len(failedMailAddrs) != 0 {
+				responseResult = makeMailErrResponse(T, failedMailAddrs)
+				w.Write([]byte(responseResult.ToJson()))
+				return
+			}
+		} else {
+			var invalidMailAddrs []string
+			for _, meetingUserFromJson := range meetingUsersFromJson {
+				if meetingUserFromJson.SendMailMode == meetingMailTypeTerminate {
+					invalidMailAddrs = append(invalidMailAddrs, meetingUserFromJson.UserMail)
+				}
+			}
+
+			err = c.App.UpdateValidMeetingUsers(meetingItemId, invalidMailAddrs, 0)
+			if err != nil {
+				responseResult = makeServerErrResponse(T)
+				w.Write([]byte(responseResult.ToJson()))
+				return
+			}
+		}
+	}
+	/* Ryobi Systems CloudOffice Meeting Mod 20220424 END */
+
+	//会議の更新に成功
+	responseResult.Status = "OK"
+	w.Write([]byte(responseResult.ToJson()))
+	return
+}
+
+//会議を削除
+func deleteMeeting(c *Context, w http.ResponseWriter, r *http.Request) {
+	T := i18n.GetUserTranslations(getUserLocale(c, c.AppContext.Session().UserId))
+	var responseResult model.ResponseResult
+	var meetingItemIds []string
+	meetingItemIds = append(meetingItemIds, c.Params.MeetingItemId)
+
+	delParams := model.DelParamsFromJson(r.Body)
+	if delParams == nil {
+		responseResult = makeServerErrResponse(T)
+		w.Write([]byte(responseResult.ToJson()))
+		return
+	}
+
+	//現在の会議のユーザを取得
+	meetingUsers, err := c.App.GetMeetingUsersByMeetingItemIds(meetingItemIds)
+	if err != nil {
+		responseResult = makeServerErrResponse(T)
+		w.Write([]byte(responseResult.ToJson()))
+		return
+	}
+
+	//会議項目IDを使用して、会議を削除
+	meetingMailInfo, err := c.App.DeleteMeeting(c.Params.MeetingItemId, delParams)
+	if err != nil {
+		responseResult = makeServerErrResponse(T)
+		w.Write([]byte(responseResult.ToJson()))
+		return
+	}
+
+	//会議に存在しない
+	if meetingMailInfo == nil {
+		responseResult := makeMeetingNotExistErrResponse(T)
+		w.Write([]byte(responseResult.ToJson()))
+		return
+	}
+
+	/* Ryobi Systems CloudOffice Meeting Mod 20220424 START */
+	//メールを送るかどうか
+	isSendMail := sendMailCheck(c)
+	if isSendMail {
+		//会議中止メールを送る、主催者メールを追加
+		meetingUsersForMail := setMeetingUsersForMail(meetingUsers, meetingMailTypeTerminate, c)
+		_, failedMailAddrs := sendMultiThreadMail(c, meetingUsersForMail, meetingMailInfo)
+
+		//送信に失敗
+		if len(failedMailAddrs) != 0 {
+			responseResult = makeMailErrResponse(T, failedMailAddrs)
+			w.Write([]byte(responseResult.ToJson()))
+			return
+		}
+	}
+	/* Ryobi Systems CloudOffice Meeting Mod 20220424 END */
+
+	//会議の削除に成功
+	responseResult.Status = "OK"
+	w.Write([]byte(responseResult.ToJson()))
+	return
+}
+
+//会議情報をフォーマット
+func formatMeetingData(meetingData *model.MeetingFromJson) (*model.Meeting, []*model.MeetingUserFromJson) {
+	var meeting model.Meeting
+
+	meetingUsers := meetingData.Users
+	meeting.MeetingName = meetingData.MeetingName
+	meeting.MeetingId = meetingData.MeetingId
+	meeting.StartAt = meetingData.StartAt
+	meeting.EndAt = meetingData.EndAt
+	meeting.TimeZone = meetingData.TimeZone
+	meeting.HostId = meetingData.HostId
+	meeting.HostName = meetingData.HostName
+	meeting.IsRepeat = meetingData.IsRepeat
+	meeting.RepeatConfig = model.RepeatConfigToJson(meetingData.RepeatConfig)
+	meeting.RepeatEndDate = meetingData.RepeatEndDate
+
+	return &meeting, meetingUsers
+}
+
+//ユーザ送信情報をフォーマット
+func setMeetingUsersForMail(meetingUsers []*model.MeetingUser, mailMode int, c *Context) []*model.MeetingUserFromJson {
+	var meetingUsersForMail []*model.MeetingUserFromJson
+	for _, meetingUser := range meetingUsers {
+		var item model.MeetingUserFromJson
+		item.UserId = meetingUser.UserId
+		item.UserMail = meetingUser.UserMail
+		item.SendMailMode = mailMode
+		item.UserType = "user"
+
+		meetingUsersForMail = append(meetingUsersForMail, &item)
+	}
+
+	//主催者メールを追加
+	var host model.MeetingUserFromJson
+	host.UserId = c.AppContext.Session().UserId
+	host.UserMail = getUserMail(c, host.UserId)
+	host.SendMailMode = mailMode
+	host.UserType = "host"
+	meetingUsersForMail = append(meetingUsersForMail, &host)
+
+	return meetingUsersForMail
+}
+
+/* Ryobi Systems CloudOffice Meeting Mod 送信元メール表示改善 20210506 START */
+//マルチスレッド送信
+func sendMultiThreadMail(c *Context, meetingUsersForMail []*model.MeetingUserFromJson, meetingMailInfo *model.MeetingMailInfo) ([]string, []string) {
+	var failedMailAddrs []string
+	var successMailAddrs []string
+	var meetingUserForMail *model.MeetingUserFromJson
+	var cChannel (chan mailResult)
+	listLen := len(meetingUsersForMail)
+	total := 0
+	hostMail := getUserMail(c, c.AppContext.Session().UserId)
+
+	for _, meetingUserForMail = range meetingUsersForMail {
+		cChannel = make(chan mailResult)
+
+		go func(meetingUserForMail *model.MeetingUserFromJson) {
+			var result mailResult
+			result.mailAddr = meetingUserForMail.UserMail
+
+			TForMail := i18n.GetUserTranslations(getUserLocale(c, meetingUserForMail.UserId))
+			errForMail := sendMeetingMail(c, TForMail, meetingUserForMail.SendMailMode, meetingUserForMail.UserType, meetingUserForMail.UserMail, meetingMailInfo, hostMail)
+			if errForMail != nil {
+				result.sendResult = false
+			} else {
+				result.sendResult = true
+			}
+
+			cChannel <- result
+			total++
+
+			if total == listLen {
+				close(cChannel)
+			}
+		}(meetingUserForMail)
+	}
+
+	for mailResultInfo := range cChannel {
+		if mailResultInfo.sendResult == true {
+			//送信に成功したメールリスト
+			successMailAddrs = append(successMailAddrs, mailResultInfo.mailAddr)
+		} else {
+			//送信に失敗したメールリスト
+			failedMailAddrs = append(failedMailAddrs, mailResultInfo.mailAddr)
+		}
+	}
+
+	return successMailAddrs, failedMailAddrs
+}
+
+//送信処理
+func sendMeetingMail(c *Context, T i18n.TranslateFunc, mailType int, userType string, mailTo string, meetingMailInfo *model.MeetingMailInfo, hostMail string) error {
+	mailConfig := c.App.Srv().MailServiceConfig()
+	meetingEmailAddress := c.App.Config().PluginSettings.Plugins["meetingemailaddress"]
+	var emailAddress string
+	if meetingEmailAddress != nil {
+		meetingEmailAddressEnable := c.App.Config().PluginSettings.PluginStates["meetingemailaddress"]
+		replaceInviterEmail := c.App.Config().PluginSettings.Plugins["meetingemailaddress"]["replaceinviteremail"]
+		ReplaceEmail := c.App.Config().PluginSettings.Plugins["meetingemailaddress"]["replaceemail"].(string)
+		if meetingEmailAddressEnable != nil && meetingEmailAddressEnable.Enable == true && replaceInviterEmail == true && ReplaceEmail != "" {
+			emailAddress = ReplaceEmail
+		} else {
+			emailAddress = hostMail
+		}
+	} else {
+		emailAddress = hostMail
+	}
+
+	switch mailType {
+	//送信なし
+	case meetingMailNotSend:
+		return nil
+	//会議招待メール
+	case meetingMailTypeInvite:
+		//招待者に送信
+		mailTemplate := "api.meeting.mail.invite_template"
+		titlePrefix := "api.meeting.mail.invite_title_prefix"
+		fromMail := mail.Address{Name: meetingMailInfo.UserName, Address: emailAddress}
+		meetingMailTo := mailTo
+
+		//主催者に送信
+		if userType == "host" {
+			mailTemplate = "api.meeting.mail.invite_template_host"
+			titlePrefix = "api.meeting.mail.invite_title_prefix_host"
+			fromMail = mail.Address{Name: *c.App.Config().EmailSettings.FeedbackName, Address: *c.App.Config().EmailSettings.FeedbackEmail}
+			meetingMailTo = hostMail
+		}
+
+		inviteMailContent := T(mailTemplate,
+			map[string]interface{}{
+				"UserName": meetingMailInfo.UserName, "StartAtYear": meetingMailInfo.StartAtYear, "StartAtMonth": meetingMailInfo.StartAtMonth,
+				"StartAtDay": meetingMailInfo.StartAtDay, "StartAtHour": meetingMailInfo.StartAtHour, "StartAtMinute": meetingMailInfo.StartAtMinute,
+				"EndAtYear": meetingMailInfo.EndAtYear, "EndAtMonth": meetingMailInfo.EndAtMonth, "EndAtDay": meetingMailInfo.EndAtDay,
+				"EndAtHour": meetingMailInfo.EndAtHour, "EndAtMinute": meetingMailInfo.EndAtMinute, "TimeZone": T(model.RSMeetingTimezonesI18n[meetingMailInfo.TimeZone]),
+				"MeetingUrl": makeMeetingUrl(T, meetingMailInfo), "RepeatMeetingInfo": makeRepeatMeetingInfo(T, meetingMailInfo)})
+		return mailservice.SendMeetingMail(mailTo, T(titlePrefix)+meetingMailInfo.MeetingName, inviteMailContent, makeICSFile(c, T, meetingMailInfo, fromMail, userType, meetingMailTo, inviteMailContent), mailConfig, "", fromMail)
+	//会議変更メール
+	case meetingMailTypeChange:
+		//招待者に送信
+		mailTemplate := "api.meeting.mail.change_template"
+		fromMail := mail.Address{Name: meetingMailInfo.UserName, Address: emailAddress}
+		meetingMailTo := mailTo
+
+		//主催者に送信
+		if userType == "host" {
+			mailTemplate = "api.meeting.mail.change_template_host"
+			fromMail = mail.Address{Name: *c.App.Config().EmailSettings.FeedbackName, Address: *c.App.Config().EmailSettings.FeedbackEmail}
+			meetingMailTo = hostMail
+		}
+
+		changeMailContent := T(mailTemplate,
+			map[string]interface{}{
+				"UserName": meetingMailInfo.UserName, "StartAtYear": meetingMailInfo.StartAtYear, "StartAtMonth": meetingMailInfo.StartAtMonth,
+				"StartAtDay": meetingMailInfo.StartAtDay, "StartAtHour": meetingMailInfo.StartAtHour, "StartAtMinute": meetingMailInfo.StartAtMinute,
+				"EndAtYear": meetingMailInfo.EndAtYear, "EndAtMonth": meetingMailInfo.EndAtMonth, "EndAtDay": meetingMailInfo.EndAtDay,
+				"EndAtHour": meetingMailInfo.EndAtHour, "EndAtMinute": meetingMailInfo.EndAtMinute, "TimeZone": T(model.RSMeetingTimezonesI18n[meetingMailInfo.TimeZone]),
+				"MeetingUrl": makeMeetingUrl(T, meetingMailInfo), "RepeatMeetingInfo": makeRepeatMeetingInfo(T, meetingMailInfo)})
+		return mailservice.SendMeetingMail(mailTo, T("api.meeting.mail.change_title_prefix")+meetingMailInfo.MeetingName, changeMailContent, makeICSFile(c, T, meetingMailInfo, fromMail, userType, meetingMailTo, changeMailContent), mailConfig, "", fromMail)
+	//会議中止メール
+	case meetingMailTypeTerminate:
+		//招待者に送信
+		mailTemplate := "api.meeting.mail.terminate_template"
+		fromMail := mail.Address{Name: meetingMailInfo.UserName, Address: emailAddress}
+
+		//主催者に送信
+		if userType == "host" {
+			mailTemplate = "api.meeting.mail.terminate_template_host"
+			fromMail = mail.Address{Name: *c.App.Config().EmailSettings.FeedbackName, Address: *c.App.Config().EmailSettings.FeedbackEmail}
+		}
+
+		terminateMailContent := T(mailTemplate,
+			map[string]interface{}{
+				"UserName": meetingMailInfo.UserName, "StartAtYear": meetingMailInfo.StartAtYear, "StartAtMonth": meetingMailInfo.StartAtMonth,
+				"StartAtDay": meetingMailInfo.StartAtDay, "StartAtHour": meetingMailInfo.StartAtHour, "StartAtMinute": meetingMailInfo.StartAtMinute,
+				"EndAtYear": meetingMailInfo.EndAtYear, "EndAtMonth": meetingMailInfo.EndAtMonth, "EndAtDay": meetingMailInfo.EndAtDay,
+				"EndAtHour": meetingMailInfo.EndAtHour, "EndAtMinute": meetingMailInfo.EndAtMinute, "TimeZone": T(model.RSMeetingTimezonesI18n[meetingMailInfo.TimeZone]),
+				"RepeatMeetingInfo": makeRepeatMeetingInfo(T, meetingMailInfo)})
+		return mailservice.SendMeetingMail(mailTo, T("api.meeting.mail.terminate_title_prefix")+meetingMailInfo.MeetingName, terminateMailContent, nil, mailConfig, "", fromMail)
+	}
+
+	return nil
+}
+
+/* Ryobi Systems CloudOffice Meeting Mod 送信元メール表示改善 20210506 END */
+
+//ユーザ言語の種類を取得
+func getUserLocale(c *Context, userId string) string {
+	userLocale := "ja"
+
+	if userId == "" {
+		return userLocale
+	}
+
+	user, err := c.App.GetUser(userId)
+	if err != nil {
+		return userLocale
+	}
+
+	userLocale = user.Locale
+	return userLocale
+}
+
+//ユーザメールを取得
+func getUserMail(c *Context, userId string) string {
+	userMail := ""
+
+	if userId == "" {
+		return userMail
+	}
+
+	user, err := c.App.GetUser(userId)
+	if err != nil {
+		return userMail
+	}
+
+	userMail = user.Email
+	return userMail
+}
+
+//カレンダーICSファイルを作成
+func makeICSFile(c *Context, T i18n.TranslateFunc, meetingMailInfo *model.MeetingMailInfo, fromMail mail.Address, userType, meetingMailTo, mailContent string) map[string]io.Reader {
+	startAtDate := meetingMailInfo.StartAtYear + meetingMailInfo.StartAtMonth + meetingMailInfo.StartAtDay + "T" + meetingMailInfo.StartAtHour + meetingMailInfo.StartAtMinute + "00"
+	endAtDate := meetingMailInfo.EndAtYear + meetingMailInfo.EndAtMonth + meetingMailInfo.EndAtDay + "T" + meetingMailInfo.EndAtHour + meetingMailInfo.EndAtMinute + "00"
+	meetingName := meetingMailInfo.MeetingName
+	meetingUrl := makeMeetingUrl(T, meetingMailInfo)
+	meetingOrganizer := fromMail.Name
+	meetingCN := fromMail.Address
+	meetingTzInfo := model.RSMeetingTimezonesICSInfo[meetingMailInfo.TimeZone]
+	utcNowInt64 := time.Now().UTC().Unix()
+	meetingDtstamp := c.App.GetMeetingDtstamp(utcNowInt64)
+	mailContentTxt, _ := html2text.FromString(strings.Replace(mailContent, "<br/>", "\\n", -1))
+	meetingAttendee := meetingMailTo
+	meetingRSVP := "TRUE"
+	if userType == "host" {
+		meetingAttendee = meetingMailInfo.UserName
+		meetingRSVP = "FALSE"
+	}
+
+	meetingRrule := makeRepeatMeetingRRULE(meetingMailInfo)
+
+	fileName := T("api.meeting.mail.ics.filename") + ".ics"
+	fileContent :=
+		`BEGIN:VCALENDAR
+PRODID:-//Microsoft Corporation//Outlook 10.0 MIMEDIR//EN
+VERSION:2.0
+METHOD:REQUEST` + meetingTzInfo +
+			`BEGIN:VEVENT
+DTSTAMP:` + meetingDtstamp + `
+ATTENDEE;CN="` + meetingAttendee + `";ROLE=REQ-PARTICIPANT;RSVP=` + meetingRSVP + `:MAILTO:` + meetingMailTo + `
+ORGANIZER;CN="` + meetingOrganizer + `":MAILTO:` + meetingCN + `
+DTSTART;TZID=` + meetingMailInfo.TimeZone + `:` + startAtDate + `
+DTEND;TZID=` + meetingMailInfo.TimeZone + `:` + endAtDate + `
+LOCATION:` + meetingUrl + `
+TRANSP:OPAQUE
+SEQUENCE:` + strconv.FormatInt(utcNowInt64, 10) + `
+UID:` + meetingMailInfo.ICalUID + `
+DESCRIPTION:` + mailContentTxt + `
+SUMMARY:` + meetingName + `
+PRIORITY:5
+CLASS:PUBLIC` + meetingRrule + `
+BEGIN:VALARM
+TRIGGER:-PT5M
+ACTION:DISPLAY
+DESCRIPTION:Reminder
+END:VALARM
+END:VEVENT
+END:VCALENDAR`
+
+	return map[string]io.Reader{fileName: bytes.NewReader([]byte(fileContent))}
+}
+
+//ICSファイル重複会議情報を作成
+func makeRepeatMeetingRRULE(meetingMailInfo *model.MeetingMailInfo) string {
+	rRULEString := ""
+
+	if meetingMailInfo.AddRepeatInfo == true {
+		repeatFrequencyTimes := strconv.Itoa(meetingMailInfo.RepeatConfig.RepeatFrequencyTimes)
+		rRULEString = "\nRRULE:"
+		switch meetingMailInfo.RepeatConfig.RepeatType {
+		//日単位
+		case "day":
+			rRULEString += "FREQ=DAILY;"
+			rRULEString += getICSEndInfo(meetingMailInfo)
+
+			if meetingMailInfo.RepeatConfig.RepeatFrequencyTimesType == "everyday" {
+				//平日
+				rRULEString += "INTERVAL=1;BYDAY=MO,TU,WE,TH,FR"
+			} else {
+				//N日毎
+				rRULEString += "INTERVAL=" + repeatFrequencyTimes
+			}
+		//週単位
+		case "week":
+			rRULEString += "FREQ=WEEKLY;WKST=SU;"
+			rRULEString += getICSEndInfo(meetingMailInfo)
+			rRULEString += "INTERVAL=" + repeatFrequencyTimes + ";"
+			rRULEString += "BYDAY=" + getICSWeekdays(meetingMailInfo.RepeatConfig.RepeatFrequencyWeekdays)
+		//月単位
+		case "month":
+			rRULEString += "FREQ=MONTHLY;"
+			rRULEString += getICSEndInfo(meetingMailInfo)
+			rRULEString += "INTERVAL=" + repeatFrequencyTimes + ";"
+
+			if len(meetingMailInfo.RepeatConfig.RepeatFrequencyDays) != 0 {
+				//月単位 - 日
+				rRULEString += "BYMONTHDAY=" + getICSDays(meetingMailInfo.RepeatConfig.RepeatFrequencyDays)
+			} else {
+				//月単位 - N週のX曜日
+				rRULEString += "BYDAY=" + getICSWeekday(meetingMailInfo.RepeatConfig.RepeatFrequencyWeekday) + ";"
+				rRULEString += "BYSETPOS=" + getICSWeekTimes(meetingMailInfo.RepeatConfig.RepeatFrequencyWeekTimes)
+			}
+		//年単位
+		case "year":
+			rRULEString += "FREQ=YEARLY;"
+			rRULEString += getICSEndInfo(meetingMailInfo)
+			rRULEString += "BYMONTH=" + repeatFrequencyTimes + ";"
+
+			if len(meetingMailInfo.RepeatConfig.RepeatFrequencyDays) != 0 {
+				//年単位 - 日
+				rRULEString += "BYMONTHDAY=" + getICSDays(meetingMailInfo.RepeatConfig.RepeatFrequencyDays)
+			} else {
+				//年単位 - N週のX曜日
+				rRULEString += "BYDAY=" + getICSWeekday(meetingMailInfo.RepeatConfig.RepeatFrequencyWeekday) + ";"
+				rRULEString += "BYSETPOS=" + getICSWeekTimes(meetingMailInfo.RepeatConfig.RepeatFrequencyWeekTimes)
+			}
+		}
+	}
+
+	return rRULEString
+}
+
+//ICSファイル重複会議終了情報を取得
+func getICSEndInfo(meetingMailInfo *model.MeetingMailInfo) string {
+	endInfoString := ""
+	switch meetingMailInfo.RepeatConfig.EndType {
+	//終了日付
+	case "date":
+		endInfoString = "UNTIL=" + meetingMailInfo.EndValueAtYear + meetingMailInfo.EndValueAtMonth + meetingMailInfo.EndValueAtDay + "T091000Z;"
+	//N回のミーティング後に終了
+	case "times":
+		endValue := strconv.FormatInt(meetingMailInfo.RepeatConfig.EndValue, 10)
+		endInfoString = "COUNT=" + endValue + ";"
+	}
+
+	return endInfoString
+}
+
+//ICSファイル重複会議曜日情報を取得
+func getICSWeekday(weekDay int) string {
+	iCSWeekday := ""
+	switch weekDay {
+	case 1:
+		iCSWeekday = "MO"
+	case 2:
+		iCSWeekday = "TU"
+	case 3:
+		iCSWeekday = "WE"
+	case 4:
+		iCSWeekday = "TH"
+	case 5:
+		iCSWeekday = "FR"
+	case 6:
+		iCSWeekday = "SA"
+	case 0:
+		iCSWeekday = "SU"
+	}
+
+	return iCSWeekday
+}
+
+//ICSファイル重複会議曜日リスト情報を取得
+func getICSWeekdays(weekDays []int) string {
+	iCSWeekdays := ""
+	for _, weekDay := range weekDays {
+		iCSWeekdays += getICSWeekday(weekDay) + ","
+	}
+
+	return strings.TrimRight(iCSWeekdays, ",")
+}
+
+//ICSファイル重複会議日リスト情報を取得
+func getICSDays(days []int) string {
+	iCSDays := ""
+	for _, day := range days {
+		iCSDays += strconv.Itoa(day) + ","
+	}
+
+	return strings.TrimRight(iCSDays, ",")
+}
+
+//ICSファイル重複会議N週情報を取得
+func getICSWeekTimes(weekTimes int) string {
+	iCSWeekTimes := ""
+	if weekTimes == 5 {
+		iCSWeekTimes = "-1"
+	} else {
+		iCSWeekTimes = strconv.Itoa(weekTimes)
+	}
+
+	return iCSWeekTimes
+}
+
+//メール重複情報を作成
+func makeRepeatMeetingInfo(T i18n.TranslateFunc, meetingMailInfo *model.MeetingMailInfo) string {
+	repeatInfoString := ""
+
+	if meetingMailInfo.AddRepeatInfo == true {
+		repeatFrequencyTimes := strconv.Itoa(meetingMailInfo.RepeatConfig.RepeatFrequencyTimes)
+		switch meetingMailInfo.RepeatConfig.RepeatType {
+		//日単位
+		case "day":
+			if meetingMailInfo.RepeatConfig.RepeatFrequencyTimesType == "everyday" {
+				//平日
+				repeatInfoString = T("api.meeting.mail.repeat_type.everyday")
+			} else {
+				repeatInfoString = T("api.meeting.mail.repeat_type.day", map[string]interface{}{"RepeatDay": repeatFrequencyTimes})
+			}
+		//週単位
+		case "week":
+			repeatFrequencyWeekdays := getDisplayWeekdays(T, meetingMailInfo.RepeatConfig.RepeatFrequencyWeekdays)
+			repeatInfoString = T("api.meeting.mail.repeat_type.week", map[string]interface{}{"RepeatWeek": repeatFrequencyTimes, "RepeatWeekDays": repeatFrequencyWeekdays})
+		//月単位
+		case "month":
+			if len(meetingMailInfo.RepeatConfig.RepeatFrequencyDays) != 0 {
+				//月単位 - 日
+				repeatFrequencyDays := getDisplayDays(T, meetingMailInfo.RepeatConfig.RepeatFrequencyDays)
+				repeatInfoString = T("api.meeting.mail.repeat_type.month_day", map[string]interface{}{"RepeatMonth": repeatFrequencyTimes, "RepeatDays": repeatFrequencyDays})
+			} else {
+				//月単位 - N週のX曜日
+				repeatFrequencyWeekTimes := getDisplayWeekTimes(T, meetingMailInfo.RepeatConfig.RepeatFrequencyWeekTimes)
+				repeatFrequencyWeekday := getDisplayWeekday(T, meetingMailInfo.RepeatConfig.RepeatFrequencyWeekday)
+				repeatInfoString = T("api.meeting.mail.repeat_type.month_week", map[string]interface{}{"RepeatMonth": repeatFrequencyTimes, "RepeatWeekDay": repeatFrequencyWeekTimes + repeatFrequencyWeekday})
+			}
+		//年単位
+		case "year":
+			month := getDisplayMonth(T, meetingMailInfo.RepeatConfig.RepeatFrequencyTimes)
+
+			if len(meetingMailInfo.RepeatConfig.RepeatFrequencyDays) != 0 {
+				//年単位 - 日
+				repeatFrequencyDays := getDisplayDays(T, meetingMailInfo.RepeatConfig.RepeatFrequencyDays)
+				repeatInfoString = T("api.meeting.mail.repeat_type.year_day", map[string]interface{}{"RepeatYear": month, "RepeatDays": repeatFrequencyDays})
+			} else {
+				//年単位 - N週のX曜日
+				repeatFrequencyWeekTimes := getDisplayWeekTimes(T, meetingMailInfo.RepeatConfig.RepeatFrequencyWeekTimes)
+				repeatFrequencyWeekday := getDisplayWeekday(T, meetingMailInfo.RepeatConfig.RepeatFrequencyWeekday)
+				repeatInfoString = T("api.meeting.mail.repeat_type.year_week", map[string]interface{}{"RepeatYear": month, "RepeatWeekDay": repeatFrequencyWeekTimes + repeatFrequencyWeekday})
+			}
+		}
+
+		switch meetingMailInfo.RepeatConfig.EndType {
+		//終了しない
+		case "none":
+			repeatInfoString += T("api.meeting.mail.repeat_end_type.none", map[string]interface{}{
+				"RepeatStartAtYear": meetingMailInfo.StartAtYear, "RepeatStartAtMonth": meetingMailInfo.StartAtMonth, "RepeatStartAtDay": meetingMailInfo.StartAtDay})
+		//終了日付
+		case "date":
+			repeatInfoString += T("api.meeting.mail.repeat_end_type.date", map[string]interface{}{
+				"RepeatStartAtYear": meetingMailInfo.StartAtYear, "RepeatStartAtMonth": meetingMailInfo.StartAtMonth, "RepeatStartAtDay": meetingMailInfo.StartAtDay,
+				"RepeatEndAtYear": meetingMailInfo.EndValueAtYear, "RepeatEndAtMonth": meetingMailInfo.EndValueAtMonth, "RepeatEndAtDay": meetingMailInfo.EndValueAtDay})
+		//N回のミーティング後に終了
+		case "times":
+			endValue := strconv.FormatInt(meetingMailInfo.RepeatConfig.EndValue, 10)
+			repeatInfoString += T("api.meeting.mail.repeat_end_type.times", map[string]interface{}{
+				"RepeatStartAtYear": meetingMailInfo.StartAtYear, "RepeatStartAtMonth": meetingMailInfo.StartAtMonth, "RepeatStartAtDay": meetingMailInfo.StartAtDay, "RepeatTimes": endValue})
+		}
+
+		repeatInfoString += "<br/>"
+	}
+
+	return repeatInfoString
+}
+
+//表示する曜日情報を取得
+func getDisplayWeekday(T i18n.TranslateFunc, weekDay int) string {
+	displayWeekday := ""
+	switch weekDay {
+	case 1:
+		displayWeekday = T("api.meeting.Mon")
+	case 2:
+		displayWeekday = T("api.meeting.Tues")
+	case 3:
+		displayWeekday = T("api.meeting.Wed")
+	case 4:
+		displayWeekday = T("api.meeting.Thur")
+	case 5:
+		displayWeekday = T("api.meeting.Fri")
+	case 6:
+		displayWeekday = T("api.meeting.Sat")
+	case 0:
+		displayWeekday = T("api.meeting.Sun")
+	}
+
+	return displayWeekday
+}
+
+//表示する曜日リスト情報を取得
+func getDisplayWeekdays(T i18n.TranslateFunc, weekDays []int) string {
+	displayWeekdays := ""
+	for _, weekDay := range weekDays {
+		displayWeekdays += getDisplayWeekday(T, weekDay) + T("api.meeting.comma")
+	}
+
+	return strings.TrimRight(displayWeekdays, T("api.meeting.comma"))
+}
+
+//表示する日リスト情報を取得
+func getDisplayDays(T i18n.TranslateFunc, days []int) string {
+	displayDays := ""
+	for _, day := range days {
+		displayDays += T("api.meeting.day", map[string]interface{}{"Day": strconv.Itoa(day)}) + T("api.meeting.comma")
+	}
+
+	return strings.TrimRight(displayDays, T("api.meeting.comma"))
+}
+
+//表示するN週情報を取得
+func getDisplayWeekTimes(T i18n.TranslateFunc, weekTimes int) string {
+	displayWeekTimes := ""
+	switch weekTimes {
+	case 1:
+		displayWeekTimes = T("api.meeting.first")
+	case 2:
+		displayWeekTimes = T("api.meeting.second")
+	case 3:
+		displayWeekTimes = T("api.meeting.third")
+	case 4:
+		displayWeekTimes = T("api.meeting.fourth")
+	case 5:
+		displayWeekTimes = T("api.meeting.last")
+	}
+
+	return displayWeekTimes
+}
+
+//表示する月情報を取得
+func getDisplayMonth(T i18n.TranslateFunc, month int) string {
+	displayMonth := ""
+	switch month {
+	case 1:
+		displayMonth = T("January")
+	case 2:
+		displayMonth = T("February")
+	case 3:
+		displayMonth = T("March")
+	case 4:
+		displayMonth = T("April")
+	case 5:
+		displayMonth = T("May")
+	case 6:
+		displayMonth = T("June")
+	case 7:
+		displayMonth = T("July")
+	case 8:
+		displayMonth = T("August")
+	case 9:
+		displayMonth = T("September")
+	case 10:
+		displayMonth = T("October")
+	case 11:
+		displayMonth = T("November")
+	case 12:
+		displayMonth = T("December")
+	}
+
+	return displayMonth
+}
+
+//サーバエラー応答
+func makeServerErrResponse(T i18n.TranslateFunc) model.ResponseResult {
+	var responseResult model.ResponseResult
+	responseResult.Status = "NG"
+	responseResult.Type = "SERVER"
+	responseResult.Message = T("api.meeting.server_opt.app_error")
+	return responseResult
+}
+
+//会議に存在しないエラー応答
+func makeMeetingNotExistErrResponse(T i18n.TranslateFunc) model.ResponseResult {
+	var responseResult model.ResponseResult
+	responseResult.Status = "NG"
+	responseResult.Type = "SERVER"
+	responseResult.Message = T("api.meeting.meeting_not_exist.app_error")
+	return responseResult
+}
+
+//メールエラー応答
+func makeMailErrResponse(T i18n.TranslateFunc, failedMailAddrs []string) model.ResponseResult {
+	var responseResult model.ResponseResult
+	var errMessage string
+
+	for _, failedMailAddr := range failedMailAddrs {
+		errMessage += "「" + failedMailAddr + "」、"
+	}
+	errMessage = strings.TrimRight(errMessage, "、")
+
+	responseResult.Status = "NG"
+	responseResult.Type = "MAIL"
+	responseResult.Message = T("api.meeting.mail_send.app_error", map[string]interface{}{"FailedMailAddrs": errMessage})
+	return responseResult
+}
+
+//メール書式チェック
+func userMailCheck(usersData []*model.MeetingUserFromJson) bool {
+	if len(usersData) == 0 {
+		return true
+	}
+
+	for _, userData := range usersData {
+		if model.IsValidEmail(userData.UserMail) == false {
+			return false
+		}
+	}
+
+	return true
+}
+
+//メール書式エラー応答
+func makeMailFormatErrResponse(T i18n.TranslateFunc) model.ResponseResult {
+	var responseResult model.ResponseResult
+	responseResult.Status = "NG"
+	responseResult.Type = "MAIL_FORMAT"
+	responseResult.Message = T("api.meeting.mail_format.app_error")
+	return responseResult
+}
+
+//メールURLを作成
+func makeMeetingUrl(T i18n.TranslateFunc, meetingMailInfo *model.MeetingMailInfo) string {
+	meetingUrl := meetingMailInfo.MeetingUrl
+	meetingDetail := ""
+	replaceData := T("app.meeting.repeat.begin")
+
+	if meetingMailInfo.AddRepeatInfo == true {
+		repeatFrequencyTimes := strconv.Itoa(meetingMailInfo.RepeatConfig.RepeatFrequencyTimes)
+		switch meetingMailInfo.RepeatConfig.RepeatType {
+		//日単位
+		case "day":
+			if meetingMailInfo.RepeatConfig.RepeatFrequencyTimesType == "everyday" {
+				//平日
+				meetingDetail = T("api.meeting.mail.repeat_type.everyday")
+			} else {
+				meetingDetail = T("api.meeting.mail.repeat_type.day", map[string]interface{}{"RepeatDay": repeatFrequencyTimes})
+			}
+			meetingDetail = T("api.meeting.mail.repeat_day") + strings.Replace(meetingDetail, replaceData, "", 1)
+		//週単位
+		case "week":
+			repeatFrequencyWeekdays := getDisplayWeekdays(T, meetingMailInfo.RepeatConfig.RepeatFrequencyWeekdays)
+			meetingDetail = T("api.meeting.mail.repeat_type.week", map[string]interface{}{"RepeatWeek": repeatFrequencyTimes, "RepeatWeekDays": repeatFrequencyWeekdays})
+			meetingDetail = T("api.meeting.mail.repeat_week") + strings.Replace(meetingDetail, replaceData, "", 1)
+		//月単位
+		case "month":
+			if len(meetingMailInfo.RepeatConfig.RepeatFrequencyDays) != 0 {
+				//月単位 - 日
+				repeatFrequencyDays := getDisplayDays(T, meetingMailInfo.RepeatConfig.RepeatFrequencyDays)
+				meetingDetail = T("api.meeting.mail.repeat_type.month_day", map[string]interface{}{"RepeatMonth": repeatFrequencyTimes, "RepeatDays": repeatFrequencyDays})
+			} else {
+				//月単位 - N週のX曜日
+				repeatFrequencyWeekTimes := getDisplayWeekTimes(T, meetingMailInfo.RepeatConfig.RepeatFrequencyWeekTimes)
+				repeatFrequencyWeekday := getDisplayWeekday(T, meetingMailInfo.RepeatConfig.RepeatFrequencyWeekday)
+				meetingDetail = T("api.meeting.mail.repeat_type.month_week", map[string]interface{}{"RepeatMonth": repeatFrequencyTimes, "RepeatWeekDay": repeatFrequencyWeekTimes + repeatFrequencyWeekday})
+			}
+			meetingDetail = T("api.meeting.mail.repeat_month") + strings.Replace(meetingDetail, replaceData, "", 1)
+		//年単位
+		case "year":
+			month := getDisplayMonth(T, meetingMailInfo.RepeatConfig.RepeatFrequencyTimes)
+
+			if len(meetingMailInfo.RepeatConfig.RepeatFrequencyDays) != 0 {
+				//年単位 - 日
+				repeatFrequencyDays := getDisplayDays(T, meetingMailInfo.RepeatConfig.RepeatFrequencyDays)
+				meetingDetail = T("api.meeting.mail.repeat_type.year_day", map[string]interface{}{"RepeatYear": month, "RepeatDays": repeatFrequencyDays})
+			} else {
+				//年単位 - N週のX曜日
+				repeatFrequencyWeekTimes := getDisplayWeekTimes(T, meetingMailInfo.RepeatConfig.RepeatFrequencyWeekTimes)
+				repeatFrequencyWeekday := getDisplayWeekday(T, meetingMailInfo.RepeatConfig.RepeatFrequencyWeekday)
+				meetingDetail = T("api.meeting.mail.repeat_type.year_week", map[string]interface{}{"RepeatYear": month, "RepeatWeekDay": repeatFrequencyWeekTimes + repeatFrequencyWeekday})
+			}
+			meetingDetail = T("api.meeting.mail.repeat_year") + strings.Replace(meetingDetail, replaceData, "", 1)
+		}
+
+		meetingDetail += meetingMailInfo.StartAtHour + ":" + meetingMailInfo.StartAtMinute + " ~ " + meetingMailInfo.EndAtHour + ":" + meetingMailInfo.EndAtMinute
+	} else {
+		meetingDetail = meetingMailInfo.StartAtYear + "/" + meetingMailInfo.StartAtMonth + "/" + meetingMailInfo.StartAtDay + " " + meetingMailInfo.StartAtHour + ":" + meetingMailInfo.StartAtMinute +
+			" ~ " +
+			meetingMailInfo.EndAtYear + "/" + meetingMailInfo.EndAtMonth + "/" + meetingMailInfo.EndAtDay + " " + meetingMailInfo.EndAtHour + ":" + meetingMailInfo.EndAtMinute
+	}
+	meetingName := strings.ReplaceAll(meetingMailInfo.MeetingName, "-", "%2d")
+	meetingUrl = strings.ReplaceAll(meetingUrl, "-", "%2d")
+	meetingUrl += "?meetingDetail=" + utils.URLEncode(meetingDetail) + "#config.callDisplayName=" + utils.URLEncode("\"") + meetingName + utils.URLEncode("\"")
+
+	return meetingUrl
+}
+
+/* Ryobi Systems CloudOffice Meeting Mod 20220424 START */
+//メールを送るかどうか
+func sendMailCheck(c *Context) bool {
+	SendEmailNotifications := *c.App.Config().EmailSettings.SendEmailNotifications
+	SMTPServer := *c.App.Config().EmailSettings.SMTPServer
+	SMTPPort := *c.App.Config().EmailSettings.SMTPPort
+
+	if !SendEmailNotifications || SMTPServer == "localhost" || SMTPPort == "10025" {
+		return false
+	}
+
+	return true
+}
+
+/* Ryobi Systems CloudOffice Meeting Mod 20220424 END */
Index: mattermost-server-7.8.1/api4/meeting_mng.go
===================================================================
--- mattermost-server-7.8.1/api4/meeting_mng.go	(nonexistent)
+++ mattermost-server-7.8.1/api4/meeting_mng.go	(revision 4485)
@@ -0,0 +1,410 @@
+//Copyright 2021 Ryobi Systems Co., Ltd. All Rights Reserved.
+
+package api4
+
+import (
+	"github.com/mattermost/mattermost-server/v6/shared/i18n"
+	mailservice "github.com/mattermost/mattermost-server/v6/shared/mail"
+	"net/mail"
+	"strconv"
+	"strings"
+
+	// "io"
+	// "bytes"
+	// "strconv"
+	// "strings"
+	"net/http"
+
+	//  "fmt"
+
+	"github.com/mattermost/mattermost-server/v6/model"
+)
+
+// const (
+// 	meetingMailNotSend = iota
+// 	meetingMailTypeInvite
+// 	meetingMailTypeChange
+// 	meetingMailTypeTerminate
+// )
+
+// type mailResult struct {
+// 	mailAddr		string
+// 	sendResult		bool
+// }
+
+func (api *API) InitMeetingMng() {
+	api.BaseRoutes.MeetingMng.Handle("", api.APISessionRequired(getMeetingMngList)).Methods("POST")
+	api.BaseRoutes.MeetingMngDetail.Handle("", api.APISessionRequired(getMeetingMngDetail)).Methods("GET")
+	api.BaseRoutes.MeetingMngDelete.Handle("", api.APISessionRequired(meetingMngDelete)).Methods("POST")
+}
+
+//会議を取得(会議項目IDを使用)
+func getMeetingMngList(c *Context, w http.ResponseWriter, r *http.Request) {
+	meetingMngFromJsonData := model.MeetingMngDataFromJson(r.Body)
+	T := i18n.GetUserTranslations(getUserLocale(c, c.AppContext.Session().UserId))
+
+	// //会議を取得
+	meetingToJson, err := c.App.GetMeetingMng(c.AppContext, meetingMngFromJsonData)
+	if err != nil {
+		var responseResult model.ResponseResult
+		if err.StatusCode == http.StatusNoContent {
+			responseResult = makeServerMngErrResponse(T)
+		} else {
+			responseResult = makeSearchMngErrResponse(T)
+		}
+		w.Write([]byte(responseResult.ToJson()))
+		return
+	}
+
+	//会議の取得に成功
+	w.Write([]byte(model.MeetingMngListToJson(makeSearchMngListResponse(meetingToJson))))
+	return
+}
+
+//会議詳細を取得(会議項目IDを使用)
+func getMeetingMngDetail(c *Context, w http.ResponseWriter, r *http.Request) {
+	meeting_item_id := r.URL.Query().Get("meeting_item_id")
+	T := i18n.GetUserTranslations(getUserLocale(c, c.AppContext.Session().UserId))
+
+	// //会議を取得
+	MeetingMngDetailToJson, err := c.App.GetMeetingMngDetail(c.AppContext, meeting_item_id)
+	if err != nil {
+		responseResult := makeSearchMngErrResponse(T)
+		w.Write([]byte(responseResult.ToJson()))
+		return
+	}
+
+	//会議の取得に成功
+	w.Write([]byte(model.MeetingMngDetailInfoToJson(makeSearchMngDetailResponse(MeetingMngDetailToJson))))
+	return
+}
+
+//会議を取得(会議項目IDを使用)
+func meetingMngDelete(c *Context, w http.ResponseWriter, r *http.Request) {
+	meetingMngDeleteFromJsonData := model.MeetingMngDeleteDataFromJson(r.Body)
+
+	T := i18n.GetUserTranslations(getUserLocale(c, c.AppContext.Session().UserId))
+	var responseResult model.ResponseResult
+
+	//メール送信機能
+	for _, MeetingItemId := range meetingMngDeleteFromJsonData.MeetingItemIds {
+
+		//現在の会議のユーザを取得
+		meetingMngUsers, err := c.App.GetMeetingMngUsersByMeetingItemIdFormail(MeetingItemId)
+		if err != nil {
+			responseResult = makeServerMngErrResponse(T)
+			w.Write([]byte(responseResult.ToJson()))
+			return
+		}
+
+		//会議項目IDを使用して、会議を削除
+		meetingMailInfo, err := c.App.MeetingMngDelete(MeetingItemId)
+		if err != nil {
+			responseResult = makeServerMngErrResponse(T)
+			w.Write([]byte(responseResult.ToJson()))
+			return
+		}
+		if meetingMailInfo == nil {
+			continue
+		}
+
+		/* Ryobi Systems CloudOffice MeetingMng Mod 20220224 START */
+		//メールを送るかどうか
+		isSendMail := sendMailCheckMng(c)
+		if !meetingMngDeleteFromJsonData.SendMailFlg && isSendMail {
+			//会議中止メールを送る、主催者メールを追加
+			meetingUsersForMail := setMeetingMngUsersForMail(meetingMngUsers, meetingMailTypeTerminate, c)
+			_, failedMailAddrs := sendMultiThreadMailMng(c, T, meetingUsersForMail, meetingMailInfo)
+
+			//送信に失敗
+			if len(failedMailAddrs) != 0 {
+				responseResult = makeMailErrResponse(T, failedMailAddrs)
+				w.Write([]byte(responseResult.ToJson()))
+				return
+			}
+		}
+		/* Ryobi Systems CloudOffice MeetingMng Mod 20220224 END */
+	}
+	//会議の削除に成功
+	responseResult.Status = "OK"
+	w.Write([]byte(responseResult.ToJson()))
+
+	return
+}
+
+//ユーザ送信情報をフォーマット
+func setMeetingMngUsersForMail(meetingMngUsers []*model.MeetingMngUser, mailMode int, c *Context) []*model.MeetingMngUserFromJson {
+	var meetingMngUsersForMail []*model.MeetingMngUserFromJson
+	for _, meetingUser := range meetingMngUsers {
+		var item model.MeetingMngUserFromJson
+		item.UserId = meetingUser.UserId
+		item.UserName = meetingUser.LastName + meetingUser.FirstName
+		item.UserMail = meetingUser.UserMail
+		item.SendMailMode = mailMode
+		item.UserType = meetingUser.UserType
+
+		meetingMngUsersForMail = append(meetingMngUsersForMail, &item)
+	}
+	return meetingMngUsersForMail
+}
+
+//マルチスレッド送信
+func sendMultiThreadMailMng(c *Context, T i18n.TranslateFunc, meetingMngUsersForMail []*model.MeetingMngUserFromJson, meetingMailInfo *model.MeetingMailInfo) ([]string, []string) {
+	var failedMailAddrs []string
+	var successMailAddrs []string
+	var meetingUserForMail *model.MeetingMngUserFromJson
+	var cChannel (chan mailResult)
+	listLen := len(meetingMngUsersForMail)
+	total := 0
+	users := ""
+	hostUser := ""
+	for _, meetingUser := range meetingMngUsersForMail {
+		// 主催者
+		if meetingUser.UserType == "host" {
+			hostUser = meetingUser.UserName
+			continue
+		}
+		// 管理者
+		if meetingUser.UserType == "admin" {
+			continue
+		}
+		//　招待者
+		if users == "" {
+			users += T("api.meeting.sikaku") + meetingUser.UserName
+		} else {
+			users += T("api.meeting.comma") + meetingUser.UserName
+		}
+	}
+
+	for _, meetingUserForMail = range meetingMngUsersForMail {
+		cChannel = make(chan mailResult)
+
+		go func(meetingUserForMail *model.MeetingMngUserFromJson) {
+			var result mailResult
+			result.mailAddr = meetingUserForMail.UserMail
+
+			TForMail := i18n.GetUserTranslations(getUserLocale(c, meetingUserForMail.UserId))
+			errForMail := sendMeetingMngMail(c, TForMail, meetingUserForMail.SendMailMode, meetingUserForMail.UserMail, meetingMailInfo, users, hostUser)
+
+			if errForMail != nil {
+				result.sendResult = false
+			} else {
+				result.sendResult = true
+			}
+
+			cChannel <- result
+			total++
+
+			if total == listLen {
+				close(cChannel)
+			}
+		}(meetingUserForMail)
+	}
+
+	for mailResultInfo := range cChannel {
+		if mailResultInfo.sendResult == true {
+			//送信に成功したメールリスト
+			successMailAddrs = append(successMailAddrs, mailResultInfo.mailAddr)
+		} else {
+			//送信に失敗したメールリスト
+			failedMailAddrs = append(failedMailAddrs, mailResultInfo.mailAddr)
+		}
+	}
+
+	return successMailAddrs, failedMailAddrs
+}
+
+//送信処理
+func sendMeetingMngMail(c *Context, T i18n.TranslateFunc, mailType int, mailTo string, meetingMailInfo *model.MeetingMailInfo, users string, hostUser string) error {
+	mailConfig := c.App.Srv().MailServiceConfig()
+	switch mailType {
+	//送信なし
+	case meetingMailNotSend:
+		return nil //会議中止メール
+	case meetingMailTypeTerminate:
+		mailTemplate := "api.meeting.mail.delete_template"
+		fromMail := mail.Address{Name: *c.App.Config().EmailSettings.FeedbackName, Address: *c.App.Config().EmailSettings.FeedbackEmail}
+		// 招待者内場合
+		if users == "" {
+			users = T("api.meeting.mail.nousers")
+		}
+		terminateMailContent := T(mailTemplate,
+			map[string]interface{}{
+				"MeetingName": meetingMailInfo.MeetingName, "HostName": hostUser, "Users": users,
+				"MeetingInfo": makeMeetingInfo(T, meetingMailInfo)})
+		return mailservice.SendMeetingMail(mailTo, T("api.meeting.mail.delete_title_prefix"), terminateMailContent, nil, mailConfig, "", fromMail)
+	}
+
+	return nil
+}
+
+//メール重複情報を作成
+func makeMeetingInfo(T i18n.TranslateFunc, meetingMailInfo *model.MeetingMailInfo) string {
+	repeatInfoString := ""
+
+	if meetingMailInfo.AddRepeatInfo == true {
+		repeatFrequencyTimes := strconv.Itoa(meetingMailInfo.RepeatConfig.RepeatFrequencyTimes)
+		repeatInfoString = T("api.meeting.mail.repeat_unit_"+meetingMailInfo.RepeatConfig.RepeatType) + "<br />"
+		switch meetingMailInfo.RepeatConfig.RepeatType {
+		//日単位
+		case "day":
+			if meetingMailInfo.RepeatConfig.RepeatFrequencyTimesType == "everyday" {
+				//平日
+				repeatInfoString += T("api.meeting.mail.repeat_everyday")
+			} else {
+				repeatInfoString += T("api.meeting.mail.repeat_frequency_day", map[string]interface{}{"RepeatDay": repeatFrequencyTimes})
+			}
+		//週単位
+		case "week":
+			repeatFrequencyWeekdays := getMeetingWeekdays(T, meetingMailInfo.RepeatConfig.RepeatFrequencyWeekdays)
+			repeatInfoString += T("api.meeting.mail.repeat_frequency_week", map[string]interface{}{"RepeatWeek": repeatFrequencyTimes})
+			repeatInfoString += "<br/>"
+			repeatInfoString += T("api.meeting.mail.repeat_frequency_weekdays", map[string]interface{}{"RepeatWeekDays": repeatFrequencyWeekdays})
+		//月単位
+		case "month":
+			if len(meetingMailInfo.RepeatConfig.RepeatFrequencyDays) != 0 {
+				//月単位 - 日
+				repeatFrequencyDays := getDisplayDays(T, meetingMailInfo.RepeatConfig.RepeatFrequencyDays)
+				repeatInfoString += T("api.meeting.mail.repeat_frequency_month_day", map[string]interface{}{"RepeatMonth": repeatFrequencyTimes, "RepeatDays": repeatFrequencyDays})
+			} else {
+				//月単位 - N週のX曜日
+				repeatFrequencyWeekTimes := getDisplayWeekTimes(T, meetingMailInfo.RepeatConfig.RepeatFrequencyWeekTimes)
+				repeatFrequencyWeekday := getMeetingWeekday(T, meetingMailInfo.RepeatConfig.RepeatFrequencyWeekday)
+				repeatInfoString += T("api.meeting.mail.repeat_frequency_month_week", map[string]interface{}{"RepeatMonth": repeatFrequencyTimes, "RepeatWeekDay": repeatFrequencyWeekTimes + repeatFrequencyWeekday})
+			}
+		//年単位
+		case "year":
+			month := getDisplayMonth(T, meetingMailInfo.RepeatConfig.RepeatFrequencyTimes)
+
+			if len(meetingMailInfo.RepeatConfig.RepeatFrequencyDays) != 0 {
+				//年単位 - 日
+				repeatFrequencyDays := getDisplayDays(T, meetingMailInfo.RepeatConfig.RepeatFrequencyDays)
+				repeatInfoString += T("api.meeting.mail.repeat_frequency_year_day", map[string]interface{}{"RepeatYear": month, "RepeatDays": repeatFrequencyDays})
+			} else {
+				//年単位 - N週のX曜日
+				repeatFrequencyWeekTimes := getDisplayWeekTimes(T, meetingMailInfo.RepeatConfig.RepeatFrequencyWeekTimes)
+				repeatFrequencyWeekday := getMeetingWeekday(T, meetingMailInfo.RepeatConfig.RepeatFrequencyWeekday)
+				repeatInfoString += T("api.meeting.mail.repeat_frequency_year_week", map[string]interface{}{"RepeatYear": month, "RepeatWeekDay": repeatFrequencyWeekTimes + repeatFrequencyWeekday})
+			}
+		}
+		repeatInfoString += "<br/>"
+
+		switch meetingMailInfo.RepeatConfig.EndType {
+		//終了しない
+		case "none":
+			repeatInfoString += T("api.meeting.mail.repeat_over_none", map[string]interface{}{
+				"RepeatStartAtYear": meetingMailInfo.StartAtYear, "RepeatStartAtMonth": meetingMailInfo.StartAtMonth, "RepeatStartAtDay": meetingMailInfo.StartAtDay})
+		//終了日付
+		case "date":
+			repeatInfoString += T("api.meeting.mail.repeat_over_date", map[string]interface{}{
+				"RepeatStartAtYear": meetingMailInfo.StartAtYear, "RepeatStartAtMonth": meetingMailInfo.StartAtMonth, "RepeatStartAtDay": meetingMailInfo.StartAtDay,
+				"RepeatEndAtYear": meetingMailInfo.EndValueAtYear, "RepeatEndAtMonth": meetingMailInfo.EndValueAtMonth, "RepeatEndAtDay": meetingMailInfo.EndValueAtDay})
+		//N回のミーティング後に終了
+		case "times":
+			endValue := strconv.FormatInt(meetingMailInfo.RepeatConfig.EndValue, 10)
+			repeatInfoString += T("api.meeting.mail.repeat_over_times", map[string]interface{}{
+				"RepeatStartAtYear": meetingMailInfo.StartAtYear, "RepeatStartAtMonth": meetingMailInfo.StartAtMonth, "RepeatStartAtDay": meetingMailInfo.StartAtDay, "RepeatTimes": endValue})
+		}
+
+	} else {
+		repeatInfoString += T("api.meeting.mail.startat", map[string]interface{}{"StartAtYear": meetingMailInfo.StartAtYear,
+			"StartAtMonth": meetingMailInfo.StartAtMonth, "StartAtDay": meetingMailInfo.StartAtDay, "StartAtHour": meetingMailInfo.StartAtHour, "StartAtMinute": meetingMailInfo.StartAtMinute})
+
+		repeatInfoString += "<br />"
+		repeatInfoString += T("api.meeting.mail.endat", map[string]interface{}{"EndAtYear": meetingMailInfo.EndAtYear,
+			"EndAtMonth": meetingMailInfo.EndAtMonth, "EndAtDay": meetingMailInfo.EndAtDay, "EndAtHour": meetingMailInfo.EndAtHour, "EndAtMinute": meetingMailInfo.EndAtMinute})
+
+	}
+	repeatInfoString += "<br />"
+
+	return repeatInfoString
+}
+
+//表示する曜日情報を取得
+func getMeetingWeekday(T i18n.TranslateFunc, weekDay int) string {
+	displayWeekday := ""
+	switch weekDay {
+	case 1:
+		displayWeekday = T("api.meeting.monday")
+	case 2:
+		displayWeekday = T("api.meeting.tuesday")
+	case 3:
+		displayWeekday = T("api.meeting.wednesday")
+	case 4:
+		displayWeekday = T("api.meeting.thursday")
+	case 5:
+		displayWeekday = T("api.meeting.friday")
+	case 6:
+		displayWeekday = T("api.meeting.saturday")
+	case 0:
+		displayWeekday = T("api.meeting.sunday")
+	}
+
+	return displayWeekday
+}
+
+//表示する曜日リスト情報を取得
+func getMeetingWeekdays(T i18n.TranslateFunc, weekDays []int) string {
+	displayWeekdays := ""
+	for _, weekDay := range weekDays {
+		if displayWeekdays == "" {
+			displayWeekdays += T("api.meeting.sikaku") + getMeetingWeekday(T, weekDay)
+		} else {
+			displayWeekdays += T("api.meeting.comma") + getMeetingWeekday(T, weekDay)
+		}
+	}
+
+	return strings.TrimRight(displayWeekdays, T("api.meeting.comma"))
+}
+
+//会議リスト応答
+func makeSearchMngListResponse(meetingMngToJson []*model.MeetingMngToJson) model.ResponseMeetingList {
+	var responseResult model.ResponseMeetingList
+	responseResult.Status = "OK"
+	responseResult.Type = "SERVER"
+	responseResult.MeetingsData = meetingMngToJson
+	return responseResult
+}
+
+//会議詳細応答
+func makeSearchMngDetailResponse(meetingMngDetailToJson *model.MeetingMngDetailToJson) model.ResponseMeetingDetail {
+	var responseResult model.ResponseMeetingDetail
+	responseResult.Status = "OK"
+	responseResult.Type = "SERVER"
+	responseResult.MeetingData = meetingMngDetailToJson
+	return responseResult
+}
+
+//サーバエラー応答
+func makeSearchMngErrResponse(T i18n.TranslateFunc) model.ResponseResult {
+	var responseResult model.ResponseResult
+	responseResult.Status = "NG"
+	responseResult.Type = "SERVER"
+	responseResult.Message = T("api.meeting.search.app_error")
+	return responseResult
+}
+
+//サーバエラー応答
+func makeServerMngErrResponse(T i18n.TranslateFunc) model.ResponseResult {
+	var responseResult model.ResponseResult
+	responseResult.Status = "NG"
+	responseResult.Type = "SERVER"
+	responseResult.Message = T("api.meeting.server.app_error")
+	return responseResult
+}
+
+/* Ryobi Systems CloudOffice MeetingMng Mod 20220224 START */
+//メールを送るかどうか
+func sendMailCheckMng(c *Context) bool {
+	SendEmailNotifications := *c.App.Config().EmailSettings.SendEmailNotifications
+	SMTPServer := *c.App.Config().EmailSettings.SMTPServer
+	SMTPPort := *c.App.Config().EmailSettings.SMTPPort
+
+	if !SendEmailNotifications || SMTPServer == "localhost" || SMTPPort == "10025" {
+		return false
+	}
+
+	return true
+}
+
+/* Ryobi Systems CloudOffice MeetingMng Mod 20220224 END */
Index: mattermost-server-7.8.1/api4/meeting_status.go
===================================================================
--- mattermost-server-7.8.1/api4/meeting_status.go	(nonexistent)
+++ mattermost-server-7.8.1/api4/meeting_status.go	(revision 4485)
@@ -0,0 +1,58 @@
+//Copyright 2021 Ryobi Systems Co., Ltd. All Rights Reserved.
+
+package api4
+
+import (
+	"github.com/mattermost/mattermost-server/v6/model"
+	"net/http"
+)
+
+func (api *API) InitMeetingStatus() {
+	api.BaseRoutes.MeetingStatus.Handle("", api.APISessionRequired(getMeetingStatusList)).Methods("POST")
+	api.BaseRoutes.MeetingEnd.Handle("", api.APISessionRequired(getMeetingEndList)).Methods("POST")
+}
+
+//Web会議状態レポートを取得
+func getMeetingStatusList(c *Context, w http.ResponseWriter, r *http.Request) {
+	//会議を取得
+	meetingToJson, _, ifSuccess := c.App.GetMeetingStatus()
+
+	//会議の取得に成功
+	if ifSuccess && meetingToJson == nil {
+		w.Write([]byte("nullData"))
+	}
+
+	if !ifSuccess {
+		w.Write([]byte("errData"))
+	}
+
+	if ifSuccess && meetingToJson != nil {
+		w.Write([]byte(model.MeetingStatusListToJson(meetingToJson)))
+	}
+
+	return
+}
+
+//Web会議履歴一覧を取得
+func getMeetingEndList(c *Context, w http.ResponseWriter, r *http.Request) {
+	//会議を取得
+	meetingEndFromJsonData := model.MeetingEndDataFromJson(r.Body)
+
+	meetingToJson, _, ifSuccess := c.App.GetMeetingEnd(meetingEndFromJsonData)
+
+	//会議の取得に成功
+
+	if ifSuccess && meetingToJson == nil {
+		w.Write([]byte("nullData"))
+	}
+
+	if !ifSuccess {
+		w.Write([]byte("errData"))
+	}
+
+	if ifSuccess && meetingToJson != nil {
+		w.Write([]byte(model.MeetingEndListToJson(meetingToJson)))
+	}
+
+	return
+}
Index: mattermost-server-7.8.1/api4/post.go
===================================================================
--- mattermost-server-7.8.1/api4/post.go	(revision 4484)
+++ mattermost-server-7.8.1/api4/post.go	(revision 4485)
@@ -5,6 +5,7 @@
 
 import (
 	"encoding/json"
+	"github.com/mattermost/mattermost-server/v6/store"
 	"net/http"
 	"strconv"
 	"time"
@@ -97,9 +98,17 @@
 	}
 	auditRec.Success()
 	auditRec.AddEventResultState(rp)
+	userId := c.AppContext.Session().UserId
+
 	auditRec.AddEventObjectType("post")
 
-	if setOnlineBool {
+	var status *model.Status
+	isMeeting := false
+	status, err = c.App.GetStatus(userId)
+	if err == nil && status.Status == model.STATUS_MEETING {
+		isMeeting = true
+	}
+	if !isMeeting && setOnlineBool {
 		c.App.SetStatusOnline(c.AppContext.Session().UserId, false)
 	}
 
@@ -257,6 +266,7 @@
 
 	c.App.AddCursorIdsForPostList(list, afterPost, beforePost, since, page, perPage, collapsedThreads)
 	clientPostList := c.App.PreparePostListForClient(c.AppContext, list)
+
 	clientPostList, err = c.App.SanitizePostListMetadataForUser(c.AppContext, clientPostList, c.AppContext.Session().UserId)
 	if err != nil {
 		c.Err = err
@@ -263,11 +273,66 @@
 		return
 	}
 
+	//replace poll data when client fetch more posts
+	for id, p := range clientPostList.Posts {
+		p = replaceFieldsIfNecessary(p, c.App.Srv().GetStore())
+
+		clientPostList.Posts[id] = p
+	}
 	if err := clientPostList.EncodeJSON(w); err != nil {
 		mlog.Warn("Error while writing response", mlog.Err(err))
 	}
 }
 
+func replaceFieldsIfNecessary(p *model.Post, s store.Store) *model.Post {
+	if len(p.Attachments()) == 0 {
+		return p
+	}
+	anonymous, _ := p.GetProp("anonymous").(bool)
+	status, _ := p.GetProp("status").(string)
+	attachment := p.Attachments()[0]
+	var postId string
+	if p.OriginalId != "" {
+		postId = p.OriginalId
+	} else {
+		postId = p.Id
+	}
+	pollFields, _ := s.PollField().GetPollFields(postId)
+	if len(pollFields) == 0 {
+		return p
+	}
+	model.ParseSlackAttachment(p, getReplaceAttachment(attachment, pollFields, anonymous, status))
+	return p
+}
+
+func getReplaceAttachment(attachment *model.SlackAttachment, fields []*model.PollFields, anonymous bool, status string) []*model.SlackAttachment {
+	pollFields := []*model.SlackAttachmentField{}
+	for _, field := range fields {
+		value := field.Voter
+		webValue := field.Voter
+		if status != "end" {
+			webValue = ""
+			value = ""
+		}
+		if anonymous {
+			webValue = ""
+			value = ""
+		}
+		pollFields = append(pollFields, &model.SlackAttachmentField{
+			Short:    true,
+			Title:    field.Answer,
+			Value:    value,
+			WebValue: webValue,
+		})
+	}
+	return []*model.SlackAttachment{{
+		AuthorName: attachment.AuthorName,
+		Title:      attachment.Title,
+		Text:       attachment.Text,
+		Actions:    attachment.Actions,
+		Fields:     pollFields,
+	}}
+}
 func getPostsForChannelAroundLastUnread(c *Context, w http.ResponseWriter, r *http.Request) {
 	c.RequireUserId().RequireChannelId()
 	if c.Err != nil {
@@ -325,7 +390,11 @@
 		c.Err = err
 		return
 	}
-
+	//replace poll data when client fetch more posts
+	for id, p := range clientPostList.Posts {
+		p = replaceFieldsIfNecessary(p, c.App.Srv().GetStore())
+		clientPostList.Posts[id] = p
+	}
 	if etag != "" {
 		w.Header().Set(model.HeaderEtagServer, etag)
 	}
@@ -591,6 +660,11 @@
 		c.Err = err
 		return
 	}
+	//replace poll data when client search for a certain part posts
+	for id, p := range list.Posts {
+		p = replaceFieldsIfNecessary(p, c.App.Srv().GetStore())
+		list.Posts[id] = p
+	}
 	if list.FirstInaccessiblePostTime != 0 {
 		// e.g. if root post is archived in a cloud plan,
 		// we don't want to display the thread,
@@ -624,7 +698,10 @@
 		c.Err = err
 		return
 	}
-
+	for id, p := range clientPostList.Posts {
+		p = replaceFieldsIfNecessary(p, c.App.Srv().GetStore())
+		clientPostList.Posts[id] = p
+	}
 	w.Header().Set(model.HeaderEtagServer, clientPostList.Etag())
 
 	if err := clientPostList.EncodeJSON(w); err != nil {
Index: mattermost-server-7.8.1/api4/status.go
===================================================================
--- mattermost-server-7.8.1/api4/status.go	(revision 4484)
+++ mattermost-server-7.8.1/api4/status.go	(revision 4485)
@@ -17,6 +17,8 @@
 	api.BaseRoutes.User.Handle("/status", api.APISessionRequired(updateUserStatus)).Methods("PUT")
 	api.BaseRoutes.User.Handle("/status/custom", api.APISessionRequired(updateUserCustomStatus)).Methods("PUT")
 	api.BaseRoutes.User.Handle("/status/custom", api.APISessionRequired(removeUserCustomStatus)).Methods("DELETE")
+	api.BaseRoutes.User.Handle("/time", api.APISessionRequired(getUserWebMeetingStatus)).Methods("POST")
+	api.BaseRoutes.User.Handle("/change/status", api.APISessionRequired(changeUserSpecifiedStatus)).Methods("POST")
 
 	// Both these handlers are for removing the recent custom status but the one with the POST method should be preferred
 	// as DELETE method doesn't support request body in the mobile app.
@@ -79,6 +81,48 @@
 	w.Write(js)
 }
 
+func getUserWebMeetingStatus(c *Context, w http.ResponseWriter, r *http.Request) {
+	user := model.UserIdFromJson(r.Body)
+
+	if len(user.Id) == 0 {
+		c.SetInvalidParam("user_id")
+		return
+	}
+
+	if len(user.Id) != 26 {
+		c.SetInvalidParam("user_id")
+		return
+	}
+
+	status, _ := c.App.GetUserWebMeetingStatus(user.Id)
+	state := model.ToJSON(status)
+	w.Write(state)
+
+}
+
+func changeUserSpecifiedStatus(c *Context, w http.ResponseWriter, r *http.Request) {
+	newStatus := model.SpecifiedStatusFromJson(r.Body)
+
+	if len(newStatus.UserId) == 0 {
+		c.SetInvalidParam("user_id")
+		return
+	}
+
+	if len(newStatus.UserId) != 26 {
+		c.SetInvalidParam("user_id")
+		return
+	}
+
+	userStatus, _ := c.App.GetStatus(newStatus.UserId)
+	if userStatus.Status != model.STATUS_MEETING {
+		userStatus.Status = newStatus.Status
+		userStatus.Manual = newStatus.Manual
+		userStatus.LastActivityAt = newStatus.LastActivityAt
+		c.App.Srv().Platform().SaveAndBroadcastStatus(userStatus)
+	}
+	return
+}
+
 func updateUserStatus(c *Context, w http.ResponseWriter, r *http.Request) {
 	c.RequireUserId()
 	if c.Err != nil {
@@ -114,6 +158,8 @@
 		c.App.SetStatusOffline(c.Params.UserId, true)
 	case "away":
 		c.App.SetStatusAwayIfNeeded(c.Params.UserId, true)
+	case "meeting":
+		c.App.SetStatusMeetingIfNeeded(c.Params.UserId, true)
 	case "dnd":
 		c.App.SetStatusDoNotDisturbTimed(c.Params.UserId, status.DNDEndTime)
 	default:
Index: mattermost-server-7.8.1/api4/team.go
===================================================================
--- mattermost-server-7.8.1/api4/team.go	(revision 4484)
+++ mattermost-server-7.8.1/api4/team.go	(revision 4485)
@@ -9,6 +9,7 @@
 	"encoding/json"
 	"fmt"
 	"io"
+	"math"
 	"net/http"
 	"regexp"
 	"strconv"
@@ -56,6 +57,7 @@
 	api.BaseRoutes.TeamMembers.Handle("", api.APISessionRequired(getTeamMembers)).Methods("GET")
 	api.BaseRoutes.TeamMembers.Handle("/ids", api.APISessionRequired(getTeamMembersByIds)).Methods("POST")
 	api.BaseRoutes.TeamMembersForUser.Handle("", api.APISessionRequired(getTeamMembersForUser)).Methods("GET")
+	api.BaseRoutes.TeamForUser.Handle("/fetchMultiTenancyInfo", api.APISessionRequired(getTeamMemberAndConfigForUser)).Methods("GET")
 	api.BaseRoutes.TeamMembers.Handle("", api.APISessionRequired(addTeamMember)).Methods("POST")
 	api.BaseRoutes.Teams.Handle("/members/invite", api.APISessionRequired(addUserToTeamFromInvite)).Methods("POST")
 	api.BaseRoutes.TeamMembers.Handle("/batch", api.APISessionRequired(addTeamMembers)).Methods("POST")
@@ -652,7 +654,64 @@
 
 	w.Write(js)
 }
+func getTeamMemberAndConfigForUser(c *Context, w http.ResponseWriter, r *http.Request) {
+	c.RequireUserId()
+	c.RequireTeamId()
+	if c.Err != nil {
+		c.Err = model.NewAppError("getTeamMemberAndConfigForUser", "api.unable_to_read_file_from_backend", nil, "", http.StatusBadRequest)
+		return
+	}
 
+	if !c.App.SessionHasPermissionToUser(*c.AppContext.Session(), c.Params.UserId) && !c.App.SessionHasPermissionTo(*c.AppContext.Session(), model.PermissionReadOtherUsersTeams) {
+		c.Err = model.NewAppError("getTeamMemberAndConfigForUser", "api.unable_to_read_file_from_backend", nil, "", http.StatusBadRequest)
+		return
+	}
+
+	canSee, err := c.App.UserCanSeeOtherUser(c.AppContext.Session().UserId, c.Params.UserId)
+	if err != nil {
+		c.Err = model.NewAppError("getTeamMemberAndConfigForUser", "api.unable_to_read_file_from_backend", nil, "", http.StatusBadRequest)
+		return
+	}
+
+	if !canSee {
+		c.Err = model.NewAppError("getTeamMemberAndConfigForUser", "api.unable_to_read_file_from_backend", nil, "", http.StatusBadRequest)
+		return
+	}
+
+	members, err := c.App.GetTeamMembersForUser(c.Params.UserId, "", true)
+	if err != nil {
+		c.Err = model.NewAppError("getTeamMemberAndConfigForUser", "api.unable_to_read_file_from_backend", nil, "", http.StatusBadRequest)
+		return
+	}
+	resultMap := make(map[string]interface{})
+	for _, member := range members {
+		if member.DeleteAt == 0 {
+			if member.TeamId != c.Params.TeamId {
+				continue
+			}
+			roles := ""
+
+			if member.Roles == "team_user" {
+				roles = "team_user"
+			}
+			if member.Roles == "team_user team_admin" {
+				roles = "team_admin"
+			}
+
+			resultMap = map[string]interface{}{
+				"roles":                     roles,
+				"teamId":                    member.TeamId,
+				"userId":                    member.UserId,
+				"isSystemAdmin":             c.IsSystemAdmin(),
+				"enableMultiTenancySupport": *c.App.Config().TeamSettings.EnableMultiTenancySupport,
+			}
+			break
+		}
+	}
+	str, _ := json.Marshal(resultMap)
+	w.Write([]byte(str))
+}
+
 func getTeamMembersByIds(c *Context, w http.ResponseWriter, r *http.Request) {
 	c.RequireTeamId()
 	if c.Err != nil {
@@ -981,6 +1040,7 @@
 	}
 
 	auditRec.Success()
+
 	ReturnStatusOK(w)
 }
 
@@ -1143,8 +1203,14 @@
 
 	if c.Params.IncludeTotalCount {
 		teamsWithCount, appErr = c.App.GetAllTeamsPageWithCount(offset, limit, opts)
+		if *c.App.Config().TeamSettings.EnableMultiTenancySupport && len(teamsWithCount.Teams) != 0 {
+			teamsWithCount.Teams = resumeTeams(c, teamsWithCount.Teams)
+		}
 	} else {
 		teams, appErr = c.App.GetAllTeamsPage(offset, limit, opts)
+		if *c.App.Config().TeamSettings.EnableMultiTenancySupport && len(teams) != 0 {
+			teams = resumeTeams(c, teams)
+		}
 	}
 	if appErr != nil {
 		c.Err = appErr
@@ -1170,6 +1236,27 @@
 	w.Write(js)
 }
 
+func resumeTeams(c *Context, teams []*model.Team) []*model.Team {
+	var resultTeam []*model.Team
+	for _, team := range teams {
+		members, _ := c.App.GetTeamMembers(team.Id, 0, math.MaxInt64, nil)
+		hasAdmin := false
+		for _, member := range members {
+			if member.Roles == "team_user team_admin" {
+				hasAdmin = true
+				break
+			}
+		}
+		if !hasAdmin {
+			resultTeam = append(resultTeam, team)
+		}
+	}
+	if resultTeam != nil {
+		return resultTeam
+	}
+	return make([]*model.Team, 0)
+}
+
 func searchTeams(c *Context, w http.ResponseWriter, r *http.Request) {
 	var props model.TeamSearch
 	if err := json.NewDecoder(r.Body).Decode(&props); err != nil {
Index: mattermost-server-7.8.1/api4/user.go
===================================================================
--- mattermost-server-7.8.1/api4/user.go	(revision 4484)
+++ mattermost-server-7.8.1/api4/user.go	(revision 4485)
@@ -6,12 +6,17 @@
 import (
 	"encoding/json"
 	"fmt"
+	"github.com/dgrijalva/jwt-go"
+	"github.com/xtgo/uuid"
 	"io"
+	"io/ioutil"
 	"net/http"
+	"net/url"
 	"strconv"
 	"strings"
 	"time"
 
+	/* Ryobi Systems MM_NC_連動SSOログアウト Mod 20201127 END */
 	"github.com/mattermost/mattermost-server/v6/app"
 	"github.com/mattermost/mattermost-server/v6/audit"
 	"github.com/mattermost/mattermost-server/v6/model"
@@ -21,6 +26,231 @@
 	"github.com/mattermost/mattermost-server/v6/web"
 )
 
+/* Ryobi Systems MM_NC_連動SSOログアウト Mod 20201127 START */
+type ClientTokenData struct {
+	Access_token string `json:"access_token"`
+}
+
+type KCUserData struct {
+	Id string `json:"id"`
+}
+
+func getClientAccessTokenFromKC(c *Context) (string, error) {
+	client := &http.Client{}
+	accessToken := ""
+
+	client_id := *c.App.Config().GitLabSettings.Id
+	grant_type := "client_credentials"
+	client_secret := *c.App.Config().GitLabSettings.Secret
+	postParams := "client_id=" + client_id + "&grant_type=" + grant_type + "&client_secret=" + client_secret
+	postUrl := *c.App.Config().GitLabSettings.TokenEndpoint
+
+	resp, err := client.Post(postUrl, "application/x-www-form-urlencoded", strings.NewReader(postParams))
+	if err != nil {
+		return accessToken, err
+	}
+
+	defer resp.Body.Close()
+
+	var data ClientTokenData
+	respResult, err := ioutil.ReadAll(resp.Body)
+	if err != nil {
+		return accessToken, err
+	}
+
+	err = json.Unmarshal(respResult, &data)
+	if err != nil {
+		return accessToken, err
+	}
+
+	accessToken = data.Access_token
+	return accessToken, err
+}
+
+func getUserIdFromKC(c *Context, accessToken string) (string, error) {
+	userIdFromKC := ""
+	userIdFromMM := c.AppContext.Session().UserId
+
+	userFromMM, _ := c.App.GetUser(userIdFromMM)
+	userName := userFromMM.Username
+	client := &http.Client{}
+
+	usersApiEndpoint := *c.App.Config().GitLabSettings.UsersApiEndpoint
+
+	req, err := http.NewRequest("GET", usersApiEndpoint+"?username="+userName, nil)
+	if err != nil {
+		return userIdFromKC, err
+	}
+
+	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
+	req.Header.Set("Authorization", "Bearer "+accessToken)
+
+	resp, err := client.Do(req)
+	if err != nil {
+		return userIdFromKC, err
+	}
+
+	defer resp.Body.Close()
+
+	body, err := ioutil.ReadAll(resp.Body)
+	if err != nil {
+		return userIdFromKC, err
+	}
+
+	respString := strings.Trim(strings.Trim(string(body), "["), "]")
+
+	var data KCUserData
+	err = json.Unmarshal([]byte(respString), &data)
+	if err != nil {
+		return userIdFromKC, nil
+	}
+
+	userIdFromKC = data.Id
+	return userIdFromKC, nil
+}
+
+func getKCClientId(c *Context, accessToken string) (string, error) {
+	clientIdFromKC := ""
+	client := &http.Client{}
+
+	clientId := *c.App.Config().GitLabSettings.Id
+	clientsApiEndpoint := *c.App.Config().GitLabSettings.ClientsApiEndpoint
+
+	req, err := http.NewRequest("GET", clientsApiEndpoint+"?clientId="+clientId, nil)
+	if err != nil {
+		return clientIdFromKC, err
+	}
+
+	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
+	req.Header.Set("Authorization", "Bearer "+accessToken)
+
+	resp, err := client.Do(req)
+	if err != nil {
+		return clientIdFromKC, err
+	}
+
+	defer resp.Body.Close()
+
+	body, err := ioutil.ReadAll(resp.Body)
+	if err != nil {
+		return clientIdFromKC, err
+	}
+
+	respString := strings.Trim(strings.Trim(string(body), "["), "]")
+
+	var data KCUserData
+	err = json.Unmarshal([]byte(respString), &data)
+	if err != nil {
+		return clientIdFromKC, nil
+	}
+
+	clientIdFromKC = data.Id
+	return clientIdFromKC, nil
+}
+
+func getKCClientServiceAccountUser(c *Context, accessToken string, clientIdFromKC string) (string, error) {
+	SAUIdFromKC := ""
+	client := &http.Client{}
+
+	clientsApiEndpoint := *c.App.Config().GitLabSettings.ClientsApiEndpoint
+
+	req, err := http.NewRequest("GET", clientsApiEndpoint+"/"+clientIdFromKC+"/service-account-user", nil)
+	if err != nil {
+		return SAUIdFromKC, err
+	}
+
+	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
+	req.Header.Set("Authorization", "Bearer "+accessToken)
+
+	resp, err := client.Do(req)
+	if err != nil {
+		return SAUIdFromKC, err
+	}
+
+	defer resp.Body.Close()
+
+	body, err := ioutil.ReadAll(resp.Body)
+	if err != nil {
+		return SAUIdFromKC, err
+	}
+
+	var data KCUserData
+	err = json.Unmarshal([]byte(string(body)), &data)
+	if err != nil {
+		return SAUIdFromKC, nil
+	}
+
+	SAUIdFromKC = data.Id
+	return SAUIdFromKC, nil
+}
+
+func logoutKCAccount(c *Context, accessToken string, userIdFromKC string) (string, error) {
+	client := &http.Client{}
+	result := ""
+
+	usersApiEndpoint := *c.App.Config().GitLabSettings.UsersApiEndpoint
+
+	req, err := http.NewRequest("POST", usersApiEndpoint+"/"+userIdFromKC+"/logout", nil)
+	if err != nil {
+		return result, err
+	}
+
+	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
+	req.Header.Set("Authorization", "Bearer "+accessToken)
+
+	resp, err := client.Do(req)
+	if err != nil {
+		return result, err
+	}
+
+	defer resp.Body.Close()
+
+	body, err := ioutil.ReadAll(resp.Body)
+	if err != nil {
+		return result, err
+	}
+
+	result = string(body)
+	return result, nil
+}
+
+type Claims struct {
+	jwt.MapClaims
+}
+
+var (
+	jwtkey []byte = []byte(uuid.NewRandom().String())
+)
+
+func makeLogoutToken(c *Context, accessToken string, userIdFromKC string, sid string) (string, error) {
+	logoutToken := ""
+	realmEndpoint := *c.App.Config().GitLabSettings.RealmEndpoint
+	clientId := *c.App.Config().GitLabSettings.Id
+
+	claims := &jwt.MapClaims{
+		"sid": sid,
+		"events": &jwt.MapClaims{
+			"http://schemas.openid.net/event/backchannel-logout": nil,
+			"revoke_offline_access":                              false,
+		},
+		"sub": userIdFromKC,
+		"iss": realmEndpoint,
+		"jti": uuid.NewRandom().String(),
+		"iat": time.Now().Unix(),
+		"aud": clientId,
+	}
+
+	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
+	logoutToken, err := token.SignedString(jwtkey)
+	if err != nil {
+		return logoutToken, err
+	}
+
+	return logoutToken, nil
+}
+
+/* Ryobi Systems MM_NC_連動SSOログアウト Mod 20201127 END */
+
 func (api *API) InitUser() {
 	api.BaseRoutes.Users.Handle("", api.APIHandler(createUser)).Methods("POST")
 	api.BaseRoutes.Users.Handle("", api.APISessionRequired(getUsers)).Methods("GET")
@@ -34,6 +264,7 @@
 	api.BaseRoutes.Users.Handle("/group_channels", api.APISessionRequired(getUsersByGroupChannelIds)).Methods("POST")
 
 	api.BaseRoutes.User.Handle("", api.APISessionRequired(getUser)).Methods("GET")
+	api.BaseRoutes.User.Handle("/update/notify_props", api.APISessionRequired(updateUserNotifyProps)).Methods("POST")
 	api.BaseRoutes.User.Handle("/image/default", api.APISessionRequiredTrustRequester(getDefaultProfileImage)).Methods("GET")
 	api.BaseRoutes.User.Handle("/image", api.APISessionRequiredTrustRequester(getProfileImage)).Methods("GET")
 	api.BaseRoutes.User.Handle("/image", api.APISessionRequired(setProfileImage)).Methods("POST")
@@ -1697,6 +1928,15 @@
 		c.Logger.Warn("Error while writing response", mlog.Err(err))
 	}
 }
+func updateUserNotifyProps(c *Context, w http.ResponseWriter, r *http.Request) {
+	user := model.UserFromJson(r.Body)
+	puser, err := c.App.UpdateUserNotifyProps(user.Id, user.NotifyProps, false)
+	if err != nil {
+		c.Err = err
+		return
+	}
+	w.Write([]byte(puser.ToJson()))
+}
 
 func updatePassword(c *Context, w http.ResponseWriter, r *http.Request) {
 	c.RequireUserId()
@@ -2030,9 +2270,11 @@
 }
 
 func logout(c *Context, w http.ResponseWriter, r *http.Request) {
-	Logout(c, w, r)
+	/* Ryobi Systems MM_NC_連動SSOログアウト Mod 20201127 START */
+	SSOLogout(c, w, r)
+	//Logout(c, w, r)
+	/* Ryobi Systems MM_NC_連動SSOログアウト Mod 20201127 END */
 }
-
 func Logout(c *Context, w http.ResponseWriter, r *http.Request) {
 	auditRec := c.MakeAuditRecord("Logout", audit.Fail)
 	defer c.LogAuditRec(auditRec)
@@ -2050,6 +2292,88 @@
 	ReturnStatusOK(w)
 }
 
+/* Ryobi Systems MM_NC_連動SSOログアウト Mod 20201127 START */
+func SSOLogout(c *Context, w http.ResponseWriter, r *http.Request) {
+	auditRec := c.MakeAuditRecord("Logout", audit.Fail)
+	defer c.LogAuditRec(auditRec)
+	c.LogAudit("")
+
+	c.RemoveSessionCookie(w, r)
+	sid := c.AppContext.Session().Props[model.SESSION_USER_STATE]
+	if c.AppContext.Session().Id != "" {
+		if err := c.App.RevokeSessionById(c.AppContext.Session().Id); err != nil {
+			c.Err = err
+			return
+		}
+	}
+
+	auditRec.Success()
+	ReturnStatusOK(w)
+
+	ssoLogoutUrl := *c.App.Config().GitLabSettings.BackchannelEndpoint
+	if c.AppContext.Session().UserId != "" && ssoLogoutUrl != "" {
+		//アクセストークンを取得
+		accessToken, err := getClientAccessTokenFromKC(c)
+		if err != nil {
+			mlog.Error(err.Error())
+			return
+		}
+
+		//KCユーザIDを取得
+		userIdFromKC, err := getUserIdFromKC(c, accessToken)
+		if err != nil {
+			mlog.Error(err.Error())
+			return
+		}
+
+		//KCのクライアントIDを取得
+		clientIdFromKC, err := getKCClientId(c, accessToken)
+		if err != nil {
+			mlog.Error(err.Error())
+			return
+		}
+
+		//クライアントのService-Account-UserIDを取得
+		SAUId, err := getKCClientServiceAccountUser(c, accessToken, clientIdFromKC)
+		if err != nil {
+			mlog.Error(err.Error())
+			return
+		}
+
+		//AccessTokenとユーザIDを使ってKC Service-Accountユーザをログアウト
+		result, err := logoutKCAccount(c, accessToken, SAUId)
+		if err != nil {
+			mlog.Error(err.Error())
+			return
+		}
+		if result != "" {
+			mlog.Error(result)
+			return
+		}
+
+		//ログアウトトークンを取得
+		logoutToken, err := makeLogoutToken(c, accessToken, userIdFromKC, sid)
+		if err != nil {
+			mlog.Error(err.Error())
+			return
+		}
+
+		//BackChannelLogoutリクエストを送信する
+		data := make(url.Values)
+		data["logout_token"] = []string{logoutToken}
+
+		res, err := http.PostForm(ssoLogoutUrl, data)
+		if err != nil {
+			mlog.Error(err.Error())
+			return
+		}
+
+		defer res.Body.Close()
+	}
+}
+
+/* Ryobi Systems MM_NC_連動SSOログアウト Mod 20201127 END */
+
 func getSessions(c *Context, w http.ResponseWriter, r *http.Request) {
 	c.RequireUserId()
 	if c.Err != nil {
Index: mattermost-server-7.8.1/app/app.go
===================================================================
--- mattermost-server-7.8.1/app/app.go	(revision 4484)
+++ mattermost-server-7.8.1/app/app.go	(revision 4485)
@@ -28,6 +28,11 @@
 	ch *Channels
 }
 
+func (a *App) UpdateUserNotifyProps(userID string, props map[string]string, sendNotifications bool) (*model.User, *model.AppError) {
+	//TODO implement me
+	panic("implement me")
+}
+
 func New(options ...AppOption) *App {
 	app := &App{}
 
Index: mattermost-server-7.8.1/app/app_iface.go
===================================================================
--- mattermost-server-7.8.1/app/app_iface.go	(revision 4484)
+++ mattermost-server-7.8.1/app/app_iface.go	(revision 4485)
@@ -397,6 +397,7 @@
 	ValidateUserPermissionsOnChannels(c request.CTX, userId string, channelIds []string) []string
 	// VerifyPlugin checks that the given signature corresponds to the given plugin and matches a trusted certificate.
 	VerifyPlugin(plugin, signature io.ReadSeeker) *model.AppError
+	GetUserWebMeetingStatus(userId string) (*model.Status, error)
 	AccountMigration() einterfaces.AccountMigrationInterface
 	ActivateMfa(userID, token string) *model.AppError
 	AddChannelsToRetentionPolicy(policyID string, channelIDs []string) *model.AppError
@@ -580,6 +581,32 @@
 	GetActivePluginManifests() ([]*model.Manifest, *model.AppError)
 	GetAllChannels(c request.CTX, page, perPage int, opts model.ChannelSearchOpts) (model.ChannelListWithTeamData, *model.AppError)
 	GetAllChannelsCount(c request.CTX, opts model.ChannelSearchOpts) (int64, *model.AppError)
+	/* Ryobi Systems CloudOffice Meeting Mod 20210325 START */
+	CreateMeeting(meeting *model.Meeting, usersfromjson []*model.MeetingUserFromJson) (*model.MeetingMailInfo, []*model.MeetingUser, *model.AppError)
+	DeleteMeeting(meetingItemId string, delParams *model.DeleteParamsFromJson) (*model.MeetingMailInfo, *model.AppError)
+	GetMeeting(meetingItemId string) (*model.RepeatMeetingToJson, *model.AppError)
+	GetMeetingsByUserId(userId string, meetingAfter string, meetingBefore string) ([]*model.RepeatMeetingToJson, *model.AppError)
+	GetDeletedMeetingInfoByMeetingItemIds(meetingItemIds []string) ([]*model.DeleteParamsToJson, *model.AppError)
+	GetMeetingUsersByMeetingItemIds(meetingItemIds []string) ([]*model.MeetingUser, *model.AppError)
+	UpdateMeeting(meeting *model.Meeting, usersfromjson []*model.MeetingUserFromJson, isAddMeeting bool) (*model.MeetingMailInfo, string, *model.AppError)
+	UpdateValidMeetingUsers(meetingItemId string, mailAddrs []string, itemValid int) *model.AppError
+	GetMeetingDtstamp(timeStamp int64) string
+	/* Ryobi Systems CloudOffice Meeting Mod 20210325 END */
+	/* Ryobi Systems CloudOffice MeetingMng Mod 20210617 START */
+	GetMeetingMng(c *request.Context, meeting *model.MeetingMngFromJson) ([]*model.MeetingMngToJson, *model.AppError)
+	GetMeetingMngDetail(c *request.Context, MeetingItemId string) (*model.MeetingMngDetailToJson, *model.AppError)
+	MeetingMngDelete(meetingItemId string) (*model.MeetingMailInfo, *model.AppError)
+	GetMeetingMngUsersByMeetingItemIdFormail(meetingItemId string) ([]*model.MeetingMngUser, *model.AppError)
+	/* Ryobi Systems CloudOffice MeetingMng Mod 20210617 END */
+	/* Ryobi Systems CloudOffice MeetingStatus Mod 20210913 START */
+	GetMeetingStatus() ([]*model.MeetingStatusToJson, *model.AppError, bool)
+	GetMeetingEnd(meeting *model.MeetingEndFromJson) ([]*model.MeetingEndToJson, *model.AppError, bool)
+	/* Ryobi Systems CloudOffice MeetingStatus Mod 20210913 END */
+	/* Ryobi Systems CloudOffice CronChat Mod 20211129 START */
+	CronDeleteChat(c *request.Context, cronTime int) *model.AppError
+	GetChannelChatSettings(channelId string) (*model.ChannelSettingsToJson, *model.AppError)
+	SetChannelChatSettings(c *request.Context, channelSetting *model.ChannelChatSaveSettingsFromJson) *model.AppError
+	/* Ryobi Systems CloudOffice CronChat Mod 20211129 END */
 	GetAllPrivateTeams() ([]*model.Team, *model.AppError)
 	GetAllPublicTeams() ([]*model.Team, *model.AppError)
 	GetAllRemoteClusters(filter model.RemoteClusterQueryFilter) ([]*model.RemoteCluster, *model.AppError)
@@ -857,6 +884,11 @@
 	GetViewUsersRestrictions(userID string) (*model.ViewUsersRestrictions, *model.AppError)
 	GetWarnMetricsBot() (*model.Bot, *model.AppError)
 	GetWarnMetricsStatus() (map[string]*model.WarnMetricStatus, *model.AppError)
+	/* Ryobi Systems CloudOffice Files Mod 20211103 START */
+	GetFilePermission(userIp string) (*model.FilePermission, *model.AppError)
+	GetFileTotalSize() (float64, *model.AppError)
+	SetFileTotalSize() *model.AppError
+	/* Ryobi Systems CloudOffice Files Mod 20211103 END */
 	GetWorkTemplateCategories(t i18n.TranslateFunc) ([]*model.WorkTemplateCategory, *model.AppError)
 	GetWorkTemplates(category string, featureFlags map[string]string, t i18n.TranslateFunc) ([]*model.WorkTemplate, *model.AppError)
 	HTTPService() httpservice.HTTPService
@@ -927,6 +959,12 @@
 	NotifySharedChannelUserUpdate(user *model.User)
 	OpenInteractiveDialog(request model.OpenDialogRequest) *model.AppError
 	OriginChecker() func(*http.Request) bool
+	/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 START */
+	SaveDefaultTeamforName(Name string)
+	/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 END */
+	/* Ryobi Systems DefaultTeamaSetUp Mod 20221025 START */
+	DeleteDefaultTeam()
+	/* Ryobi Systems DefaultTeamaSetUp Mod 20221025 END */
 	PatchChannel(c request.CTX, channel *model.Channel, patch *model.ChannelPatch, userID string) (*model.Channel, *model.AppError)
 	PatchPost(c *request.Context, postID string, patch *model.PostPatch) (*model.Post, *model.AppError)
 	PatchRetentionPolicy(patch *model.RetentionPolicyWithTeamAndChannelIDs) (*model.RetentionPolicyWithTeamAndChannelCounts, *model.AppError)
@@ -978,6 +1016,9 @@
 	RemoveTeamIcon(teamID string) *model.AppError
 	RemoveTeamsFromRetentionPolicy(policyID string, teamIDs []string) *model.AppError
 	RemoveUserFromChannel(c request.CTX, userIDToRemove string, removerUserId string, channel *model.Channel) *model.AppError
+	/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 START */
+	GetDefaultTeama(teamId string) int
+	/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 END */
 	RemoveUserFromTeam(c request.CTX, teamID string, userID string, requestorId string) *model.AppError
 	RemoveUsersFromChannelNotMemberOfTeam(c request.CTX, remover *model.User, channel *model.Channel, team *model.Team) *model.AppError
 	RequestLicenseAndAckWarnMetric(c *request.Context, warnMetricId string, isBot bool) *model.AppError
@@ -1076,6 +1117,7 @@
 	SetSearchEngine(se *searchengine.Broker)
 	SetServer(srv *Server)
 	SetStatusAwayIfNeeded(userID string, manual bool)
+	SetStatusMeetingIfNeeded(UserId string, manual bool)
 	SetStatusDoNotDisturb(userID string)
 	SetStatusOffline(userID string, manual bool)
 	SetStatusOnline(userID string, manual bool)
@@ -1153,6 +1195,7 @@
 	UpdateUserActive(c request.CTX, userID string, active bool) *model.AppError
 	UpdateUserAsUser(c request.CTX, user *model.User, asAdmin bool) (*model.User, *model.AppError)
 	UpdateUserAuth(userID string, userAuth *model.UserAuth) (*model.UserAuth, *model.AppError)
+	UpdateUserNotifyProps(userID string, props map[string]string, sendNotifications bool) (*model.User, *model.AppError)
 	UpdateUserRoles(c request.CTX, userID string, newRoles string, sendWebSocketEvent bool) (*model.User, *model.AppError)
 	UpdateUserRolesWithUser(c request.CTX, user *model.User, newRoles string, sendWebSocketEvent bool) (*model.User, *model.AppError)
 	UploadData(c request.CTX, us *model.UploadSession, rd io.Reader) (*model.FileInfo, *model.AppError)
Index: mattermost-server-7.8.1/app/bot.go
===================================================================
--- mattermost-server-7.8.1/app/bot.go	(revision 4484)
+++ mattermost-server-7.8.1/app/bot.go	(revision 4485)
@@ -632,7 +632,9 @@
 	T := i18n.GetUserTranslations(user.Locale)
 	message = T("app.bot.get_disable_bot_sysadmin_message",
 		map[string]any{
-			"UserName":           user.Username,
+			/* Ryobi Systems CloudOffice Meeting Mod メール本文にIDを姓名に変更 20210609 START */
+			"UserName": user.GetFullName(),
+			/* Ryobi Systems CloudOffice Meeting Mod メール本文にIDを姓名に変更 20210609 END */
 			"NumBots":            len(userBots),
 			"BotNames":           botList,
 			"disableBotsSetting": disableBotsSetting,
Index: mattermost-server-7.8.1/app/channel.go
===================================================================
--- mattermost-server-7.8.1/app/channel.go	(revision 4484)
+++ mattermost-server-7.8.1/app/channel.go	(revision 4485)
@@ -835,7 +835,9 @@
 
 		post := &model.Post{
 			ChannelId: channel.Id,
-			Message:   T("api.channel.restore_channel.unarchived", map[string]any{"Username": user.Username}),
+			/* Ryobi Systems CloudOffice Meeting Mod メール本文にIDを姓名に変更 20210609 START */
+			Message:   T("api.channel.restore_channel.unarchived", map[string]any{"Username": user.GetFullName()}),
+			/* Ryobi Systems CloudOffice Meeting Mod メール本文にIDを姓名に変更 20210609 END */			
 			Type:      model.PostTypeChannelRestored,
 			UserId:    userID,
 			Props: model.StringInterface{
@@ -856,7 +858,9 @@
 
 			post := &model.Post{
 				ChannelId: channel.Id,
-				Message:   i18n.T("api.channel.restore_channel.unarchived", map[string]any{"Username": systemBot.Username}),
+				/* Ryobi Systems CloudOffice Meeting Mod メール本文にIDを姓名に変更 20210609 START */
+				Message:   i18n.T("api.channel.restore_channel.unarchived", map[string]any{"Username": user.GetFullName()}),
+				/* Ryobi Systems CloudOffice Meeting Mod メール本文にIDを姓名に変更 20210609 END */				
 				Type:      model.PostTypeChannelRestored,
 				UserId:    systemBot.UserId,
 				Props: model.StringInterface{
@@ -1281,7 +1285,9 @@
 	if desktop, exists := data[model.DesktopNotifyProp]; exists {
 		filteredProps[model.DesktopNotifyProp] = desktop
 	}
-
+	if desktop, exists := data[model.CONTINUE_SHOW]; exists {
+		filteredProps[model.CONTINUE_SHOW] = desktop
+	}
 	if desktop_threads, exists := data[model.DesktopThreadsNotifyProp]; exists {
 		filteredProps[model.DesktopThreadsNotifyProp] = desktop_threads
 	}
@@ -1301,7 +1307,15 @@
 	if ignoreChannelMentions, exists := data[model.IgnoreChannelMentionsNotifyProp]; exists {
 		filteredProps[model.IgnoreChannelMentionsNotifyProp] = ignoreChannelMentions
 	}
+	/* Ryobi Systems CloudOffice Channel Mod 20210802 start */
+	if notificationsToChannel, exists := data[model.NOTIFICATIONS_TO_CHANNEL_NOTIFY_PROP]; exists {
+		filteredProps[model.NOTIFICATIONS_TO_CHANNEL_NOTIFY_PROP] = notificationsToChannel
+	}
 
+	if notificationsToChannelCount, exists := data[model.NOTIFICATIONS_TO_CHANNEL_COUNT_NOTIFY_PROP]; exists {
+		filteredProps[model.NOTIFICATIONS_TO_CHANNEL_COUNT_NOTIFY_PROP] = notificationsToChannelCount
+	}
+	/* Ryobi Systems CloudOffice Channel Mod 20210816 END */
 	member, err := a.Srv().Store().Channel().UpdateMemberNotifyProps(channelID, userID, filteredProps)
 	if err != nil {
 		var appErr *model.AppError
@@ -2569,7 +2583,9 @@
 		oldStatus = status.Status
 		status.ActiveChannel = channelID
 		if !status.Manual && channelID != "" {
-			status.Status = model.StatusOnline
+			if status.Status != model.STATUS_MEETING {
+				status.Status = model.StatusOnline
+			}
 		}
 		status.LastActivityAt = model.GetMillis()
 	}
Index: mattermost-server-7.8.1/app/config.go
===================================================================
--- mattermost-server-7.8.1/app/config.go	(revision 4484)
+++ mattermost-server-7.8.1/app/config.go	(revision 4485)
@@ -211,6 +211,35 @@
 	return cfg
 }
 
+/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 START */
+func (a *App) SaveDefaultTeamforName(Name string) {
+	team, err := a.Srv().Store().Team().GetByName(Name)
+	if err != nil {
+		return
+	}
+	DefaultTeam, errDefaultTeam := a.Srv().Store().Session().SqlGetDefaultTeam()
+	if errDefaultTeam == nil && DefaultTeam != "" {
+		_ = a.Srv().Store().Session().SqlDeleteDefaultTeam()
+	}
+
+	dt := model.DefaultTeam{}
+
+	dt.Id = team.Id
+	dt.CreateAt = 0
+	dt.UpdateAt = 0
+	a.Srv().Store().Session().SqlSaveDefaultTeam(&dt)
+	return
+}
+
+/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 END */
+
+/* Ryobi Systems DefaultTeamaSetUp Mod 20221025 START */
+func (a *App) DeleteDefaultTeam() {
+	_ = a.Srv().Store().Session().SqlDeleteDefaultTeam()
+	return
+}
+
+/* Ryobi Systems DefaultTeamaSetUp Mod 20221025 END */
 // GetEnvironmentConfig returns a map of configuration keys whose values have been overridden by an environment variable.
 // If filter is not nil and returns false for a struct field, that field will be omitted.
 func (a *App) GetEnvironmentConfig(filter func(reflect.StructField) bool) map[string]any {
Index: mattermost-server-7.8.1/app/cron_chat.go
===================================================================
--- mattermost-server-7.8.1/app/cron_chat.go	(nonexistent)
+++ mattermost-server-7.8.1/app/cron_chat.go	(revision 4485)
@@ -0,0 +1,497 @@
+//Copyright 2021 Ryobi Systems Co., Ltd. All Rights Reserved.
+
+package app
+
+import (
+	"fmt"
+	"github.com/mattermost/mattermost-server/v6/app/request"
+	"github.com/mattermost/mattermost-server/v6/model"
+	"github.com/mattermost/mattermost-server/v6/shared/i18n"
+	"github.com/mattermost/mattermost-server/v6/shared/mlog"
+	"github.com/robfig/cron"
+	"net/http"
+	"strconv"
+	"strings"
+	"time"
+)
+
+var globalCron *cron.Cron
+
+func init() {
+	globalCron = newWithSeconds()
+}
+
+//　画面リクエストにより、cron設定する
+func (a *App) CronDeleteChat(c *request.Context, cronTime int) *model.AppError {
+	T := i18n.GetUserTranslations(getUserLocaleCron(a, c.Session().UserId))
+
+	gc := globalCron
+	err := a.addMainCron(T, gc, cronTime)
+	if err != nil {
+		return err
+	}
+
+	gc.Start()
+	mlog.Info(T("api.cron_chat.chat_delete_batch.startup"))
+	return nil
+}
+
+//ユーザ言語の種類を取得
+func getUserLocaleCron(a *App, userId string) string {
+	userLocale := "ja"
+
+	if userId == "" {
+		return userLocale
+	}
+
+	user, err := a.GetUser(userId)
+	if err != nil {
+		return userLocale
+	}
+
+	userLocale = user.Locale
+	return userLocale
+}
+func (a *App) addMainCron(T i18n.TranslateFunc, c *cron.Cron, ti int) *model.AppError {
+	cronSetting, _ := a.Srv().Store().CronChat().GetCronId()
+	if len(cronSetting) != 0 {
+		c.Remove(cronSetting[0].CronId)
+		err := a.Srv().Store().CronChat().UpdateCronChatDelete(cronSetting[0].Id)
+		if err != nil {
+			return err
+		}
+	}
+	spec := GetSpec(ti)
+	cronId, errc := a.createCron(T, c, spec)
+	if errc != nil {
+		return errc
+	}
+
+	err := a.Srv().Store().CronChat().SaveCronChatDelete(cronId, spec)
+	if err != nil {
+		return err
+	}
+	return nil
+}
+func (a *App) createCron(T i18n.TranslateFunc, c *cron.Cron, spec string) (cron.EntryID, *model.AppError) {
+	id, err := c.AddFunc(spec, func() {
+		mlog.Info(T("api.cron_chat.chat_delete_batch.start"))
+		channelSetting := a.getChannelSettingFromConfig()
+		//　チャットのメッセージ削除
+		a.deleteChatMessage(channelSetting)
+		//　チャットのファイル削除
+		a.deleteChatFile(channelSetting)
+		mlog.Info(T("api.cron_chat.chat_delete_batch.end"))
+	})
+	if err != nil {
+		mlog.Info(fmt.Sprintf("%s", err))
+		return 0, model.NewAppError("AppCronChat.createCron", "app.createCron.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	return id, nil
+}
+func newWithSeconds() *cron.Cron {
+	secondParser := cron.NewParser(cron.Second | cron.Minute |
+		cron.Hour | cron.Dom | cron.Month | cron.DowOptional | cron.Descriptor)
+	return cron.New(cron.WithParser(secondParser), cron.WithChain())
+}
+
+//　チャットのメッセージ削除
+func (a *App) deleteChatMessage(sysSetting *model.ChannelChatSaveSettings) {
+	//設定あるチャンネル毎の削除
+	channelSettings, err := a.Srv().Store().CronChat().GetChannelSettings()
+	if err != nil {
+		mlog.Error(fmt.Sprintln(err))
+		return
+	}
+	if sysSetting.MessagePermission {
+		var channelIds []string
+		sysDeleteTime := getDeleteTime(sysSetting.MessageTime, sysSetting.MessageUtil)
+		for _, channel := range channelSettings {
+			channelIds = append(channelIds, channel.ChannelId)
+			// 設定したことある　且　有効の場合
+			if channel.MessageTime > 0 && channel.MessagePermission && sysSetting.ShowUserSettings {
+				channelDeleteTime := getDeleteTime(channel.MessageTime, channel.MessageUtil)
+				posts, errGet := a.Srv().Store().CronChat().GetChatMessagesByChannelId(channel.ChannelId, channelDeleteTime)
+				if errGet != nil {
+					mlog.Error(fmt.Sprintln(errGet))
+					return
+				}
+				for _, post := range posts.Posts {
+					a.DeletePost(nil, post.Id, post.UserId)
+				}
+				//　メッセージチャットを削除(ユーザにより削除されたメッセージも含む)
+				errd := a.Srv().Store().CronChat().DeleteChatMessagesByChannelId(channel.ChannelId, channelDeleteTime)
+				if errd != nil {
+					mlog.Error(fmt.Sprintln(errd))
+					return
+				}
+			} else {
+				posts, errGet := a.Srv().Store().CronChat().GetChatMessagesByChannelId(channel.ChannelId, sysDeleteTime)
+				if errGet != nil {
+					mlog.Error(fmt.Sprintln(errGet))
+					return
+				}
+				for _, post := range posts.Posts {
+					a.DeletePost(nil, post.Id, post.UserId)
+				}
+				//　メッセージチャットを削除(ユーザにより削除されたメッセージも含む)
+				errd := a.Srv().Store().CronChat().DeleteChatMessagesByChannelId(channel.ChannelId, sysDeleteTime)
+				if errd != nil {
+					mlog.Error(fmt.Sprintln(errd))
+					return
+				}
+			}
+		}
+		posts, errGet := a.Srv().Store().CronChat().GetChatMessagesOther(channelIds, sysDeleteTime)
+		if errGet != nil {
+			mlog.Error(fmt.Sprintln(errGet))
+			return
+		}
+		for _, post := range posts.Posts {
+			a.DeletePost(nil, post.Id, post.UserId)
+		}
+		//設定ないチャンネルと私信を削除(ユーザにより削除されたメッセージも含む)
+		errd := a.Srv().Store().CronChat().DeleteChatMessagesOther(channelIds, sysDeleteTime)
+		if errd != nil {
+			mlog.Error(fmt.Sprintln(errd))
+			return
+		}
+	} else {
+		if sysSetting.ShowUserSettings {
+			for _, channel := range channelSettings {
+				// 設定したことある　且　有効の場合
+				if channel.MessageTime > 0 && channel.MessagePermission {
+					channelDeleteTime := getDeleteTime(channel.MessageTime, channel.MessageUtil)
+					posts, errGet := a.Srv().Store().CronChat().GetChatMessagesByChannelId(channel.ChannelId, channelDeleteTime)
+					if errGet != nil {
+						mlog.Error(fmt.Sprintln(errGet))
+						return
+					}
+					for _, post := range posts.Posts {
+						a.DeletePost(nil, post.Id, post.UserId)
+					}
+					errd := a.Srv().Store().CronChat().DeleteChatMessagesByChannelId(channel.ChannelId, channelDeleteTime)
+					if errd != nil {
+						mlog.Error(fmt.Sprintln(errd))
+						return
+					}
+				}
+			}
+		}
+
+	}
+	return
+}
+
+//　チャットのファイル削除
+func (a *App) deleteChatFile(sysSetting *model.ChannelChatSaveSettings) {
+	channelSettings, err := a.Srv().Store().CronChat().GetChannelSettings()
+	if err != nil {
+		mlog.Error(fmt.Sprintln(err))
+		return
+	}
+	if sysSetting.FilePermission {
+		sysDeleteTime := getDeleteTime(sysSetting.FileTime, sysSetting.FileUtil)
+		var channelIds []string
+		//設定あるチャンネル毎の削除
+		for _, channel := range channelSettings {
+			var fileIds []string
+			channelIds = append(channelIds, channel.ChannelId)
+			// 設定したことある　且　有効の場合
+			if channel.FileTime > 0 && channel.FilePermission && sysSetting.ShowUserFileSettings {
+				channelDeleteTime := getDeleteTime(channel.FileTime, channel.FileUtil)
+				// ファイルチャット取得
+				chatFiles, errg := a.Srv().Store().CronChat().GetChatFilesByChannelId(channel.ChannelId, channelDeleteTime)
+				if errg != nil {
+					mlog.Error(fmt.Sprintln(errg))
+					return
+				}
+				for _, chatFile := range chatFiles {
+					a.DeletePost(nil, chatFile.Id, chatFile.UserId)
+					for index := range chatFile.FileIds {
+						fileIds = append(fileIds, chatFile.FileIds[index])
+					}
+				}
+
+				// ファイルチャット削除(ユーザにより削除されたファイルも含む)
+				errd := a.Srv().Store().CronChat().DeleteChatFilesByChannelId(channel.ChannelId, channelDeleteTime, fileIds)
+				if errd != nil {
+					mlog.Error(fmt.Sprintln(errd))
+					return
+				}
+			} else {
+				// ファイルチャット取得
+				chatFiles, errg := a.Srv().Store().CronChat().GetChatFilesByChannelId(channel.ChannelId, sysDeleteTime)
+				if errg != nil {
+					mlog.Error(fmt.Sprintln(errg))
+					return
+				}
+				for _, chatFile := range chatFiles {
+					a.DeletePost(nil, chatFile.Id, chatFile.UserId)
+					for index := range chatFile.FileIds {
+						fileIds = append(fileIds, chatFile.FileIds[index])
+					}
+				}
+
+				// ファイルチャット削除(ユーザにより削除されたファイルも含む)
+				errd := a.Srv().Store().CronChat().DeleteChatFilesByChannelId(channel.ChannelId, sysDeleteTime, fileIds)
+				if errd != nil {
+					mlog.Error(fmt.Sprintln(errd))
+					return
+				}
+			}
+		}
+		var fileIds []string
+		// ファイルチャット取得
+		chatFiles, errg := a.Srv().Store().CronChat().GetChatFilesOther(channelIds, sysDeleteTime)
+		if errg != nil {
+			mlog.Error(fmt.Sprintln(errg))
+			return
+		}
+		for _, chatFile := range chatFiles {
+			a.DeletePost(nil, chatFile.Id, chatFile.UserId)
+			for index := range chatFile.FileIds {
+				fileIds = append(fileIds, chatFile.FileIds[index])
+			}
+		}
+		//設定ないチャンネルと私信を削除(ユーザにより削除されたファイルも含む)
+		errd := a.Srv().Store().CronChat().DeleteChatFilesOther(channelIds, sysDeleteTime, fileIds)
+		if errd != nil {
+			mlog.Error(fmt.Sprintln(errd))
+			return
+		}
+	} else {
+		if sysSetting.ShowUserFileSettings {
+			//設定あるチャンネル毎の削除
+			for _, channel := range channelSettings {
+				var fileIds []string
+				// 設定したことある　且　有効の場合
+				if channel.FileTime > 0 && channel.FilePermission {
+					channelDeleteTime := getDeleteTime(channel.FileTime, channel.FileUtil)
+					// ファイルチャット取得
+					chatFiles, errg := a.Srv().Store().CronChat().GetChatFilesByChannelId(channel.ChannelId, channelDeleteTime)
+					if errg != nil {
+						mlog.Error(fmt.Sprintln(errg))
+						return
+					}
+					for _, chatFile := range chatFiles {
+						a.DeletePost(nil, chatFile.Id, chatFile.UserId)
+						for index := range chatFile.FileIds {
+							fileIds = append(fileIds, chatFile.FileIds[index])
+						}
+					}
+
+					// ファイルチャット削除
+					errd := a.Srv().Store().CronChat().DeleteChatFilesByChannelId(channel.ChannelId, channelDeleteTime, fileIds)
+					if errd != nil {
+						mlog.Error(fmt.Sprintln(errd))
+						return
+					}
+				}
+			}
+		}
+	}
+
+	go func() {
+		// 削除ファイルを取得
+		chatFilesPath, errg := a.Srv().Store().CronChat().GetChatFilesPath()
+		if errg != nil {
+			mlog.Error(fmt.Sprintln(errg))
+			return
+		}
+		// ファイルをDBから削除する
+		errd := a.Srv().Store().CronChat().DeleteFileInfos()
+		if errd != nil {
+			mlog.Error(fmt.Sprintln(errd))
+			return
+		}
+		// 実ファイルを削除する
+		if len(chatFilesPath) > 0 {
+			for _, chatFile := range chatFilesPath {
+				chatFileParentPath := getParentDirectory(chatFile.Path)
+				errf := a.RemoveDirectory(chatFileParentPath)
+				if errf != nil {
+					mlog.Error(fmt.Sprintln(errf))
+					return
+				}
+			}
+		}
+	}()
+	return
+}
+
+func getParentDirectory(chatFileParentPath string) string {
+	return substr(chatFileParentPath, 0, strings.LastIndex(chatFileParentPath, "/"))
+}
+
+func substr(s string, pos, length int) string {
+	runes := []rune(s)
+	return string(runes[:length])
+}
+
+func getDeleteTime(chatTime int64, timeUtil string) int64 {
+	var deleteTime int64 = 0
+	switch timeUtil {
+	case "day":
+		nowTime := time.Now().Unix() * 1000
+		saveTime := chatTime * 24 * 60 * 60 * 1000
+		deleteTime = nowTime - saveTime
+		return deleteTime
+	case "year":
+		nowTime := time.Now().Unix() * 1000
+		saveTime := chatTime * 365 * 24 * 60 * 60 * 1000
+		deleteTime = nowTime - saveTime
+		return deleteTime
+	}
+
+	return deleteTime
+}
+
+// サーバ起動により実行される。
+func (a *App) SetCronChat() string {
+	c := globalCron
+	cronSetting, _ := a.Srv().Store().CronChat().GetCronId()
+	if len(cronSetting) != 0 {
+		// 既存バッチを削除
+		erru := a.Srv().Store().CronChat().UpdateCronChatDelete(cronSetting[0].Id)
+		if erru != nil {
+			mlog.Error(fmt.Sprintln(erru))
+			return ""
+		}
+		spec := cronSetting[0].Spec
+		//　既存のバッチ設定により、バッチを作成
+		cronId, err := a.createCron(i18n.T, c, spec)
+		if err != nil {
+			mlog.Error(fmt.Sprintln(err))
+		}
+		//　バッチ設定をDBに格納
+		errs := a.Srv().Store().CronChat().SaveCronChatDelete(cronId, spec)
+		if errs != nil {
+			mlog.Error(fmt.Sprintln(errs))
+			return ""
+		}
+		c.Start()
+		mlog.Info(i18n.T("api.cron_chat.chat_delete_batch.startup"))
+	}
+
+	return ""
+}
+func GetSpec(ti int) string {
+	_, offset := time.Now().Zone()
+	offsetH := offset / 60 / 60
+	time := ti + offsetH
+	if time > 23 {
+		time -= 24
+	}
+	if time < 0 {
+		time += 24
+	}
+
+	spec := "0 0 " + strconv.Itoa(time) + " * * ?"
+	return spec
+}
+
+//　channel設定を取得する
+func (a *App) GetChannelChatSettings(channelId string) (*model.ChannelSettingsToJson, *model.AppError) {
+	channelSettings, _ := a.Srv().Store().CronChat().GetChannelSettingByChannelId(channelId)
+
+	if len(channelSettings) == 0 {
+		channelSetting := a.getChannelSettingFromConfig()
+		return a.makeChannelSettingsRes(channelSetting), nil
+	} else {
+		return a.makeChannelSettingsRes(channelSettings[0]), nil
+	}
+}
+
+//　configからチャット設定を取得
+func (a *App) getChannelSettingFromConfig() *model.ChannelChatSaveSettings {
+	var sysSetting model.ChannelChatSaveSettings
+	sysSetting.MessagePermission = *a.Config().PostSaveSettings.PostPermission
+	MessageTime, _ := strconv.Atoi(*a.Config().PostSaveSettings.Postinput)
+	sysSetting.MessageTime = int64(MessageTime)
+	sysSetting.MessageUtil = *a.Config().PostSaveSettings.PostUtil
+
+	sysSetting.FilePermission = *a.Config().PostSaveSettings.FilePermission
+	Fileinput, _ := strconv.Atoi(*a.Config().PostSaveSettings.Fileinput)
+
+	sysSetting.FileTime = int64(Fileinput)
+	sysSetting.FileUtil = *a.Config().PostSaveSettings.FileUtil
+	sysSetting.ShowUserSettings = *a.Config().PostSaveSettings.ShowUserSettings
+	sysSetting.ShowUserFileSettings = *a.Config().PostSaveSettings.ShowUserFileSettings
+	return &sysSetting
+}
+func (a *App) makeChannelSettingsRes(saveSetting *model.ChannelChatSaveSettings) *model.ChannelSettingsToJson {
+	var cronSettingsToJson model.ChannelSettingsToJson
+
+	cronSettingsToJson.SystemMessagePermission = *a.Config().PostSaveSettings.PostPermission
+	systemPostTime, _ := strconv.Atoi(*a.Config().PostSaveSettings.Postinput)
+	cronSettingsToJson.SystemMessageTime = int64(systemPostTime)
+	cronSettingsToJson.SystemMessageUtil = *a.Config().PostSaveSettings.PostUtil
+
+	cronSettingsToJson.SystemFilePermission = *a.Config().PostSaveSettings.FilePermission
+	systemFileTime, _ := strconv.Atoi(*a.Config().PostSaveSettings.Fileinput)
+	cronSettingsToJson.SystemFileTime = int64(systemFileTime)
+	cronSettingsToJson.SystemFileUtil = *a.Config().PostSaveSettings.FileUtil
+
+	if saveSetting.MessageTime == 0 {
+		cronSettingsToJson.MessagePermission = cronSettingsToJson.SystemMessagePermission
+		cronSettingsToJson.MessageTime = cronSettingsToJson.SystemMessageTime
+		cronSettingsToJson.MessageUtil = cronSettingsToJson.SystemMessageUtil
+	} else {
+		cronSettingsToJson.MessagePermission = saveSetting.MessagePermission
+		cronSettingsToJson.MessageTime = saveSetting.MessageTime
+		cronSettingsToJson.MessageUtil = saveSetting.MessageUtil
+	}
+
+	if saveSetting.FileTime == 0 {
+		cronSettingsToJson.FilePermission = cronSettingsToJson.SystemFilePermission
+		cronSettingsToJson.FileTime = cronSettingsToJson.SystemFileTime
+		cronSettingsToJson.FileUtil = cronSettingsToJson.SystemFileUtil
+	} else {
+		cronSettingsToJson.FilePermission = saveSetting.FilePermission
+		cronSettingsToJson.FileTime = saveSetting.FileTime
+		cronSettingsToJson.FileUtil = saveSetting.FileUtil
+	}
+	cronSettingsToJson.ShowUserSettings = *a.Config().PostSaveSettings.ShowUserSettings
+	cronSettingsToJson.ShowUserFileSettings = *a.Config().PostSaveSettings.ShowUserFileSettings
+
+	return &cronSettingsToJson
+}
+
+//　画面リクエストにより、チャンネル設定する
+func (a *App) SetChannelChatSettings(c *request.Context, channelSetting *model.ChannelChatSaveSettingsFromJson) *model.AppError {
+	channelSettings, _ := a.Srv().Store().CronChat().GetChannelSettingByChannelId(channelSetting.ChannelId)
+	if len(channelSettings) == 0 {
+		var cSetting model.ChannelChatSaveSettingsFromJson
+		cSetting.ChannelId = channelSetting.ChannelId
+		if channelSetting.CurrentType == "post" {
+			cSetting.MessagePermission = channelSetting.MessagePermission
+			cSetting.MessageTime = channelSetting.MessageTime
+			cSetting.MessageUtil = channelSetting.MessageUtil
+		} else {
+			cSetting.FilePermission = channelSetting.FilePermission
+			cSetting.FileTime = channelSetting.FileTime
+			cSetting.FileUtil = channelSetting.FileUtil
+		}
+		err := a.Srv().Store().CronChat().SaveChannelsSetting(&cSetting, c.Session().UserId)
+		if err != nil {
+			return err
+		}
+	} else {
+		if channelSetting.CurrentType == "post" {
+			channelSetting.FilePermission = channelSettings[0].FilePermission
+			channelSetting.FileTime = channelSettings[0].FileTime
+			channelSetting.FileUtil = channelSettings[0].FileUtil
+		} else {
+			channelSetting.MessagePermission = channelSettings[0].MessagePermission
+			channelSetting.MessageTime = channelSettings[0].MessageTime
+			channelSetting.MessageUtil = channelSettings[0].MessageUtil
+		}
+		err := a.Srv().Store().CronChat().UpdateChannelsSetting(channelSetting, c.Session().UserId)
+		if err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
Index: mattermost-server-7.8.1/app/file.go
===================================================================
--- mattermost-server-7.8.1/app/file.go	(revision 4484)
+++ mattermost-server-7.8.1/app/file.go	(revision 4485)
@@ -47,6 +47,13 @@
 	jpegEncQuality             = 90
 	maxUploadInitialBufferSize = 1024 * 1024 // 1MB
 	maxContentExtractionSize   = 1024 * 1024 // 1MB
+	/* Ryobi Systems CloudOffice Files Mod 20211103 START */
+	permissionNone        = "none"
+	permissionAll         = "all"
+	permissionSome        = "some"
+	userPermissonDownload = "download"
+	userPermissonReadonly = "readonly"
+	/* Ryobi Systems CloudOffice Files Mod 20211103 END */
 )
 
 // Ensure fileInfo service wrapper implements `product.FileInfoStoreService`
@@ -1358,6 +1365,117 @@
 	return nil
 }
 
+/* Ryobi Systems CloudOffice Files Mod 20211103 START */
+func (a *App) GetFilePermission(userIp string) (*model.FilePermission, *model.AppError) {
+	var fp model.FilePermission
+
+	fp.UserPermissionDownload = permissionNone
+	fp.UserPermissionUpload = false
+
+	if !*a.Config().FileSettings.EnableFileAttachments {
+		return &fp, nil
+	} else {
+		fp.UserPermissionDownload = userPermissonDownload
+		fp.UserPermissionUpload = true
+	}
+
+	if _, ok := a.Config().PluginSettings.PluginStates["filepermissionsettingplugin"]; !ok {
+		return &fp, nil
+	}
+	if !a.Config().PluginSettings.PluginStates["filepermissionsettingplugin"].Enable {
+		return &fp, nil
+	}
+	if _, ok := a.Config().PluginSettings.Plugins["filepermissionsettingplugin"]; !ok {
+		return &fp, nil
+	}
+
+	Permission := a.Config().PluginSettings.Plugins["filepermissionsettingplugin"]["filepermission"].(string)
+	Download, _ := a.Config().PluginSettings.Plugins["filepermissionsettingplugin"]["download"].(bool)
+	DownloadWhitelist, _ := a.Config().PluginSettings.Plugins["filepermissionsettingplugin"]["downloadwhitelist"].(string)
+	Refer, _ := a.Config().PluginSettings.Plugins["filepermissionsettingplugin"]["refer"].(bool)
+	ReferWhitelist, _ := a.Config().PluginSettings.Plugins["filepermissionsettingplugin"]["referwhitelist"].(string)
+	Upload, _ := a.Config().PluginSettings.Plugins["filepermissionsettingplugin"]["upload"].(bool)
+	UploadWhitelist, _ := a.Config().PluginSettings.Plugins["filepermissionsettingplugin"]["uploadwhitelist"].(string)
+
+	fp.UserPermissionDownload = permissionNone
+	fp.UserPermissionUpload = false
+
+	switch Permission {
+	// 権限無し
+	case permissionNone:
+		return &fp, nil
+	// 権限ある
+	case permissionAll:
+		fp.UserPermissionDownload = userPermissonDownload
+		fp.UserPermissionUpload = true
+		return &fp, nil
+	case permissionSome:
+		//　アップロード権限
+		if Upload {
+			if UploadWhitelist == "" {
+				fp.UserPermissionUpload = true
+			} else if a.CheckUser(UploadWhitelist, userIp) {
+				fp.UserPermissionUpload = true
+			}
+		}
+		//　参照権限
+		if Refer {
+			if ReferWhitelist == "" {
+				fp.UserPermissionDownload = userPermissonReadonly
+			} else if a.CheckUser(ReferWhitelist, userIp) {
+				fp.UserPermissionDownload = userPermissonReadonly
+			}
+		}
+		//　ダウンロード権限
+		if Download {
+			if DownloadWhitelist == "" {
+				fp.UserPermissionDownload = userPermissonDownload
+			} else if a.CheckUser(DownloadWhitelist, userIp) {
+				fp.UserPermissionDownload = userPermissonDownload
+			}
+		}
+		return &fp, nil
+	}
+	return &fp, nil
+}
+func (a *App) CheckUser(ipList string, userIp string) bool {
+	if strings.Contains(ipList, userIp) {
+		return true
+	}
+
+	s := strings.Split(ipList, ";")
+	for _, item := range s {
+		if item == "" {
+			continue
+		}
+		matchStr := "^" + item + "$"
+		matchStr = strings.Replace(matchStr, ".", "\\.", -1)
+		matchStr = strings.Replace(matchStr, "*", "\\d{1,3}", -1)
+		if ok, _ := regexp.MatchString(matchStr, userIp); ok {
+			return true
+		}
+	}
+	return false
+}
+func (a *App) SetFileTotalSize() *model.AppError {
+	if _, ok := a.Config().PluginSettings.Plugins["filepermissionsettingplugin"]; ok {
+		totalSize, _ := a.GetFileTotalSize()
+		a.Srv().Platform().GetConfigStore().ReMulTotalSize(totalSize)
+	}
+	return nil
+}
+func (a *App) GetFileTotalSize() (float64, *model.AppError) {
+	totalSize, _ := a.Srv().Store().FileInfo().GetFileTotalSize()
+
+	totalSileMB := float64(totalSize) / 1024 / 1024
+	totalSileMB, _ = strconv.ParseFloat(fmt.Sprintf("%.1f", totalSileMB), 64)
+	if totalSileMB < 0.1 {
+		totalSileMB = 0.1
+	}
+	return totalSileMB, nil
+}
+
+/* Ryobi Systems CloudOffice Files Mod 20211103 END */
 // GetLastAccessibleFileTime returns CreateAt time(from cache) of the last accessible post as per the cloud limit
 func (a *App) GetLastAccessibleFileTime() (int64, *model.AppError) {
 	license := a.Srv().License()
Index: mattermost-server-7.8.1/app/login.go
===================================================================
--- mattermost-server-7.8.1/app/login.go	(revision 4484)
+++ mattermost-server-7.8.1/app/login.go	(revision 4485)
@@ -206,12 +206,20 @@
 	} else {
 		session.AddProp(model.SessionPropIsGuest, "false")
 	}
-
+	if user.Props["session_state"] != "" {
+		session.AddProp(model.SESSION_USER_STATE, user.Props["session_state"])
+	}
 	var err *model.AppError
 	if session, err = a.CreateSession(session); err != nil {
 		err.StatusCode = http.StatusInternalServerError
 		return err
 	}
+	/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 START */
+	if len(session.TeamMembers) == 0 {
+		DefaultTeamid, _ := a.Srv().Store().Session().SqlGetDefaultTeam()
+		_, _ = a.AddTeamMember(c, DefaultTeamid, session.UserId)
+	}
+	/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 END */
 
 	w.Header().Set(model.HeaderToken, session.Token)
 
Index: mattermost-server-7.8.1/app/meeting.go
===================================================================
--- mattermost-server-7.8.1/app/meeting.go	(nonexistent)
+++ mattermost-server-7.8.1/app/meeting.go	(revision 4485)
@@ -0,0 +1,529 @@
+//Copyright 2021 Ryobi Systems Co., Ltd. All Rights Reserved.
+
+package app
+
+import (
+	"encoding/json"
+	"fmt"
+	"github.com/garyburd/redigo/redis"
+	"net/http"
+	"os"
+	"strings"
+	"time"
+
+	"github.com/mattermost/mattermost-server/v6/model"
+	"github.com/mattermost/mattermost-server/v6/shared/mlog"
+	"github.com/xtgo/uuid"
+	"unsafe"
+)
+
+type meetingDate struct {
+	year   string
+	month  string
+	day    string
+	hour   string
+	minute string
+	sec    string
+}
+
+//会議を作成
+func (a *App) CreateMeeting(meeting *model.Meeting, usersfromjson []*model.MeetingUserFromJson) (*model.MeetingMailInfo, []*model.MeetingUser, *model.AppError) {
+	//ICSファイルIDを設定
+	meeting.ICalUID = uuid.NewRandom().String()
+
+	meetingUsers, _, err := a.Srv().Store().Meeting().Save(meeting, usersfromjson, "0")
+	if err != nil {
+		return nil, nil, err
+	}
+
+	return a.makeMeetingMailInfo(meeting), meetingUsers, nil
+}
+
+//会議を更新
+func (a *App) UpdateMeeting(meeting *model.Meeting, usersfromjson []*model.MeetingUserFromJson, isAddMeeting bool) (*model.MeetingMailInfo, string, *model.AppError) {
+	meetingItemId := meeting.MeetingItemId
+
+	//会議が存在しないと更新できません
+	meetingTmp, err := a.Srv().Store().Meeting().GetMeetingByMeetingItemId(meeting.MeetingItemId)
+	if err != nil {
+		return nil, meetingItemId, err
+	}
+
+	if meetingTmp == nil {
+		return nil, meetingItemId, nil
+	}
+
+	//ICSファイルIDを維持
+	meeting.ICalUID = meetingTmp.ICalUID
+
+	//招待者に主催者情報を削除
+	usersfromjson = removeHostInUsers(usersfromjson)
+
+	if isAddMeeting {
+		meetingTmp.RepeatEndDate = time.Now().UTC().Unix() * 1000
+
+		//繰り返し会議の終了サイクル時間を現在の時間に設定
+		err = a.Srv().Store().Meeting().UpdateMeetingRepeatEndDate(meetingTmp)
+		if err != nil {
+			return nil, meetingItemId, err
+		}
+
+		//新しい繰り返し会議を作成
+		_, meetingItemId, err = a.Srv().Store().Meeting().Save(meeting, usersfromjson, "1")
+		if err != nil {
+			return nil, meetingItemId, err
+		}
+	} else {
+		//会議を更新
+		err = a.Srv().Store().Meeting().Update(meeting, usersfromjson)
+		if err != nil {
+			return nil, meetingItemId, err
+		}
+
+		if isNeedRemoveDelRepeatMeeting(meetingTmp, meeting) {
+			//除外された単条重複会議情報を保留しない
+			err = a.Srv().Store().Meeting().RemoveDelRepeatMeetingAfterNow(meetingItemId, 0)
+			if err != nil {
+				return nil, meetingItemId, err
+			}
+		}
+	}
+
+	return a.makeMeetingMailInfo(meeting), meetingItemId, nil
+}
+
+func isNeedRemoveDelRepeatMeeting(meetingBefore, meetingAfter *model.Meeting) bool {
+	//定期会議が一回だけの会議に変更された場合
+	if meetingBefore.IsRepeat == true && meetingAfter.IsRepeat == false {
+		return true
+	}
+
+	//定期会議の場合
+	if meetingBefore.IsRepeat == true && meetingAfter.IsRepeat == true {
+		//定期会議の循環配置が変化した場合
+		if meetingBefore.RepeatConfig != meetingAfter.RepeatConfig {
+			return true
+		}
+
+		//定期会議の時間が変化した場合
+		if meetingBefore.StartAt != meetingAfter.StartAt || meetingBefore.EndAt != meetingAfter.EndAt {
+			return true
+		}
+	}
+
+	return false
+}
+
+//招待者に主催者情報を削除
+func removeHostInUsers(duplicatedUsers []*model.MeetingUserFromJson) []*model.MeetingUserFromJson {
+	var users []*model.MeetingUserFromJson
+
+	for _, duplicatedUser := range duplicatedUsers {
+		if duplicatedUser.UserType == "host" {
+			continue
+		}
+		users = append(users, duplicatedUser)
+	}
+
+	return users
+}
+
+//招待者の有効を更新
+func (a *App) UpdateValidMeetingUsers(meetingItemId string, mailAddrs []string, itemValid int) *model.AppError {
+	return a.Srv().Store().Meeting().UpdateValidMeetingUsers(meetingItemId, mailAddrs, itemValid)
+}
+
+//会議を取得(ユーザIDを使用)
+func (a *App) GetMeetingsByUserId(userId string, meetingAfter string, meetingBefore string) ([]*model.RepeatMeetingToJson, *model.AppError) {
+	var meetingsToJson []*model.RepeatMeetingToJson
+	var meetingItemIds []string
+
+	//会議情報を取得
+	meetings, err := a.Srv().Store().Meeting().GetMeetingsByUserId(userId, meetingAfter, meetingBefore)
+	if err != nil || len(meetings) == 0 {
+		return meetingsToJson, err
+	}
+	//会議情報のフォーマット保存
+	jitsiUrl := a.getJitsiUrl()
+	for _, meeting := range meetings {
+		var item model.RepeatMeetingToJson
+		item.MeetingItemId = meeting.MeetingItemId
+		item.MeetingUrl = jitsiUrl + "/" + meeting.MeetingId
+		item.MeetingName = meeting.MeetingName
+		item.StartAt = meeting.StartAt
+		item.EndAt = meeting.EndAt
+		item.TimeZone = meeting.TimeZone
+		item.HostId = meeting.HostId
+		item.HostName = meeting.HostName
+		item.IsRepeat = meeting.IsRepeat
+		item.RepeatConfig = model.RepeatConfigFromJson(meeting.RepeatConfig)
+		item.RepeatEndDate = meeting.RepeatEndDate
+
+		meetingItemIds = append(meetingItemIds, meeting.MeetingItemId)
+		meetingsToJson = append(meetingsToJson, &item)
+	}
+
+	//会議ユーザー情報を取得
+	meetingUsers, err := a.GetMeetingUsersByMeetingItemIds(meetingItemIds)
+	if err != nil || len(meetingUsers) == 0 {
+		return meetingsToJson, err
+	}
+
+	//会議ユーザー情報のフォーマット保存
+	for index, meetingToJson := range meetingsToJson {
+		for _, meetingUser := range meetingUsers {
+			if meetingToJson.MeetingItemId == meetingUser.MeetingItemId {
+				var item model.MeetingUserToJson
+				item.UserId = meetingUser.UserId
+				item.UserMail = meetingUser.UserMail
+
+				meetingToJson.Users = append(meetingToJson.Users, &item)
+			}
+		}
+		meetingsToJson[index] = meetingToJson
+	}
+
+	return meetingsToJson, nil
+}
+
+//除外された単条重複会議情報を取得
+func (a *App) GetDeletedMeetingInfoByMeetingItemIds(meetingItemIds []string) ([]*model.DeleteParamsToJson, *model.AppError) {
+	return a.Srv().Store().Meeting().GetDeletedMeetingInfoByMeetingItemIds(meetingItemIds)
+}
+
+//会議を取得(会議項目IDを使用)
+func (a *App) GetMeeting(meetingItemId string) (*model.RepeatMeetingToJson, *model.AppError) {
+	var meetingToJson model.RepeatMeetingToJson
+
+	//会議情報を取得
+	meeting, err := a.Srv().Store().Meeting().GetMeetingByMeetingItemId(meetingItemId)
+	if err != nil {
+		return &meetingToJson, err
+	}
+
+	if meeting == nil {
+		return nil, nil
+	}
+
+	//会議情報のフォーマット保存
+	meetingToJson.MeetingItemId = meeting.MeetingItemId
+	meetingToJson.MeetingUrl = a.getJitsiUrl() + "/" + meeting.MeetingId
+	meetingToJson.MeetingName = meeting.MeetingName
+	meetingToJson.StartAt = meeting.StartAt
+	meetingToJson.EndAt = meeting.EndAt
+	meetingToJson.TimeZone = meeting.TimeZone
+	meetingToJson.HostId = meeting.HostId
+	meetingToJson.HostName = meeting.HostName
+	meetingToJson.IsRepeat = meeting.IsRepeat
+	meetingToJson.RepeatConfig = model.RepeatConfigFromJson(meeting.RepeatConfig)
+	meetingToJson.RepeatEndDate = meeting.RepeatEndDate
+
+	//会議ユーザー情報を取得
+	var meetingItemIds []string
+	meetingItemIds = append(meetingItemIds, meetingItemId)
+	meetingUsers, err := a.GetMeetingUsersByMeetingItemIds(meetingItemIds)
+	if err != nil || len(meetingUsers) == 0 {
+		return &meetingToJson, err
+	}
+
+	//会議ユーザー情報のフォーマット保存
+	for _, meetingUser := range meetingUsers {
+		var item model.MeetingUserToJson
+		item.UserId = meetingUser.UserId
+		item.UserMail = meetingUser.UserMail
+
+		meetingToJson.Users = append(meetingToJson.Users, &item)
+	}
+
+	return &meetingToJson, nil
+}
+
+//会議ユーザー情報を取得
+func (a *App) GetMeetingUsersByMeetingItemIds(meetingItemIds []string) ([]*model.MeetingUser, *model.AppError) {
+	return a.Srv().Store().Meeting().GetMeetingUsersByMeetingItemIds(meetingItemIds)
+}
+
+//会議を削除
+func (a *App) DeleteMeeting(meetingItemId string, delParams *model.DeleteParamsFromJson) (*model.MeetingMailInfo, *model.AppError) {
+	//削除前に会議情報を取得
+	meeting, err := a.Srv().Store().Meeting().GetMeetingByMeetingItemId(meetingItemId)
+	if err != nil {
+		return nil, err
+	}
+
+	if meeting == nil {
+		return nil, nil
+	}
+
+	switch delParams.DeleteType {
+	//重複していない単独会議を削除
+	//まだ行われていない循環会議をすべて削除
+	case 0:
+		err = a.Srv().Store().Meeting().PermanentDelete(meetingItemId)
+		if err != nil {
+			return nil, err
+		}
+	//重複した会議をすべて削除
+	case 1:
+		meeting.RepeatEndDate = time.Now().UTC().Unix() * 1000
+
+		//繰り返し会議の終了サイクル時間を現在の時間に設定
+		err = a.Srv().Store().Meeting().UpdateMeetingRepeatEndDate(meeting)
+		if err != nil {
+			return nil, err
+		}
+
+		//除外された単条重複会議情報を削除
+		err = a.Srv().Store().Meeting().RemoveDelRepeatMeetingAfterNow(meetingItemId, meeting.RepeatEndDate)
+		if err != nil {
+			return nil, err
+		}
+	//重複した単条会議を削除
+	case 2:
+		err = a.Srv().Store().Meeting().SaveDelRepeatMeeting(meeting, delParams)
+		if err != nil {
+			return nil, err
+		}
+
+		//メールに重複情報を追加しない
+		meeting.IsRepeat = false
+
+		//メールでの会議時間を設定
+		meeting.StartAt = delParams.StartAt
+		meeting.EndAt = delParams.EndAt
+	}
+
+	return a.makeMeetingMailInfo(meeting), nil
+}
+
+//メールを送るための情報を生成
+func (a *App) makeMeetingMailInfo(meeting *model.Meeting) *model.MeetingMailInfo {
+	var meetingMailInfo model.MeetingMailInfo
+	meetingMailInfo.UserName = meeting.HostName
+	meetingMailInfo.MeetingName = meeting.MeetingName
+	meetingMailInfo.MeetingUrl = a.getJitsiUrl() + "/" + meeting.MeetingId
+
+	//タイムゾーンによる書式設定の日付を取得
+	startDate := parseTimeStamp(meeting.StartAt, meeting.TimeZone)
+	EndDate := parseTimeStamp(meeting.EndAt, meeting.TimeZone)
+	meetingMailInfo.StartAtYear = startDate.year
+	meetingMailInfo.StartAtMonth = startDate.month
+	meetingMailInfo.StartAtDay = startDate.day
+	meetingMailInfo.StartAtHour = startDate.hour
+	meetingMailInfo.StartAtMinute = startDate.minute
+	meetingMailInfo.EndAtYear = EndDate.year
+	meetingMailInfo.EndAtMonth = EndDate.month
+	meetingMailInfo.EndAtDay = EndDate.day
+	meetingMailInfo.EndAtHour = EndDate.hour
+	meetingMailInfo.EndAtMinute = EndDate.minute
+	meetingMailInfo.TimeZone = meeting.TimeZone
+	meetingMailInfo.AddRepeatInfo = meeting.IsRepeat
+
+	if meetingMailInfo.AddRepeatInfo == true {
+		meetingMailInfo.RepeatConfig = model.RepeatConfigFromJson(meeting.RepeatConfig)
+		if meetingMailInfo.RepeatConfig.EndType == "date" {
+			endValue := parseTimeStamp(meetingMailInfo.RepeatConfig.EndValue, meeting.TimeZone)
+			meetingMailInfo.EndValueAtYear = endValue.year
+			meetingMailInfo.EndValueAtMonth = endValue.month
+			meetingMailInfo.EndValueAtDay = endValue.day
+		}
+	}
+
+	//ICSファイルIDを設定
+	meetingMailInfo.ICalUID = meeting.ICalUID
+
+	return &meetingMailInfo
+}
+
+//ICSファイルのDTSTAMPを取得
+func (a *App) GetMeetingDtstamp(timeStamp int64) string {
+	date := parseTimeStamp(timeStamp*1000, "Etc/GMT")
+	return date.year + date.month + date.day + "T" + date.hour + date.minute + date.sec + "Z"
+}
+
+//タイムスタンプの日付を取得
+func parseTimeStamp(timeStamp int64, timeZone string) meetingDate {
+	var dateInfo meetingDate
+	tm := time.Unix(timeStamp/1000, 0)
+	local, timeErr := time.LoadLocation(timeZone)
+	if timeErr != nil {
+		return dateInfo
+	}
+	localTime := tm.In(local)
+	dateInfo.year = fmt.Sprintf("%04d", localTime.Year())
+	dateInfo.month = fmt.Sprintf("%02d", localTime.Month())
+	dateInfo.day = fmt.Sprintf("%02d", localTime.Day())
+	dateInfo.hour = fmt.Sprintf("%02d", localTime.Hour())
+	dateInfo.minute = fmt.Sprintf("%02d", localTime.Minute())
+	dateInfo.sec = fmt.Sprintf("%02d", localTime.Second())
+
+	return dateInfo
+}
+
+//JITSIプラグインで設定したURLを取得
+func (a *App) getJitsiUrl() string {
+	jitsiUrl := "https://meet.jit.si"
+
+	pluginConfig := a.Config().PluginSettings.Plugins["jitsi"]["jitsiurl"]
+	if pluginConfig != nil {
+		jitsiUrl = strings.TrimSpace(pluginConfig.(string))
+		jitsiUrl = strings.TrimRight(jitsiUrl, "/")
+	}
+
+	return jitsiUrl
+}
+
+// sinkatec 20210821  start
+type SubscribeCallbackForStatus func(channel, message string)
+type SubscriberForStatus struct {
+	client redis.PubSubConn
+	cbMap  map[string]SubscribeCallbackForStatus
+}
+
+func (a *App) SubscribeRedis() string {
+
+	var sub SubscriberForStatus
+	/* Ryobi Systems CloudOffice MeetingMng Mod 20220214 START */
+	redisIp := os.Getenv("REDIS_CONNECTION_HOST")
+	redisPort := os.Getenv("REDIS_CONNECTION_PORT")
+	err := sub.Connect(redisIp, redisPort)
+	/* Ryobi Systems CloudOffice MeetingMng Mod 20220214 END */
+	if err != nil {
+		mlog.Error(fmt.Sprintln(err))
+		return ""
+	}
+	sub.Subscribe("meeting_channel", a.MeetingCallback)
+
+	for {
+		time.Sleep(1 * time.Second)
+	}
+	return ""
+}
+
+func (c *SubscriberForStatus) Connect(ip string, port string) *model.AppError {
+	conn, err := redis.Dial("tcp", ip+":"+port)
+	if err != nil {
+		mlog.Error("redis dial failed.")
+		return model.NewAppError("app.Connect", "app.meeting_mng.app_error", nil, err.Error(), http.StatusNoContent)
+	}
+	redisPass := os.Getenv("REDIS_CONNECTION_PW")
+	err = conn.Send("auth", redisPass)
+	if err != nil {
+		mlog.Error("redis dial failed.")
+		return model.NewAppError("app.Connect", "app.meeting_mng.app_error", nil, err.Error(), http.StatusNoContent)
+	}
+
+	c.client = redis.PubSubConn{conn}
+	c.cbMap = make(map[string]SubscribeCallbackForStatus)
+
+	go func() {
+		for {
+			switch res := c.client.Receive().(type) {
+			case redis.Message:
+				channel := (*string)(unsafe.Pointer(&res.Channel))
+				message := (*string)(unsafe.Pointer(&res.Data))
+				c.cbMap[*channel](*channel, *message)
+			case redis.Subscription:
+				fmt.Printf("%s: %s %d\n", res.Channel, res.Kind, res.Count)
+			case error:
+				mlog.Error("error handle...")
+				continue
+			}
+		}
+	}()
+	return nil
+
+}
+
+func (c *SubscriberForStatus) Close() {
+	err := c.client.Close()
+	if err != nil {
+		mlog.Error("redis close error.")
+	}
+}
+
+func (c *SubscriberForStatus) Subscribe(channel interface{}, cb SubscribeCallbackForStatus) {
+	err := c.client.Subscribe(channel)
+	if err != nil {
+		mlog.Error("redis Subscribe error.")
+	}
+	// meeting_channel  = MeetingCallback()
+	c.cbMap[channel.(string)] = cb
+}
+
+func (a *App) MeetingCallback(chann, msg string) {
+	mlog.Info("MeetingCallback channel : " + chann + " message : " + msg)
+	var data map[string]interface{}
+	json.Unmarshal([]byte(msg), &data)
+
+	UserEmail := data["userEmail"].(string)
+	MeetingFlg := data["meetingFlg"].(string)
+
+	user, _ := a.GetUserByEmail(UserEmail)
+	status, _ := a.GetStatus(user.Id)
+	//joinmeeting
+	if MeetingFlg == "0" {
+		if status.Status == model.STATUS_MEETING && status.Manual == false {
+			status.PrevStatus = model.STATUS_MEETING
+			a.Srv().Platform().SaveAndBroadcastStatus(status)
+		} else if status.Status == model.StatusOnline || (status.Status == model.StatusAway && status.Manual == false) || (status.Status == model.STATUS_MEETING && status.Manual == true) {
+			status.PrevStatus = model.StatusOnline
+			a.Srv().Platform().AddStatusCacheSkipClusterSend(status)
+			a.SetStatusMeetingIfNeeded(user.Id, false)
+
+		}
+		//leavemeeting
+	} else if MeetingFlg == "1" {
+		if status.Status == model.STATUS_MEETING && status.PrevStatus == model.STATUS_MEETING {
+			boo := a.RepeatMeeting(UserEmail)
+			if boo {
+				return
+			} else {
+				status.PrevStatus = status.Status
+				a.Srv().Platform().AddStatusCacheSkipClusterSend(status)
+				a.SetStatusOnline(user.Id, true)
+			}
+		} else if status.Status == model.STATUS_MEETING {
+			a.SetStatusOnline(user.Id, true)
+		}
+	}
+	return
+}
+
+func (a *App) RepeatMeeting(userEmail string) bool {
+	/* Ryobi Systems CloudOffice MeetingMng Mod 20220214 START */
+	redisIp := os.Getenv("REDIS_CONNECTION_HOST")
+	redisPort := os.Getenv("REDIS_CONNECTION_PORT")
+	conn, rediserr := redis.Dial("tcp", redisIp+":"+redisPort)
+	/* Ryobi Systems CloudOffice MeetingMng Mod 20220214 END */
+	if rediserr != nil {
+		mlog.Error("redis dial failed,from func RepeatMeeting")
+		return true
+	}
+	redisPass := os.Getenv("REDIS_CONNECTION_PW")
+	err := conn.Send("auth", redisPass)
+	if err != nil {
+		mlog.Error("The redis password is incorrect")
+		return true
+	}
+	rulen, _ := redis.Uint64(conn.Do("LLEN", "MEETING_LIST"))
+	rooms, _ := redis.Strings(conn.Do("LRANGE", "MEETING_LIST", 0, rulen))
+	for _, meetingName := range rooms {
+		roomlen, err := redis.Uint64(conn.Do("LLEN", meetingName+"&"+userEmail))
+		if err != nil || roomlen == 0 {
+			continue
+		}
+
+		data, _ := redis.Strings(conn.Do("LRANGE", meetingName+"&"+userEmail, 0, roomlen))
+		var room map[string]interface{}
+		json.Unmarshal([]byte(data[roomlen-1]), &room)
+		endTime := room["endTime"].(string)
+		if endTime == "" {
+			return true
+		}
+
+	}
+	return false
+}
+
+// sinkatec 20210821 end
Index: mattermost-server-7.8.1/app/meeting_mng.go
===================================================================
--- mattermost-server-7.8.1/app/meeting_mng.go	(nonexistent)
+++ mattermost-server-7.8.1/app/meeting_mng.go	(revision 4485)
@@ -0,0 +1,787 @@
+//Copyright 2021 Ryobi Systems Co., Ltd. All Rights Reserved.
+
+package app
+
+import (
+	"encoding/json"
+	"fmt"
+	"github.com/garyburd/redigo/redis"
+	"github.com/mattermost/mattermost-server/v6/app/request"
+	"github.com/mattermost/mattermost-server/v6/model"
+	"github.com/mattermost/mattermost-server/v6/shared/i18n"
+	"github.com/mattermost/mattermost-server/v6/shared/mlog"
+	"github.com/mattermost/mattermost-server/v6/utils"
+	"net/http"
+	"os"
+	"strconv"
+	"strings"
+	"time"
+	"unsafe"
+)
+
+type meetingMngDate struct {
+	year     string
+	month    string
+	day      string
+	hour     string
+	minute   string
+	date     string
+	datetime string
+}
+
+//会議を取得(会議項目IDを使用)
+func (a *App) GetMeetingMng(c *request.Context, meetingMngFromJsonData *model.MeetingMngFromJson) ([]*model.MeetingMngToJson, *model.AppError) {
+	var meetingMngToJsonData []*model.MeetingMngToJson
+
+	//会議情報を取得
+	meetingMngData, err := a.Srv().Store().MeetingMng().GetMeetingMngList(meetingMngFromJsonData)
+	if err != nil {
+		mlog.Error(fmt.Sprintln(err))
+		return meetingMngToJsonData, err
+	}
+	T := i18n.GetUserTranslations(getUserLocale(a, c.Session().UserId))
+	// Redisの情報を取得
+	/* Ryobi Systems CloudOffice MeetingMng Mod 20220214 END */
+	ip, pass, port, _ := a.getRedisIpAndPass()
+
+	conn, rediserr := redis.Dial("tcp", ip+":"+port)
+	/* Ryobi Systems CloudOffice MeetingMng Mod 20220214 END */
+	if rediserr != nil {
+		mlog.Error(T("app.meeting.redis_connect_error"))
+		return meetingMngToJsonData, model.NewAppError("app.GetMeetingMng", "app.meeting_mng.app_error", nil, rediserr.Error(), http.StatusNoContent)
+	}
+	rediserr = conn.Send("auth", pass)
+	if rediserr != nil {
+		mlog.Error(T("app.meeting.redis_pass_error"))
+		return meetingMngToJsonData, model.NewAppError("app.GetMeetingMng", "app.meeting_mng.app_error", nil, rediserr.Error(), http.StatusNoContent)
+	}
+	defer conn.Close()
+	for _, meeting := range meetingMngData {
+		//　データ初期化
+		var item model.MeetingMngToJson
+		item.TimeZone = meeting.TimeZone
+		item.MeetingItemId = meeting.MeetingItemId
+		item.MeetingName = meeting.MeetingName // 会議名
+		item.MeetingCount = "1"                // 会議数
+		if meeting.MeetingStartTime == 0 {
+			item.MeetMeetingCount = "0" // 開催した会議数
+		} else {
+			item.MeetMeetingCount = "1" // 開催した会議数
+		}
+		item.UserCount = meeting.UserCount // 招待者人数
+		if meeting.SumMemberCount == 0 {
+			item.MeetUserCount = "-" // 実績会議参加人数
+		} else {
+			item.MeetUserCount = strconv.Itoa(meeting.SumMemberCount)
+		}
+
+		mStartAt := meeting.StartAt / 1000 / 60
+		mEndAt := meeting.EndAt / 1000 / 60
+		mTimes := uint64(mEndAt) - uint64(mStartAt)
+		item.MeetingTimes = strconv.FormatUint(mTimes, 10) // 予約会議時間
+
+		if meeting.MeetingStartTime == 0 {
+			item.MeetMeetingTimes = "0" //　実績開催時間
+		} else {
+			MStartTime := meeting.MeetingStartTime / 1000 / 60
+			MEndTime := meeting.MeetingEndTime / 1000 / 60
+			meTimes := MEndTime - MStartTime
+			item.MeetMeetingTimes = strconv.FormatInt(meTimes, 10) // 実績開催時間
+		}
+
+		item.IsRepeat = meeting.IsRepeat
+		a.getRepeatData(&item, meeting.RepeatConfig, meeting.TimeZone)
+
+		startAt := parseDateTime(meeting.StartAt, meeting.TimeZone)
+		endAt := parseDateTime(meeting.EndAt, meeting.TimeZone)
+		item.StartAt = startAt.datetime // 会議予約開始時間
+		item.EndAt = endAt.datetime     // 会議予約終了時間
+		/* Ryobi Systems CloudOffice post Mod 20211221 START */
+		item.IsProgressMeeting = false // 会議が始まるかどうか
+		/* Ryobi Systems CloudOffice post Mod 20211221 END */
+
+		RepeatEndDate := parseDateTime(meeting.RepeatEndDate, meeting.TimeZone)
+		if meeting.RepeatEndDate == 0 {
+			item.RepeatEndDate = ""
+		} else {
+			item.RepeatEndDate = RepeatEndDate.datetime
+		}
+
+		// 会議オーナー
+		if meeting.LastName+meeting.FirstName == "" {
+			item.Creater = meeting.UserName
+		} else {
+			item.Creater = meeting.UserName + "(" + meeting.LastName + meeting.FirstName + ")"
+		}
+
+		// 繰り返しの会議の場合
+		if meeting.IsRepeat == true {
+			if meeting.RepeatEndDate != 0 {
+				item.EndAt = RepeatEndDate.datetime // 会議予約終了時間
+			}
+
+			item.StartTime = T("app.meeting.repeat_start")
+			item.EndTime = T("app.meeting.repeat_end")
+		} else {
+			if meeting.MeetingStartTime != 0 {
+				startDate := parseDateTime(meeting.MeetingStartTime, meeting.TimeZone)
+				item.StartTime = startDate.datetime
+			} else {
+				item.StartTime = ""
+			}
+
+			if meeting.MeetingEndTime != 0 {
+				endDate := parseDateTime(meeting.MeetingEndTime, meeting.TimeZone)
+				item.EndTime = endDate.datetime
+			} else {
+				item.EndTime = ""
+			}
+		}
+
+		// Redis データ検索
+		rlen, _ := redis.Uint64(conn.Do("LLEN", meeting.MeetingId))
+		// redisにデータがない場合
+		if rlen == 0 {
+			meetingMngToJsonData = append(meetingMngToJsonData, &item)
+			continue
+		}
+		rdata, _ := redis.Strings(conn.Do("LRANGE", meeting.MeetingId, 0, rlen))
+
+		var mapdata map[string]interface{}
+		json.Unmarshal([]byte(rdata[rlen-1]), &mapdata)
+		meetingStartTime := mapdata["meetingStartTime"].(string)
+		sumMemberCount := mapdata["sumMemberCount"].(string)
+		meetingEndTime := mapdata["meetingEndTime"].(string)
+		item.MeetUserCount = sumMemberCount //実績の会議参加者数
+
+		// 会議終了していない場合
+		if meetingEndTime == "" {
+			local, _ := time.LoadLocation(meeting.TimeZone)
+			lt := time.Now().In(local).Unix()
+			endTime := strconv.FormatInt(lt*1000, 10)
+			item.MeetMeetingTimes = getTimes(meetingStartTime, endTime, "m") //実績の会議時間
+		} else {
+			item.MeetMeetingTimes = getTimes(meetingStartTime, meetingEndTime, "m") //実績の会議時間
+		}
+		item.MeetMeetingCount = "1" // 開催した会議数
+
+		/* Ryobi Systems CloudOffice post Mod 20211221 START */
+		if meetingStartTime != "" && meetingEndTime == "" {
+			item.IsProgressMeeting = true // 会議が始まるかどうか
+		}
+		/* Ryobi Systems CloudOffice post Mod 20211221 END */
+
+		// 繰り返しの会議の場合
+		if meeting.IsRepeat == false {
+			if meetingStartTime != "" {
+				rstart, _ := strconv.ParseInt(meetingStartTime, 10, 64) // redisの会議開始時間　int64
+				startDate := parseDateTime(rstart, meeting.TimeZone)
+				item.StartTime = startDate.datetime
+			} else {
+				item.StartTime = ""
+			}
+
+			if meetingEndTime != "" {
+				rend, _ := strconv.ParseInt(meetingEndTime, 10, 64) // redisの会議終了時間　int64
+				endDate := parseDateTime(rend, meeting.TimeZone)
+				item.EndTime = endDate.datetime
+			} else {
+				item.EndTime = ""
+			}
+		}
+
+		meetingMngToJsonData = append(meetingMngToJsonData, &item)
+	}
+
+	return meetingMngToJsonData, nil
+}
+
+//会議を削除(会議項目IDを使用)
+func (a *App) MeetingMngDelete(meetingItemId string) (*model.MeetingMailInfo, *model.AppError) {
+	//会議詳細を取得
+	meetingdet, err := a.Srv().Store().MeetingMng().GetMeetingMngsByMeetingItemId(meetingItemId)
+	if err != nil {
+		return nil, err
+	}
+	if meetingdet == nil {
+		return nil, nil
+	}
+	// 繰り返しの会議の場合
+	if meetingdet.IsRepeat == true {
+		// 繰り返しの削除データ
+		times := getTimeOfTimezone(meetingdet.TimeZone)
+		endData := strconv.FormatInt(meetingdet.RepeatEndDate, 10)
+		if endData != "0" && times > endData {
+			return nil, nil
+		}
+		// 繰り返しの削除会議がある場合　終了日を今日にする
+		delerr := a.Srv().Store().MeetingMng().UpdateMeetingMngByMeetingItemId(meetingdet.MeetingItemId, times)
+		if delerr != nil {
+			return nil, delerr
+		}
+	} else {
+		delerr := a.Srv().Store().MeetingMng().DeleteMeetingMngByMeetingItemId(meetingdet.MeetingItemId)
+		if delerr != nil {
+			return nil, delerr
+		}
+	}
+
+	return a.makeMeetingMngMailInfo(meetingdet), nil
+}
+
+//メールを送るための情報を生成
+func (a *App) makeMeetingMngMailInfo(meetingdet *model.MeetingMng) *model.MeetingMailInfo {
+
+	var meetingMngMailInfo model.MeetingMailInfo
+	meetingMngMailInfo.UserName = meetingdet.HostName
+	meetingMngMailInfo.MeetingName = meetingdet.MeetingName
+	meetingName := strings.ReplaceAll(meetingdet.MeetingName, "-", "%2d")
+	meetingMngMailInfo.MeetingUrl = a.getJitsiUrl() + "/" + meetingdet.MeetingId + "#config.callDisplayName=" + utils.URLEncode("\"") + meetingName + utils.URLEncode("\"")
+
+	//タイムゾーンによる書式設定の日付を取得
+	startDate := parseTimeStamp(meetingdet.StartAt, meetingdet.TimeZone)
+	EndDate := parseTimeStamp(meetingdet.EndAt, meetingdet.TimeZone)
+	meetingMngMailInfo.StartAtYear = startDate.year
+	meetingMngMailInfo.StartAtMonth = startDate.month
+	meetingMngMailInfo.StartAtDay = startDate.day
+	meetingMngMailInfo.StartAtHour = startDate.hour
+	meetingMngMailInfo.StartAtMinute = startDate.minute
+	meetingMngMailInfo.EndAtYear = EndDate.year
+	meetingMngMailInfo.EndAtMonth = EndDate.month
+	meetingMngMailInfo.EndAtDay = EndDate.day
+	meetingMngMailInfo.EndAtHour = EndDate.hour
+	meetingMngMailInfo.EndAtMinute = EndDate.minute
+	meetingMngMailInfo.TimeZone = meetingdet.TimeZone
+	meetingMngMailInfo.AddRepeatInfo = meetingdet.IsRepeat
+
+	if meetingMngMailInfo.AddRepeatInfo == true {
+		meetingMngMailInfo.RepeatConfig = model.RepeatConfigFromJson(meetingdet.RepeatConfig)
+		if meetingMngMailInfo.RepeatConfig.EndType == "date" {
+			endValue := parseTimeStamp(meetingMngMailInfo.RepeatConfig.EndValue, meetingdet.TimeZone)
+			meetingMngMailInfo.EndValueAtYear = endValue.year
+			meetingMngMailInfo.EndValueAtMonth = endValue.month
+			meetingMngMailInfo.EndValueAtDay = endValue.day
+		}
+	}
+
+	//ICSファイルIDを設定
+	meetingMngMailInfo.ICalUID = meetingdet.ICalUID
+
+	return &meetingMngMailInfo
+}
+
+//会議詳細を取得(会議項目IDを使用)
+func (a *App) GetMeetingMngDetail(c *request.Context, MeetingItemId string) (*model.MeetingMngDetailToJson, *model.AppError) {
+	var meetingMngDetailToJsonData model.MeetingMngDetailToJson
+	var userNameList []string
+
+	T := i18n.GetUserTranslations(getUserLocale(a, c.Session().UserId))
+
+	//会議詳細を取得
+	meetingdet, err := a.Srv().Store().MeetingMng().GetMeetingMngEndByMeetingItemId(MeetingItemId)
+	if err != nil {
+		mlog.Error(fmt.Sprintln(err))
+		return &meetingMngDetailToJsonData, err
+	}
+	meetingMngDetailToJsonData.MeetingItemId = meetingdet.MeetingItemId
+	meetingMngDetailToJsonData.MeetingName = meetingdet.MeetingName
+	meetingMngDetailToJsonData.TimeZone = T(model.RSMeetingTimezonesI18n[meetingdet.TimeZone])
+	meetingMngDetailToJsonData.Creater = meetingdet.HostName
+
+	startAt := parseDateTime(meetingdet.StartAt, meetingdet.TimeZone)
+	meetingMngDetailToJsonData.StartAt = startAt.datetime
+	endAt := parseDateTime(meetingdet.EndAt, meetingdet.TimeZone)
+	meetingMngDetailToJsonData.EndAt = endAt.datetime
+
+	if meetingdet.MeetingStartTime == 0 {
+		meetingMngDetailToJsonData.StartTime = ""
+	} else {
+		startDate := parseDateTime(meetingdet.MeetingStartTime, meetingdet.TimeZone)
+		meetingMngDetailToJsonData.StartTime = startDate.datetime
+
+	}
+	if meetingdet.MeetingEndTime == 0 {
+		meetingMngDetailToJsonData.EndTime = ""
+	} else {
+		endDate := parseDateTime(meetingdet.MeetingEndTime, meetingdet.TimeZone)
+		meetingMngDetailToJsonData.EndTime = endDate.datetime
+	}
+
+	if meetingdet.RepeatEndDate == 0 {
+		meetingMngDetailToJsonData.RepeatEndDate = ""
+	} else {
+		RepeatEndDate := parseDateTime(meetingdet.RepeatEndDate, meetingdet.TimeZone)
+		meetingMngDetailToJsonData.RepeatEndDate = RepeatEndDate.date
+	}
+	// 参加者リスト
+	endUsers, err := a.Srv().Store().MeetingMng().GetMeetingEndUsers(meetingdet.MeetingId, meetingdet.MeetingStartTime)
+	if err != nil {
+		mlog.Error(fmt.Sprintln(err))
+		return &meetingMngDetailToJsonData, err
+	}
+	for _, endUser := range endUsers {
+		// 会議参加時間
+		ustart, _ := strconv.ParseInt(endUser.StartTime, 10, 64) // redisの会議開始時間　int64
+		ustartDate := parseDateTime(ustart, meetingdet.TimeZone)
+		endUser.StartTime = ustartDate.datetime
+		// 会議退出時間
+		if endUser.EndTime == "0" {
+			endUser.EndTime = ""
+		} else {
+			uend, _ := strconv.ParseInt(endUser.EndTime, 10, 64) // redisの会議開始時間　int64
+			uendDate := parseDateTime(uend, meetingdet.TimeZone)
+			endUser.EndTime = uendDate.datetime
+		}
+	}
+	meetingMngDetailToJsonData.Users = endUsers
+	a.getMeetingUsersListInRedis(T, &meetingMngDetailToJsonData, meetingdet)
+
+	// 招待者リスト
+	meetingusers, err := a.Srv().Store().MeetingMng().GetMeetingMngUsersByMeetingItemId(MeetingItemId)
+	if err != nil {
+		mlog.Error(fmt.Sprintln(err))
+		return &meetingMngDetailToJsonData, err
+	}
+	for _, meeting := range meetingusers {
+		if meeting.LastName+meeting.FirstName == "" {
+			userNameList = append(userNameList, meeting.UserName)
+		} else {
+			fullNme := meeting.UserName + "(" + meeting.LastName + meeting.FirstName + ")"
+			userNameList = append(userNameList, fullNme)
+		}
+	}
+	meetingMngDetailToJsonData.UserList = userNameList
+
+	// 繰り返し詳細
+	meetingMngDetailToJsonData.IsRepeat = meetingdet.IsRepeat
+	if meetingdet.IsRepeat == true {
+		a.getRepeatDataToDetail(&meetingMngDetailToJsonData, meetingdet)
+	}
+
+	return &meetingMngDetailToJsonData, nil
+}
+
+//　会議参加者リスト
+func (a *App) getMeetingUsersListInRedis(T i18n.TranslateFunc, meetingMngDetailToJsonData *model.MeetingMngDetailToJson, meetingdet *model.MeetingsMeetingEnd) {
+	// Redisの情報を取得
+	/* Ryobi Systems CloudOffice MeetingMng Mod 20220214 START */
+	ip, pass, port, _ := a.getRedisIpAndPass()
+	conn, rediserr := redis.Dial("tcp", ip+":"+port)
+	/* Ryobi Systems CloudOffice MeetingMng Mod 20220214 END */
+	if rediserr != nil {
+		mlog.Error(T("app.meeting.redis_connect_error"))
+		return
+	}
+	rediserr = conn.Send("auth", pass)
+	if rediserr != nil {
+		mlog.Error(T("app.meeting.redis_pass_error"))
+		return
+	}
+	defer conn.Close()
+
+	var meetingMngUserToJsonData []*model.MeetingMngUserToJson
+	len, _ := redis.Uint64(conn.Do("LLEN", meetingdet.MeetingId+"_USERLIST"))
+	if len == 0 {
+		return
+	}
+	ruserlist, _ := redis.Strings(conn.Do("LRANGE", meetingdet.MeetingId+"_USERLIST", 0, len))
+	ruserlist = strings.Split(ruserlist[len-1], ";")
+	// DBに存在する参加者
+	dbUsers, _ := a.Srv().Store().MeetingMng().GetUsersByUserMails(ruserlist)
+	for _, meeting := range dbUsers {
+		var item model.MeetingMngUserToJson
+		item.UserMail = meeting.Email
+		item.UserName = meeting.UserName
+		item.FirstName = meeting.FirstName
+		item.LastName = meeting.LastName
+
+		rulen, _ := redis.Uint64(conn.Do("LLEN", meetingdet.MeetingId+"&"+meeting.Email))
+		if rulen == 0 {
+			continue
+		}
+		rudata, ruerr := redis.Strings(conn.Do("LRANGE", meetingdet.MeetingId+"&"+meeting.Email, 0, rulen))
+		if ruerr != nil {
+			mlog.Error(fmt.Sprintln(ruerr))
+			return
+		}
+		var mapdata map[string]interface{}
+		json.Unmarshal([]byte(rudata[rulen-1]), &mapdata)
+		a.getUserRedisData(mapdata, &item, meetingdet.TimeZone)
+		meetingMngUserToJsonData = append(meetingMngUserToJsonData, &item)
+	}
+	cnt := 0
+	// DBに存在しない参加者の処理
+	for _, usermail := range ruserlist {
+		indb := false
+		//　DBに存在する場合　次に行く
+		for _, user := range dbUsers {
+			if usermail == user.Email {
+				indb = true
+				break
+			}
+		}
+		if indb == true {
+			continue
+		}
+		var item model.MeetingMngUserToJson
+		if strings.Contains(usermail, "EMAILNOTSET_") {
+			cnt = cnt + 1
+			item.UserMail = usermail
+			item.UserName = "参加者" + strconv.Itoa(cnt)
+		} else {
+			item.UserMail = usermail
+			item.UserName = ""
+		}
+
+		rulen, _ := redis.Uint64(conn.Do("LLEN", meetingdet.MeetingId+"&"+usermail))
+		if rulen == 0 {
+			continue
+		}
+		rudata, ruerr := redis.Strings(conn.Do("LRANGE", meetingdet.MeetingId+"&"+usermail, 0, rulen))
+		if ruerr != nil {
+			mlog.Error(fmt.Sprintln(ruerr))
+			return
+		}
+		var mapdata map[string]interface{}
+		json.Unmarshal([]byte(rudata[rulen-1]), &mapdata)
+		a.getUserRedisData(mapdata, &item, meetingdet.TimeZone)
+		meetingMngUserToJsonData = append(meetingMngUserToJsonData, &item)
+	}
+
+	meetingMngDetailToJsonData.Users = meetingMngUserToJsonData
+	conn.Close()
+}
+func (a *App) getUserRedisData(mapdata map[string]interface{}, item *model.MeetingMngUserToJson, timeZone string) {
+	owner := mapdata["owner"].(string)
+	remoteIp := mapdata["remoteIp"].(string)
+	localIp := mapdata["localIp"].(string)
+	startTime := mapdata["startTime"].(string)
+	endTime := mapdata["endTime"].(string)
+
+	item.Owner = owner
+
+	if startTime != "" {
+		rustart, _ := strconv.ParseInt(startTime, 10, 64) // redisの会議開始時間　int64
+		rustartDate := parseDateTime(rustart, timeZone)
+		item.StartTime = rustartDate.datetime
+	} else {
+		item.StartTime = ""
+	}
+
+	if endTime != "" {
+		ruend, _ := strconv.ParseInt(endTime, 10, 64) // redisの会議終了時間　int64
+		ruendDate := parseDateTime(ruend, timeZone)
+		item.EndTime = ruendDate.datetime
+	} else {
+		item.EndTime = ""
+	}
+	item.RemoteIp = remoteIp
+	item.LocalIp = localIp
+}
+
+//会議ユーザー情報を取得
+func (a *App) GetMeetingMngUsersByMeetingItemIdFormail(meetingItemId string) ([]*model.MeetingMngUser, *model.AppError) {
+	return a.Srv().Store().MeetingMng().GetMeetingMngUsersByMeetingItemIdFormail(meetingItemId)
+}
+func (a *App) getRepeatData(MeetingMngToJson *model.MeetingMngToJson, meetingConfig string, timeZone string) *model.MeetingMngToJson {
+
+	meetingMngRepeatConfigData := model.MeetingMngRepeatFromString(meetingConfig)
+	MeetingMngToJson.RepeatType = meetingMngRepeatConfigData.RepeatType
+	MeetingMngToJson.RepeatTimes = meetingMngRepeatConfigData.RepeatFrequencyTimes
+	MeetingMngToJson.RepeatTimesType = meetingMngRepeatConfigData.RepeatFrequencyTimesType
+	MeetingMngToJson.RepeatWeekdays = meetingMngRepeatConfigData.RepeatFrequencyWeekdays
+	MeetingMngToJson.RepeatDays = meetingMngRepeatConfigData.RepeatFrequencyDays
+	MeetingMngToJson.RepeatWeekTimes = meetingMngRepeatConfigData.RepeatFrequencyWeekTimes
+	MeetingMngToJson.RepeatWeekday = meetingMngRepeatConfigData.RepeatFrequencyWeekday
+	MeetingMngToJson.RepeatEndType = meetingMngRepeatConfigData.EndType
+
+	switch meetingMngRepeatConfigData.EndType {
+	case "none":
+		MeetingMngToJson.RepeatEndValue = "0"
+	case "date":
+		repeatEndDate := parseDateTime(meetingMngRepeatConfigData.EndValue, timeZone)
+		MeetingMngToJson.RepeatEndValue = repeatEndDate.date
+	case "times":
+		MeetingMngToJson.RepeatEndValue = strconv.FormatInt(meetingMngRepeatConfigData.EndValue, 10)
+	}
+	return MeetingMngToJson
+}
+
+//繰り返し詳細習得
+func (a *App) getRepeatDataToDetail(meetingMngDetailToJsonData *model.MeetingMngDetailToJson, meetingdet *model.MeetingsMeetingEnd) {
+	var MeetingMngToJson model.MeetingMngToJson
+	a.getRepeatData(&MeetingMngToJson, meetingdet.RepeatConfig, meetingdet.TimeZone)
+
+	meetingMngDetailToJsonData.RepeatType = MeetingMngToJson.RepeatType
+	meetingMngDetailToJsonData.RepeatTimes = MeetingMngToJson.RepeatTimes
+	meetingMngDetailToJsonData.RepeatTimesType = MeetingMngToJson.RepeatTimesType
+	meetingMngDetailToJsonData.RepeatWeekdays = MeetingMngToJson.RepeatWeekdays
+	meetingMngDetailToJsonData.RepeatDays = MeetingMngToJson.RepeatDays
+	meetingMngDetailToJsonData.RepeatWeekTimes = MeetingMngToJson.RepeatWeekTimes
+	meetingMngDetailToJsonData.RepeatWeekday = MeetingMngToJson.RepeatWeekday
+	meetingMngDetailToJsonData.RepeatEndType = MeetingMngToJson.RepeatEndType
+	meetingMngDetailToJsonData.RepeatEndValue = MeetingMngToJson.RepeatEndValue
+}
+
+//繰り返し詳細習得
+/* Ryobi Systems CloudOffice MeetingMng Mod 20220214 START */
+func (a *App) getRedisIpAndPass() (string, string, string, *model.AppError) {
+	// システムから設定を取得
+	var redisIp string
+	redisIp = os.Getenv("REDIS_CONNECTION_HOST")
+	var redisPass string
+	redisPass = os.Getenv("REDIS_CONNECTION_PW")
+	var redisPort string
+	redisPort = os.Getenv("REDIS_CONNECTION_PORT")
+
+	return redisIp, redisPass, redisPort, nil
+	/* Ryobi Systems CloudOffice MeetingMng Mod 20220214 END */
+}
+
+//タイムスタンプの日付を取得
+func parseDateTime(timeStamp int64, timeZone string) meetingMngDate {
+	var dateInfo meetingMngDate
+	tm := time.Unix(timeStamp/1000, 0)
+
+	local, timeErr := time.LoadLocation(timeZone)
+	if timeErr != nil {
+		return dateInfo
+	}
+
+	localTime := tm.In(local)
+	dateInfo.year = fmt.Sprintf("%04d", localTime.Year())
+	dateInfo.month = fmt.Sprintf("%02d", localTime.Month())
+	dateInfo.day = fmt.Sprintf("%02d", localTime.Day())
+	dateInfo.hour = fmt.Sprintf("%02d", localTime.Hour())
+	dateInfo.minute = fmt.Sprintf("%02d", localTime.Minute())
+	year, month, day := localTime.Date()
+	//hour, minute, second := localTime.Clock()
+	hour, minute, _ := localTime.Clock()
+	dateInfo.date = fmt.Sprintf("%04d/%02d/%02d", year, month, day)
+	dateInfo.datetime = fmt.Sprintf("%04d/%02d/%02d %02d:%02d", year, month, day, hour, minute)
+
+	return dateInfo
+}
+
+//ユーザ言語の種類を取得
+func getUserLocale(a *App, userId string) string {
+	userLocale := "ja"
+
+	if userId == "" {
+		return userLocale
+	}
+
+	user, err := a.GetUser(userId)
+	if err != nil {
+		return userLocale
+	}
+
+	userLocale = user.Locale
+	return userLocale
+}
+
+// タイムゾンにおいて時間をとる
+func getTimeOfTimezone(timeZone string) string {
+	t := time.Now()
+	utc, err := time.LoadLocation(timeZone)
+	if err != nil {
+		fmt.Println("err: ", err.Error())
+	}
+
+	return strconv.FormatInt(t.In(utc).Unix()*1000, 10)
+}
+
+// タイムゾンにおいて時間をとる
+func getTimes(startTime string, endTime string, flg string) string {
+	tstart, _ := strconv.Atoi(startTime)
+	tend, _ := strconv.Atoi(endTime)
+	if flg == "m" {
+		tstart = tstart / 1000 / 60
+		tend = tend / 1000 / 60
+	}
+	if flg == "h" {
+		tstart = tstart / 1000 / 60 / 60
+		tend = tend / 1000 / 60 / 60
+	}
+	ttimes := tend - tstart
+
+	times := strconv.Itoa(ttimes)
+
+	return times
+}
+
+// sinkatec 20211008 追加 start
+type SubscribeCallback func(channel, message string, ip string, port string, pass string)
+type Subscriber struct {
+	client redis.PubSubConn
+	cbMap  map[string]SubscribeCallback
+}
+
+var RedisConnFlg bool
+
+func (a *App) SubscribeRedisMeetingEnd() {
+	mlog.Info("===========Subscribe Redis main start============")
+
+	RedisConnFlg = false
+	for {
+		if RedisConnFlg == false {
+			var sub Subscriber
+			/* Ryobi Systems CloudOffice MeetingMng Mod 20220214 START */
+			ip, pass, port, _ := a.getRedisIpAndPass()
+			err := sub.Connect(ip, port, pass)
+			/* Ryobi Systems CloudOffice MeetingMng Mod 20220214 END */
+			if err != nil {
+				mlog.Error(fmt.Sprintln(err))
+				RedisConnFlg = false
+			} else {
+				sub.Subscribe("meeting_End", a.MeetingEndCallback)
+				RedisConnFlg = true
+			}
+		}
+
+		time.Sleep(60 * time.Second)
+	}
+}
+
+func (c *Subscriber) Connect(ip string, port string, pass string) *model.AppError {
+	conn, err := c.RedisConn(ip, port, pass)
+
+	c.client = redis.PubSubConn{conn}
+	c.cbMap = make(map[string]SubscribeCallback)
+	errCnt := 0
+
+	go func() {
+		for {
+			if conn != nil {
+				if errCnt < 5 {
+					mlog.Info("wait...")
+				}
+				switch res := c.client.Receive().(type) {
+				case redis.Message:
+					channel := (*string)(unsafe.Pointer(&res.Channel))
+					message := (*string)(unsafe.Pointer(&res.Data))
+					c.cbMap[*channel](*channel, *message, ip, port, pass)
+				case redis.Subscription:
+					fmt.Printf("%s: %s %d\n", res.Channel, res.Kind, res.Count)
+				case error:
+					errCnt++
+					if errCnt < 5 {
+						mlog.Error("error handle...")
+					} else {
+						RedisConnFlg = false
+						return
+					}
+					continue
+				}
+			} else {
+				return
+			}
+		}
+	}()
+
+	return err
+}
+
+func (c *Subscriber) RedisConn(ip string, port string, pass string) (redis.Conn, *model.AppError) {
+	conn, err := redis.Dial("tcp", ip+":"+port)
+	if err != nil {
+		mlog.Error("redis dial failed.")
+		return nil, model.NewAppError("app.Connect", "app.meeting_mng.app_error", nil, err.Error(), http.StatusNoContent)
+	}
+	err = conn.Send("auth", pass)
+	if err != nil {
+		mlog.Error("redis dial failed.")
+		return nil, model.NewAppError("app.Connect", "app.meeting_mng.app_error", nil, err.Error(), http.StatusNoContent)
+	}
+	return conn, nil
+}
+
+func (c *Subscriber) Close() {
+	err := c.client.Close()
+	if err != nil {
+		mlog.Error("redis close error.")
+	}
+}
+
+func (c *Subscriber) Subscribe(channel interface{}, cb SubscribeCallback) {
+	err := c.client.Subscribe(channel)
+	if err != nil {
+		mlog.Error("redis Subscribe error.")
+	}
+	c.cbMap[channel.(string)] = cb
+}
+
+func (a *App) MeetingEndCallback(chann, msg string, ip string, port string, pass string) {
+	conn, err := redis.Dial("tcp", ip+":"+port)
+	if err != nil {
+		mlog.Error("redis dial failed.")
+		return
+	}
+	rediserr := conn.Send("auth", pass)
+	if rediserr != nil {
+		mlog.Error("redis connect auth pass error")
+		return
+	}
+
+	var data map[string]interface{}
+	json.Unmarshal([]byte(msg), &data)
+	meetingId := data["meetingId"].(string)
+
+	//会議リストから該当会議を削除する
+	redis.Uint64(conn.Do("LREM", "MEETING_LIST", 1, meetingId))
+
+	//reids データ取得
+	len, _ := redis.Uint64(conn.Do("LLEN", meetingId))
+	if len == 0 {
+		return
+	}
+	var meetingDatas []string
+	var meetingMngUserRedis []*model.MeetingMngUserRedis
+
+	// 会議実行回数
+	for i := 0; i < int(len); i++ {
+		// 該当会議の詳細を取得する
+		meetingdata, _ := redis.Strings(conn.Do("LPOP", meetingId, 1))
+		meetingDatas = append(meetingDatas, meetingdata[0])
+
+		var mapdata map[string]interface{}
+		json.Unmarshal([]byte(meetingdata[0]), &mapdata)
+
+		//　会議参加したユーザリスト
+		userlist, _ := redis.Strings(conn.Do("LPOP", meetingId+"_USERLIST", 1))
+		usermails := strings.Split(userlist[0], ";")
+		for _, usermail := range usermails {
+			//　ユーザ詳細
+			user, _ := redis.Strings(conn.Do("LPOP", meetingId+"&"+usermail, 1))
+
+			var item model.MeetingMngUserRedis
+			item.MeetingStartTime = mapdata["meetingStartTime"].(string)
+			item.UserMail = usermail
+
+			var mdata map[string]interface{}
+			json.Unmarshal([]byte(user[0]), &mdata)
+			item.Owner = mdata["owner"].(string)
+			item.StartTime = mdata["startTime"].(string)
+			item.EndTime = mdata["endTime"].(string)
+			item.RemoteIp = mdata["remoteIp"].(string)
+			item.LocalIp = mdata["localIp"].(string)
+			meetingMngUserRedis = append(meetingMngUserRedis, &item)
+		}
+	}
+	conn.Close()
+
+	// redisの開催済みのデータをDBに格納する
+	merr := a.Srv().Store().MeetingMng().SaveRedisMeeting(meetingId, meetingDatas)
+	if merr != nil {
+		mlog.Error(fmt.Sprintln(merr))
+	}
+	// 会議参加したユーザをDBに格納する
+	uerr := a.Srv().Store().MeetingMng().SaveRedisMeetingUser(meetingId, meetingMngUserRedis)
+	if uerr != nil {
+		mlog.Error(fmt.Sprintln(uerr))
+	}
+
+	return
+}
+
+// sinkatec 20211008 追加 end
Index: mattermost-server-7.8.1/app/meeting_status.go
===================================================================
--- mattermost-server-7.8.1/app/meeting_status.go	(nonexistent)
+++ mattermost-server-7.8.1/app/meeting_status.go	(revision 4485)
@@ -0,0 +1,205 @@
+//Copyright 2021 Ryobi Systems Co., Ltd. All Rights Reserved.
+
+package app
+
+import (
+	"github.com/garyburd/redigo/redis"
+	"os"
+	// "github.com/mattermost/mattermost-server/v6/utils"
+	"encoding/json"
+	"github.com/mattermost/mattermost-server/v6/model"
+	"github.com/mattermost/mattermost-server/v6/shared/mlog"
+	"strconv"
+	"time"
+)
+
+// Web会議状態レポートを取得
+func (a *App) GetMeetingStatus() ([]*model.MeetingStatusToJson, *model.AppError, bool) {
+	var meetingStatusToJsonData []*model.MeetingStatusToJson
+	var meetingIdList []string
+	var userEmailList []string
+
+	// Redisの情報を取得
+	/* Ryobi Systems CloudOffice MeetingStatus Mod 20220214 START */
+	ip, pass, port, _ := a.getRedisIp()
+
+	conn, rediserr := redis.Dial("tcp", ip+":"+port)
+
+	/* Ryobi Systems CloudOffice MeetingStatus Mod 20220214 END */
+	if rediserr != nil {
+		mlog.Err(rediserr)
+		return meetingStatusToJsonData, nil, false
+	}
+	rediserr = conn.Send("auth", pass)
+	if rediserr != nil {
+		mlog.Err(rediserr)
+		return meetingStatusToJsonData, nil, false
+	}
+	defer conn.Close()
+
+	count, err := redis.Uint64(conn.Do("LLEN", "MEETING_LIST"))
+
+	if err != nil {
+		mlog.Err(err)
+		return meetingStatusToJsonData, nil, false
+	}
+
+	if count == 0 {
+		return meetingStatusToJsonData, nil, true
+	}
+
+	meetingIds, err := redis.Strings(conn.Do("LRANGE", "MEETING_LIST", 0, count))
+
+	if err != nil {
+		mlog.Err(err)
+		return meetingStatusToJsonData, nil, false
+	}
+
+	// Redis データ検索
+	for _, meetingId := range meetingIds {
+
+		rlen, _ := redis.Uint64(conn.Do("LLEN", meetingId))
+
+		if rlen != 0 {
+			rdata, _ := redis.Strings(conn.Do("LRANGE", meetingId, 0, rlen))
+			meetingIdList = append(meetingIdList, meetingId)
+
+			for _, ritem := range rdata {
+				var item model.MeetingStatusToJson
+				var mapdata map[string]interface{}
+				json.Unmarshal([]byte(ritem), &mapdata)
+				if mapdata["currentMemberCount"].(string) != "0" && mapdata["meetingStartTime"].(string) != "" {
+					userEmailList = append(userEmailList, mapdata["userEmail"].(string))
+					item.Creater = mapdata["userEmail"].(string)
+					item.MeetingId = meetingId
+					item.MeetUserCount, _ = strconv.Atoi(mapdata["currentMemberCount"].(string))
+					item.MeetingName = "進行中の会議"
+					meetingStatusToJsonData = append(meetingStatusToJsonData, &item)
+				}
+			}
+		}
+	}
+
+	//会議名を追加する
+	meetingDatas, _ := a.Srv().Store().MeetingStatus().GetMeetingNames(meetingIdList)
+	for _, meetingStatusData := range meetingStatusToJsonData {
+		for _, meetingData := range meetingDatas {
+			if meetingStatusData.MeetingId == meetingData.MeetingId {
+				if meetingData.IsRepeat {
+					meetingStatusData.MeetingName = "「繰り返し」 " + meetingData.MeetingName
+				} else {
+					meetingStatusData.MeetingName = meetingData.MeetingName
+				}
+			}
+		}
+	}
+
+	if len(meetingIdList)-len(meetingDatas) >= 2 {
+		var number int = 1
+		for _, meetingStatusData := range meetingStatusToJsonData {
+			if meetingStatusData.MeetingName == "進行中の会議" {
+				meetingStatusData.MeetingName = "進行中の会議" + strconv.Itoa(number)
+				number = number + 1
+			}
+		}
+	}
+
+	//会議オーナーを追加する
+	userDatas, _ := a.Srv().Store().MeetingStatus().GetUsersName(userEmailList)
+	for _, meetingStatusData := range meetingStatusToJsonData {
+		for _, userData := range userDatas {
+			if meetingStatusData.Creater == userData.Email {
+				if userData.LastName+userData.FirstName == "" {
+					meetingStatusData.Creater = userData.UserName
+				} else {
+					meetingStatusData.Creater = userData.UserName + "(" + userData.LastName + userData.FirstName + ")"
+				}
+			}
+		}
+
+	}
+	return meetingStatusToJsonData, nil, true
+}
+
+// Web会議履歴一覧を取得
+func (a *App) GetMeetingEnd(meeting *model.MeetingEndFromJson) ([]*model.MeetingEndToJson, *model.AppError, bool) {
+	var meetingEndToJsonData []*model.MeetingEndToJson
+	var meetingIdList []string
+	var userEmailList []string
+
+	timeLayout := "2006-01-02 15:04:05"
+
+	//会議名を追加する
+	meetingsEndData, _ := a.Srv().Store().MeetingStatus().GetMeetingEndData(meeting)
+
+	if len(meetingsEndData) == 0 {
+		return meetingEndToJsonData, nil, true
+	}
+
+	for _, meetingsEnd := range meetingsEndData {
+		var item model.MeetingEndToJson
+		meetingIdList = append(meetingIdList, meetingsEnd.MeetingItemId)
+		userEmailList = append(userEmailList, meetingsEnd.UserMail)
+		item.MeetingId = meetingsEnd.MeetingItemId
+		item.Creater = meetingsEnd.UserMail
+		item.MeetUserCount = meetingsEnd.SumMemberCount
+		item.MeetingName = "終わりの会議"
+		item.StartTime = time.Unix(meetingsEnd.MeetingStartTime/1000, 1).Format(timeLayout)
+		item.EndTime = time.Unix(meetingsEnd.MeetingEndTime/1000, 1).Format(timeLayout)
+		meetingEndToJsonData = append(meetingEndToJsonData, &item)
+	}
+
+	//会議名を追加する
+	meetingDatas, _ := a.Srv().Store().MeetingStatus().GetMeetingNames(meetingIdList)
+	for _, meetingEndData := range meetingEndToJsonData {
+		for _, meetingData := range meetingDatas {
+			if meetingEndData.MeetingId == meetingData.MeetingId {
+				if meetingData.IsRepeat {
+					meetingEndData.MeetingName = "「繰り返し」 " + meetingData.MeetingName
+				} else {
+					meetingEndData.MeetingName = meetingData.MeetingName
+				}
+			}
+		}
+	}
+
+	if len(meetingIdList)-len(meetingDatas) >= 2 {
+		var number int = 1
+		for _, meetingEndData := range meetingEndToJsonData {
+			if meetingEndData.MeetingName == "終わりの会議" {
+				meetingEndData.MeetingName = "終わりの会議" + strconv.Itoa(number)
+				number = number + 1
+			}
+		}
+	}
+
+	//会議オーナーを追加する
+	userDatas, _ := a.Srv().Store().MeetingStatus().GetUsersName(userEmailList)
+	for _, meetingEndData := range meetingEndToJsonData {
+		for _, userData := range userDatas {
+			if meetingEndData.Creater == userData.Email {
+				if userData.LastName+userData.FirstName == "" {
+					meetingEndData.Creater = userData.UserName
+				} else {
+					meetingEndData.Creater = userData.UserName + "(" + userData.LastName + userData.FirstName + ")"
+				}
+			}
+		}
+
+	}
+	return meetingEndToJsonData, nil, true
+}
+
+/* Ryobi Systems CloudOffice MeetingStatus Mod 20220214 START */
+func (a *App) getRedisIp() (string, string, string, *model.AppError) {
+	// システムから設定を取得
+	var redisIp string
+	redisIp = os.Getenv("REDIS_CONNECTION_HOST")
+	var redisPass string
+	redisPass = os.Getenv("REDIS_CONNECTION_PW")
+	var redisPort string
+	redisPort = os.Getenv("REDIS_CONNECTION_PORT")
+
+	return redisIp, redisPass, redisPort, nil
+	/* Ryobi Systems CloudOffice MeetingStatus Mod 20220214 END */
+}
Index: mattermost-server-7.8.1/app/notification_email.go
===================================================================
--- mattermost-server-7.8.1/app/notification_email.go	(revision 4484)
+++ mattermost-server-7.8.1/app/notification_email.go	(revision 4485)
@@ -11,7 +11,7 @@
 	"io"
 	"strings"
 	"time"
-
+	"unicode"
 	email "github.com/mattermost/mattermost-server/v6/app/email"
 	"github.com/mattermost/mattermost-server/v6/app/request"
 	"github.com/mattermost/mattermost-server/v6/model"
@@ -107,7 +107,9 @@
 		}
 	}
 
-	landingURL := a.GetSiteURL() + "/landing#/" + team.Name
+	/* Ryobi Systems CloudOffice Meeting Mod ランディングURLを修正 20210517 START */
+	landingURL := a.GetSiteURL() + "/" + team.Name
+	/* Ryobi Systems CloudOffice Meeting Mod ランディングURLを修正 20210517 END */
 
 	var bodyText, err = a.getNotificationEmailBody(c, user, post, channel, channelName, senderName, team.Name, landingURL, emailNotificationContentsType, useMilitaryTime, translateFunc, senderPhoto)
 	if err != nil {
@@ -233,6 +235,9 @@
 
 	if emailNotificationContentsType == model.EmailNotificationContentsFull {
 		postMessage := a.GetMessageForNotification(post, translateFunc)
+		/* Ryobi Systems CloudOffice Meeting Mod メール本文にIDを姓名に変更 20210609 START */
+		postMessage = a.changeUserNameToFullNameWithPrefixAt(postMessage)
+		/* Ryobi Systems CloudOffice Meeting Mod メール本文にIDを姓名に変更 20210609 END */
 		postMessage = html.EscapeString(postMessage)
 		mdPostMessage, mdErr := utils.MarkdownToHTML(postMessage, a.GetSiteURL())
 		if mdErr != nil {
@@ -382,3 +387,32 @@
 func (a *App) GetMessageForNotification(post *model.Post, translateFunc i18n.TranslateFunc) string {
 	return a.Srv().EmailService.GetMessageForNotification(post, translateFunc)
 }
+
+/* Ryobi Systems CloudOffice Meeting Mod メール本文にIDを姓名に変更 20210609 START */
+//メール通知本文の@UserNameを@FullNameに修正
+func (a *App) changeUserNameToFullNameWithPrefixAt(text string) string {
+	message := text
+	for _, word := range strings.FieldsFunc(text, func(c rune) bool {
+		// Split on any whitespace or punctuation that can't be part of an at mention or emoji pattern
+		return !(c == ':' || c == '.' || c == '-' || c == '_' || c == '@' || unicode.IsLetter(c) || unicode.IsNumber(c))
+	}) {
+		// skip word with format ':word:' with an assumption that it is an emoji format only
+		if word[0] == ':' && word[len(word)-1] == ':' {
+			continue
+		}
+
+		word = strings.TrimLeft(word, ":.-_")
+
+		if strings.HasPrefix(word, "@") {
+			user, err := a.GetUserByUsername(word[1:])
+			if err == nil {
+				replaceWord := "@" + user.GetFullName()
+				message = strings.Replace(message, word, replaceWord, -1)
+			}
+		}
+	}
+
+	return message
+}
+
+/* Ryobi Systems CloudOffice Meeting Mod メール本文にIDを姓名に変更 20210609 END */
Index: mattermost-server-7.8.1/app/oauth.go
===================================================================
--- mattermost-server-7.8.1/app/oauth.go	(revision 4484)
+++ mattermost-server-7.8.1/app/oauth.go	(revision 4485)
@@ -810,7 +810,10 @@
 
 	cookie, cookieErr := r.Cookie(CookieOAuth)
 	if cookieErr != nil {
-		return nil, "", stateProps, nil, model.NewAppError("AuthorizeOAuthUser", "api.user.authorize_oauth_user.invalid_state.app_error", nil, "", http.StatusBadRequest)
+		// 20210604 Ryobi Systems/--
+		// エラー詳細にoauth_cookie_expiredが含まれる場合は呼び出し元で復旧処理を行う
+		return nil, "", stateProps, nil, model.NewAppError("AuthorizeOAuthUser", "api.user.authorize_oauth_user.invalid_state.app_error", nil, "oauth_cookie_expired", http.StatusBadRequest)
+		// --/20210604 Ryobi Systems
 	}
 
 	expectedTokenExtra := generateOAuthStateTokenExtra(stateEmail, stateAction, cookie.Value)
Index: mattermost-server-7.8.1/app/opentracing/opentracing_layer.go
===================================================================
--- mattermost-server-7.8.1/app/opentracing/opentracing_layer.go	(revision 4484)
+++ mattermost-server-7.8.1/app/opentracing/opentracing_layer.go	(revision 4485)
@@ -4588,6 +4588,398 @@
 	return resultVar0, resultVar1
 }
 
+/* Ryobi Systems CloudOffice Meeting Mod 20210325 START */
+func (a *OpenTracingAppLayer) GetMeetingsByUserId(userId string, meetingAfter string, meetingBefore string) ([]*model.RepeatMeetingToJson, *model.AppError) {
+	origCtx := a.ctx
+	span, newCtx := tracing.StartSpanWithParentByContext(a.ctx, "app.GetMeetingsByUserId")
+
+	a.ctx = newCtx
+	a.app.Srv().Store().SetContext(newCtx)
+	defer func() {
+		a.app.Srv().Store().SetContext(origCtx)
+		a.ctx = origCtx
+	}()
+
+	defer span.Finish()
+	resultVar0, resultVar1 := a.app.GetMeetingsByUserId(userId, meetingAfter, meetingBefore)
+
+	if resultVar1 != nil {
+		span.LogFields(spanlog.Error(resultVar1))
+		ext.Error.Set(span, true)
+	}
+
+	return resultVar0, resultVar1
+}
+
+func (a *OpenTracingAppLayer) GetDeletedMeetingInfoByMeetingItemIds(meetingItemIds []string) ([]*model.DeleteParamsToJson, *model.AppError) {
+	origCtx := a.ctx
+	span, newCtx := tracing.StartSpanWithParentByContext(a.ctx, "app.GetDeletedMeetingInfoByMeetingItemIds")
+
+	a.ctx = newCtx
+	a.app.Srv().Store().SetContext(newCtx)
+	defer func() {
+		a.app.Srv().Store().SetContext(origCtx)
+		a.ctx = origCtx
+	}()
+
+	defer span.Finish()
+	resultVar0, resultVar1 := a.app.GetDeletedMeetingInfoByMeetingItemIds(meetingItemIds)
+
+	if resultVar1 != nil {
+		span.LogFields(spanlog.Error(resultVar1))
+		ext.Error.Set(span, true)
+	}
+
+	return resultVar0, resultVar1
+}
+
+func (a *OpenTracingAppLayer) GetMeeting(meetingItemId string) (*model.RepeatMeetingToJson, *model.AppError) {
+	origCtx := a.ctx
+	span, newCtx := tracing.StartSpanWithParentByContext(a.ctx, "app.GetMeeting")
+
+	a.ctx = newCtx
+	a.app.Srv().Store().SetContext(newCtx)
+	defer func() {
+		a.app.Srv().Store().SetContext(origCtx)
+		a.ctx = origCtx
+	}()
+
+	defer span.Finish()
+	resultVar0, resultVar1 := a.app.GetMeeting(meetingItemId)
+
+	if resultVar1 != nil {
+		span.LogFields(spanlog.Error(resultVar1))
+		ext.Error.Set(span, true)
+	}
+
+	return resultVar0, resultVar1
+}
+
+func (a *OpenTracingAppLayer) GetMeetingUsersByMeetingItemIds(meetingItemIds []string) ([]*model.MeetingUser, *model.AppError) {
+	origCtx := a.ctx
+	span, newCtx := tracing.StartSpanWithParentByContext(a.ctx, "app.GetMeetingUsersByMeetingItemIds")
+
+	a.ctx = newCtx
+	a.app.Srv().Store().SetContext(newCtx)
+	defer func() {
+		a.app.Srv().Store().SetContext(origCtx)
+		a.ctx = origCtx
+	}()
+
+	defer span.Finish()
+	resultVar0, resultVar1 := a.app.GetMeetingUsersByMeetingItemIds(meetingItemIds)
+
+	if resultVar1 != nil {
+		span.LogFields(spanlog.Error(resultVar1))
+		ext.Error.Set(span, true)
+	}
+
+	return resultVar0, resultVar1
+}
+
+func (a *OpenTracingAppLayer) DeleteMeeting(meetingItemId string, delParams *model.DeleteParamsFromJson) (*model.MeetingMailInfo, *model.AppError) {
+	origCtx := a.ctx
+	span, newCtx := tracing.StartSpanWithParentByContext(a.ctx, "app.DeleteMeeting")
+
+	a.ctx = newCtx
+	a.app.Srv().Store().SetContext(newCtx)
+	defer func() {
+		a.app.Srv().Store().SetContext(origCtx)
+		a.ctx = origCtx
+	}()
+
+	defer span.Finish()
+	resultVar0, resultVar1 := a.app.DeleteMeeting(meetingItemId, delParams)
+
+	if resultVar1 != nil {
+		span.LogFields(spanlog.Error(resultVar1))
+		ext.Error.Set(span, true)
+	}
+
+	return resultVar0, resultVar1
+}
+
+func (a *OpenTracingAppLayer) CreateMeeting(meeting *model.Meeting, usersfromjson []*model.MeetingUserFromJson) (*model.MeetingMailInfo, []*model.MeetingUser, *model.AppError) {
+	origCtx := a.ctx
+	span, newCtx := tracing.StartSpanWithParentByContext(a.ctx, "app.CreateMeeting")
+
+	a.ctx = newCtx
+	a.app.Srv().Store().SetContext(newCtx)
+	defer func() {
+		a.app.Srv().Store().SetContext(origCtx)
+		a.ctx = origCtx
+	}()
+
+	defer span.Finish()
+	resultVar0, resultVar1, resultVar2 := a.app.CreateMeeting(meeting, usersfromjson)
+
+	if resultVar2 != nil {
+		span.LogFields(spanlog.Error(resultVar2))
+		ext.Error.Set(span, true)
+	}
+
+	return resultVar0, resultVar1, resultVar2
+}
+
+func (a *OpenTracingAppLayer) UpdateMeeting(meeting *model.Meeting, usersfromjson []*model.MeetingUserFromJson, isAddMeeting bool) (*model.MeetingMailInfo, string, *model.AppError) {
+	origCtx := a.ctx
+	span, newCtx := tracing.StartSpanWithParentByContext(a.ctx, "app.UpdateMeeting")
+
+	a.ctx = newCtx
+	a.app.Srv().Store().SetContext(newCtx)
+	defer func() {
+		a.app.Srv().Store().SetContext(origCtx)
+		a.ctx = origCtx
+	}()
+
+	defer span.Finish()
+	resultVar0, resultVar1, resultVar2 := a.app.UpdateMeeting(meeting, usersfromjson, isAddMeeting)
+
+	if resultVar2 != nil {
+		span.LogFields(spanlog.Error(resultVar2))
+		ext.Error.Set(span, true)
+	}
+
+	return resultVar0, resultVar1, resultVar2
+}
+
+func (a *OpenTracingAppLayer) UpdateValidMeetingUsers(meetingItemId string, mailAddrs []string, itemValid int) *model.AppError {
+	origCtx := a.ctx
+	span, newCtx := tracing.StartSpanWithParentByContext(a.ctx, "app.UpdateValidMeetingUsers")
+
+	a.ctx = newCtx
+	a.app.Srv().Store().SetContext(newCtx)
+	defer func() {
+		a.app.Srv().Store().SetContext(origCtx)
+		a.ctx = origCtx
+	}()
+
+	defer span.Finish()
+	resultVar0 := a.app.UpdateValidMeetingUsers(meetingItemId, mailAddrs, itemValid)
+
+	if resultVar0 != nil {
+		span.LogFields(spanlog.Error(resultVar0))
+		ext.Error.Set(span, true)
+	}
+
+	return resultVar0
+}
+
+func (a *OpenTracingAppLayer) GetMeetingDtstamp(timeStamp int64) string {
+	origCtx := a.ctx
+	span, newCtx := tracing.StartSpanWithParentByContext(a.ctx, "app.GetMeetingDtstamp")
+
+	a.ctx = newCtx
+	a.app.Srv().Store().SetContext(newCtx)
+	defer func() {
+		a.app.Srv().Store().SetContext(origCtx)
+		a.ctx = origCtx
+	}()
+
+	defer span.Finish()
+	resultVar0 := a.app.GetMeetingDtstamp(timeStamp)
+
+	return resultVar0
+}
+
+/* Ryobi Systems CloudOffice Meeting Mod 20210325 END */
+/* Ryobi Systems CloudOffice MeetingMng Mod 20210617 START */
+
+func (a *OpenTracingAppLayer) GetMeetingMng(c *request.Context, meeting *model.MeetingMngFromJson) ([]*model.MeetingMngToJson, *model.AppError) {
+	origCtx := a.ctx
+	span, newCtx := tracing.StartSpanWithParentByContext(a.ctx, "app.GetMeetingMng")
+
+	a.ctx = newCtx
+	a.app.Srv().Store().SetContext(newCtx)
+	defer func() {
+		a.app.Srv().Store().SetContext(origCtx)
+		a.ctx = origCtx
+	}()
+
+	defer span.Finish()
+	resultVar0, resultVar1 := a.app.GetMeetingMng(c, meeting)
+
+	if resultVar1 != nil {
+		span.LogFields(spanlog.Error(resultVar1))
+		ext.Error.Set(span, true)
+	}
+
+	return resultVar0, resultVar1
+}
+func (a *OpenTracingAppLayer) GetMeetingMngDetail(c *request.Context, MeetingItemId string) (*model.MeetingMngDetailToJson, *model.AppError) {
+	origCtx := a.ctx
+	span, newCtx := tracing.StartSpanWithParentByContext(a.ctx, "app.GetMeetingMngByUserId")
+
+	a.ctx = newCtx
+	a.app.Srv().Store().SetContext(newCtx)
+	defer func() {
+		a.app.Srv().Store().SetContext(origCtx)
+		a.ctx = origCtx
+	}()
+
+	defer span.Finish()
+	resultVar0, resultVar1 := a.app.GetMeetingMngDetail(c, MeetingItemId)
+
+	if resultVar1 != nil {
+		span.LogFields(spanlog.Error(resultVar1))
+		ext.Error.Set(span, true)
+	}
+
+	return resultVar0, resultVar1
+}
+
+/* Ryobi Systems CloudOffice MeetingMng Mod 20210617 END */
+/* Ryobi Systems CloudOffice MeetingMng Mod 20210913 START */
+
+func (a *OpenTracingAppLayer) MeetingMngDelete(meetingItemId string) (*model.MeetingMailInfo, *model.AppError) {
+	origCtx := a.ctx
+	span, newCtx := tracing.StartSpanWithParentByContext(a.ctx, "app.MeetingMngDelete")
+
+	a.ctx = newCtx
+	a.app.Srv().Store().SetContext(newCtx)
+	defer func() {
+		a.app.Srv().Store().SetContext(origCtx)
+		a.ctx = origCtx
+	}()
+
+	defer span.Finish()
+	resultVar0, resultVar1 := a.app.MeetingMngDelete(meetingItemId)
+
+	if resultVar1 != nil {
+		span.LogFields(spanlog.Error(resultVar1))
+		ext.Error.Set(span, true)
+	}
+
+	return resultVar0, resultVar1
+}
+func (a *OpenTracingAppLayer) GetMeetingMngUsersByMeetingItemIdFormail(meetingItemId string) ([]*model.MeetingMngUser, *model.AppError) {
+	origCtx := a.ctx
+	span, newCtx := tracing.StartSpanWithParentByContext(a.ctx, "app.GetMeetingMngByUserId")
+
+	a.ctx = newCtx
+	a.app.Srv().Store().SetContext(newCtx)
+	defer func() {
+		a.app.Srv().Store().SetContext(origCtx)
+		a.ctx = origCtx
+	}()
+
+	defer span.Finish()
+	resultVar0, resultVar1 := a.app.GetMeetingMngUsersByMeetingItemIdFormail(meetingItemId)
+
+	if resultVar1 != nil {
+		span.LogFields(spanlog.Error(resultVar1))
+		ext.Error.Set(span, true)
+	}
+
+	return resultVar0, resultVar1
+}
+
+/* Ryobi Systems CloudOffice MeetingMng Mod 20210913 END */
+
+/* Ryobi Systems CloudOffice MeetingStatus Mod 20210913 START */
+func (a *OpenTracingAppLayer) GetMeetingStatus() ([]*model.MeetingStatusToJson, *model.AppError, bool) {
+	origCtx := a.ctx
+	span, newCtx := tracing.StartSpanWithParentByContext(a.ctx, "app.GetMeetingStatus")
+
+	a.ctx = newCtx
+	a.app.Srv().Store().SetContext(newCtx)
+	defer func() {
+		a.app.Srv().Store().SetContext(origCtx)
+		a.ctx = origCtx
+	}()
+
+	defer span.Finish()
+	resultVar0, resultVar1, resultVar2 := a.app.GetMeetingStatus()
+
+	if resultVar1 != nil {
+		span.LogFields(spanlog.Error(resultVar1))
+		ext.Error.Set(span, true)
+	}
+
+	return resultVar0, resultVar1, resultVar2
+}
+
+func (a *OpenTracingAppLayer) GetMeetingEnd(meeting *model.MeetingEndFromJson) ([]*model.MeetingEndToJson, *model.AppError, bool) {
+	origCtx := a.ctx
+	span, newCtx := tracing.StartSpanWithParentByContext(a.ctx, "app.GetMeetingEnd")
+
+	a.ctx = newCtx
+	a.app.Srv().Store().SetContext(newCtx)
+	defer func() {
+		a.app.Srv().Store().SetContext(origCtx)
+		a.ctx = origCtx
+	}()
+
+	defer span.Finish()
+	resultVar0, resultVar1, resultVar2 := a.app.GetMeetingEnd(meeting)
+
+	if resultVar1 != nil {
+		span.LogFields(spanlog.Error(resultVar1))
+		ext.Error.Set(span, true)
+	}
+
+	return resultVar0, resultVar1, resultVar2
+}
+
+/* Ryobi Systems CloudOffice MeetingStatus Mod 20210913 END */
+
+/* Ryobi Systems CloudOffice CronChat Mod 20211129 START */
+func (a *OpenTracingAppLayer) CronDeleteChat(c *request.Context, cronTime int) *model.AppError {
+	origCtx := a.ctx
+	span, newCtx := tracing.StartSpanWithParentByContext(a.ctx, "app.CronDeleteChat")
+
+	a.ctx = newCtx
+	a.app.Srv().Store().SetContext(newCtx)
+	defer func() {
+		a.app.Srv().Store().SetContext(origCtx)
+		a.ctx = origCtx
+	}()
+
+	defer span.Finish()
+	resultVar0 := a.app.CronDeleteChat(c, cronTime)
+
+	return resultVar0
+}
+func (a *OpenTracingAppLayer) GetChannelChatSettings(channelId string) (*model.ChannelSettingsToJson, *model.AppError) {
+	origCtx := a.ctx
+	span, newCtx := tracing.StartSpanWithParentByContext(a.ctx, "app.GetMeetingMngByUserId")
+
+	a.ctx = newCtx
+	a.app.Srv().Store().SetContext(newCtx)
+	defer func() {
+		a.app.Srv().Store().SetContext(origCtx)
+		a.ctx = origCtx
+	}()
+
+	defer span.Finish()
+	resultVar0, resultVar1 := a.app.GetChannelChatSettings(channelId)
+
+	if resultVar1 != nil {
+		span.LogFields(spanlog.Error(resultVar1))
+		ext.Error.Set(span, true)
+	}
+
+	return resultVar0, resultVar1
+}
+func (a *OpenTracingAppLayer) SetChannelChatSettings(c *request.Context, channelSetting *model.ChannelChatSaveSettingsFromJson) *model.AppError {
+	origCtx := a.ctx
+	span, newCtx := tracing.StartSpanWithParentByContext(a.ctx, "app.CronDeleteChat")
+
+	a.ctx = newCtx
+	a.app.Srv().Store().SetContext(newCtx)
+	defer func() {
+		a.app.Srv().Store().SetContext(origCtx)
+		a.ctx = origCtx
+	}()
+
+	defer span.Finish()
+	resultVar0 := a.app.SetChannelChatSettings(c, channelSetting)
+
+	return resultVar0
+}
+
+/* Ryobi Systems CloudOffice CronChat Mod 20211129 END */
+
 func (a *OpenTracingAppLayer) GetAllLdapGroupsPage(page int, perPage int, opts model.LdapGroupSearchOpts) ([]*model.Group, int, *model.AppError) {
 	origCtx := a.ctx
 	span, newCtx := tracing.StartSpanWithParentByContext(a.ctx, "app.GetAllLdapGroupsPage")
@@ -10636,6 +11028,28 @@
 	return resultVar0, resultVar1
 }
 
+func (a *OpenTracingAppLayer) GetUserWebMeetingStatus(userId string) (*model.Status, error) {
+	origCtx := a.ctx
+	span, newCtx := tracing.StartSpanWithParentByContext(a.ctx, "app.getUserWebMeetingStatus")
+
+	a.ctx = newCtx
+	a.app.Srv().Store().SetContext(newCtx)
+	defer func() {
+		a.app.Srv().Store().SetContext(origCtx)
+		a.ctx = origCtx
+	}()
+
+	defer span.Finish()
+	resultVar0, resultVar1 := a.app.GetUserWebMeetingStatus(userId)
+
+	if resultVar1 != nil {
+		span.LogFields(spanlog.Error(resultVar1))
+		ext.Error.Set(span, true)
+	}
+
+	return resultVar0, nil
+}
+
 func (a *OpenTracingAppLayer) GetUsers(userIDs []string) ([]*model.User, *model.AppError) {
 	origCtx := a.ctx
 	span, newCtx := tracing.StartSpanWithParentByContext(a.ctx, "app.GetUsers")
@@ -10907,7 +11321,7 @@
 	}()
 
 	defer span.Finish()
-	resultVar0, resultVar1 := a.app.GetUsersInChannelPageByStatus(options, asAdmin)
+	resultVar0, resultVar1 := a.app.GetUsersInChannelPageByAdmin(options, asAdmin)
 
 	if resultVar1 != nil {
 		span.LogFields(spanlog.Error(resultVar1))
@@ -11303,6 +11717,72 @@
 	return resultVar0, resultVar1
 }
 
+/* Ryobi Systems CloudOffice Files Mod 20211103 START */
+func (a *OpenTracingAppLayer) GetFilePermission(userIp string) (*model.FilePermission, *model.AppError) {
+	origCtx := a.ctx
+	span, newCtx := tracing.StartSpanWithParentByContext(a.ctx, "app.GetFilePermission")
+
+	a.ctx = newCtx
+	a.app.Srv().Store().SetContext(newCtx)
+	defer func() {
+		a.app.Srv().Store().SetContext(origCtx)
+		a.ctx = origCtx
+	}()
+
+	defer span.Finish()
+	resultVar0, resultVar1 := a.app.GetFilePermission(userIp)
+
+	if resultVar1 != nil {
+		span.LogFields(spanlog.Error(resultVar1))
+		ext.Error.Set(span, true)
+	}
+
+	return resultVar0, resultVar1
+}
+func (a *OpenTracingAppLayer) GetFileTotalSize() (float64, *model.AppError) {
+	origCtx := a.ctx
+	span, newCtx := tracing.StartSpanWithParentByContext(a.ctx, "app.GetFileTotalSize")
+
+	a.ctx = newCtx
+	a.app.Srv().Store().SetContext(newCtx)
+	defer func() {
+		a.app.Srv().Store().SetContext(origCtx)
+		a.ctx = origCtx
+	}()
+
+	defer span.Finish()
+	resultVar0, resultVar1 := a.app.GetFileTotalSize()
+
+	if resultVar1 != nil {
+		span.LogFields(spanlog.Error(resultVar1))
+		ext.Error.Set(span, true)
+	}
+
+	return resultVar0, resultVar1
+}
+func (a *OpenTracingAppLayer) SetFileTotalSize() *model.AppError {
+	origCtx := a.ctx
+	span, newCtx := tracing.StartSpanWithParentByContext(a.ctx, "app.SetFileTotalSize")
+
+	a.ctx = newCtx
+	a.app.Srv().Store().SetContext(newCtx)
+	defer func() {
+		a.app.Srv().Store().SetContext(origCtx)
+		a.ctx = origCtx
+	}()
+
+	defer span.Finish()
+	resultVar1 := a.app.SetFileTotalSize()
+
+	if resultVar1 != nil {
+		span.LogFields(spanlog.Error(resultVar1))
+		ext.Error.Set(span, true)
+	}
+
+	return resultVar1
+}
+
+/* Ryobi Systems CloudOffice Files Mod 20211103 END */
 func (a *OpenTracingAppLayer) GetWorkTemplateCategories(t i18n.TranslateFunc) ([]*model.WorkTemplateCategory, *model.AppError) {
 	origCtx := a.ctx
 	span, newCtx := tracing.StartSpanWithParentByContext(a.ctx, "app.GetWorkTemplateCategories")
@@ -12790,6 +13270,41 @@
 	return resultVar0
 }
 
+/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 START */
+func (a *OpenTracingAppLayer) SaveDefaultTeamforName(Name string) {
+	origCtx := a.ctx
+	span, newCtx := tracing.StartSpanWithParentByContext(a.ctx, "app.SaveDefaultTeamforName")
+
+	a.ctx = newCtx
+	a.app.Srv().Store().SetContext(newCtx)
+	defer func() {
+		a.app.Srv().Store().SetContext(origCtx)
+		a.ctx = origCtx
+	}()
+
+	defer span.Finish()
+	a.app.SaveDefaultTeamforName(Name)
+}
+
+/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 END */
+/* Ryobi Systems DefaultTeamaSetUp Mod 20221025 START */
+func (a *OpenTracingAppLayer) DeleteDefaultTeam() {
+	origCtx := a.ctx
+	span, newCtx := tracing.StartSpanWithParentByContext(a.ctx, "app.DeleteDefaultTeam")
+
+	a.ctx = newCtx
+	a.app.Srv().Store().SetContext(newCtx)
+	defer func() {
+		a.app.Srv().Store().SetContext(origCtx)
+		a.ctx = origCtx
+	}()
+
+	defer span.Finish()
+	a.app.DeleteDefaultTeam()
+}
+
+/* Ryobi Systems DefaultTeamaSetUp Mod 20221025 END */
+
 func (a *OpenTracingAppLayer) OriginChecker() func(*http.Request) bool {
 	origCtx := a.ctx
 	span, newCtx := tracing.StartSpanWithParentByContext(a.ctx, "app.OriginChecker")
@@ -14049,6 +14564,28 @@
 	return resultVar0
 }
 
+/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 START */
+func (a *OpenTracingAppLayer) GetDefaultTeama(teamId string) int {
+
+	origCtx := a.ctx
+	span, newCtx := tracing.StartSpanWithParentByContext(a.ctx, "app.GetDefaultTeama")
+
+	a.ctx = newCtx
+	a.app.Srv().Store().SetContext(newCtx)
+	defer func() {
+		a.app.Srv().Store().SetContext(origCtx)
+		a.ctx = origCtx
+	}()
+
+	defer span.Finish()
+	resultVar0 := a.app.GetDefaultTeama(teamId)
+
+	return resultVar0
+
+}
+
+/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 END */
+
 func (a *OpenTracingAppLayer) RemoveUserFromTeam(c request.CTX, teamID string, userID string, requestorId string) *model.AppError {
 	origCtx := a.ctx
 	span, newCtx := tracing.StartSpanWithParentByContext(a.ctx, "app.RemoveUserFromTeam")
@@ -16286,6 +16823,21 @@
 	a.app.SetStatusAwayIfNeeded(userID, manual)
 }
 
+func (a *OpenTracingAppLayer) SetStatusMeetingIfNeeded(userId string, manual bool) {
+	origCtx := a.ctx
+	span, newCtx := tracing.StartSpanWithParentByContext(a.ctx, "app.SetStatusMeetingIfNeeded")
+
+	a.ctx = newCtx
+	a.app.Srv().Store().SetContext(newCtx)
+	defer func() {
+		a.app.Srv().Store().SetContext(origCtx)
+		a.ctx = origCtx
+	}()
+
+	defer span.Finish()
+	a.app.SetStatusMeetingIfNeeded(userId, manual)
+}
+
 func (a *OpenTracingAppLayer) SetStatusDoNotDisturb(userID string) {
 	origCtx := a.ctx
 	span, newCtx := tracing.StartSpanWithParentByContext(a.ctx, "app.SetStatusDoNotDisturb")
@@ -18138,6 +18690,27 @@
 	return resultVar0, resultVar1
 }
 
+func (a *OpenTracingAppLayer) UpdateUserNotifyProps(userID string, props map[string]string, sendNotifications bool) (*model.User, *model.AppError) {
+	origCtx := a.ctx
+	span, newCtx := tracing.StartSpanWithParentByContext(a.ctx, "app.UpdateUserNotifyProps")
+
+	a.ctx = newCtx
+	a.app.Srv().Store().SetContext(newCtx)
+	defer func() {
+		a.app.Srv().Store().SetContext(origCtx)
+		a.ctx = origCtx
+	}()
+
+	defer span.Finish()
+	resultVar0, resultVar1 := a.app.UpdateUserNotifyProps(userID, props, sendNotifications)
+
+	if resultVar1 != nil {
+		span.LogFields(spanlog.Error(resultVar1))
+		ext.Error.Set(span, true)
+	}
+
+	return resultVar0, resultVar1
+}
 func (a *OpenTracingAppLayer) UpdateUserRoles(c request.CTX, userID string, newRoles string, sendWebSocketEvent bool) (*model.User, *model.AppError) {
 	origCtx := a.ctx
 	span, newCtx := tracing.StartSpanWithParentByContext(a.ctx, "app.UpdateUserRoles")
Index: mattermost-server-7.8.1/app/platform/session.go
===================================================================
--- mattermost-server-7.8.1/app/platform/session.go	(revision 4484)
+++ mattermost-server-7.8.1/app/platform/session.go	(revision 4485)
@@ -260,3 +260,22 @@
 
 	return nil
 }
+
+/*
+Delete user session by userID sessionState
+*/
+func (ps *PlatformService) RevokeSessionsBySid(userID string, sessionState string) error {
+	sessions, err := ps.Store.Session().GetSessions(userID)
+	if err != nil {
+		return fmt.Errorf("%s: %w", err.Error(), GetSessionError)
+	}
+	for _, session := range sessions {
+		if sessionState == session.Props[model.SESSION_USER_STATE] {
+			if err := ps.Store.Session().Remove(session.Id); err != nil {
+				return fmt.Errorf("%s: %w", err.Error(), DeleteSessionError)
+			}
+		}
+	}
+	ps.ClearUserSessionCache(userID)
+	return nil
+}
Index: mattermost-server-7.8.1/app/platform/status.go
===================================================================
--- mattermost-server-7.8.1/app/platform/status.go	(revision 4484)
+++ mattermost-server-7.8.1/app/platform/status.go	(revision 4485)
@@ -165,6 +165,11 @@
 	event := model.NewWebSocketEvent(model.WebsocketEventStatusChange, "", "", status.UserId, nil, "")
 	event.Add("status", status.Status)
 	event.Add("user_id", status.UserId)
+	event.Add("manual", status.Manual)
+	event.Add("last_activity_at", status.LastActivityAt)
+	event.Add("active_channel", status.ActiveChannel)
+	event.Add("DND_end_time", status.DNDEndTime)
+	event.Add("prev_status", status.PrevStatus)
 	ps.Publish(event)
 }
 
@@ -332,7 +337,7 @@
 	}
 
 	if !manual {
-		if status.Status == model.StatusAway {
+		if status.Status == model.StatusAway || status.Status==model.STATUS_MEETING{
 			return
 		}
 
Index: mattermost-server-7.8.1/app/plugin_api.go
===================================================================
--- mattermost-server-7.8.1/app/plugin_api.go	(revision 4484)
+++ mattermost-server-7.8.1/app/plugin_api.go	(revision 4485)
@@ -324,6 +324,18 @@
 	return api.app.UpdateUserActive(api.ctx, userID, active)
 }
 
+/* Ryobi Systems MM_NC_連動SSOログアウト Mod 20201130 START */
+func (api *PluginAPI) RevokeAllSessionsById(userId string) *model.AppError {
+	return api.app.RevokeAllSessionsById(userId)
+}
+
+/* Ryobi Systems MM_NC_連動SSOログアウト Mod 20201130 END */
+/* Ryobi Systems MM_NC_連動SSOログアウト 20211224 START */
+func (api *PluginAPI) RevokeUserSessionById(userId string, sessionState string) *model.AppError {
+	return api.app.RevokeUserSessionById(userId, sessionState)
+}
+
+/* Ryobi Systems MM_NC_連動SSOログアウト 20211224 END */
 func (api *PluginAPI) GetUserStatus(userID string) (*model.Status, *model.AppError) {
 	return api.app.GetStatus(userID)
 }
@@ -342,6 +354,8 @@
 		api.app.SetStatusAwayIfNeeded(userID, true)
 	case model.StatusDnd:
 		api.app.SetStatusDoNotDisturb(userID)
+	case model.STATUS_MEETING:
+		api.app.SetStatusMeetingIfNeeded(userID, true)
 	default:
 		return nil, model.NewAppError("UpdateUserStatus", "plugin.api.update_user_status.bad_status", nil, "unrecognized status", http.StatusBadRequest)
 	}
@@ -683,6 +697,15 @@
 	}
 	return post, appErr
 }
+func (api *PluginAPI) GetPollFields(postID string) ([]*model.PollFields, *model.AppError) {
+	return api.app.GetPollFields(postID)
+}
+func (api *PluginAPI) PollFieldsInsert(field *model.PollFields) *model.AppError {
+	return api.app.PollFieldsInsert(field)
+}
+func (api *PluginAPI) DeletePollFields(userId string, postId string) *model.AppError {
+	return api.app.DeletePollFields(userId, postId)
+}
 
 func (api *PluginAPI) GetPostsSince(channelID string, time int64) (*model.PostList, *model.AppError) {
 	list, appErr := api.app.GetPostsSince(model.GetPostsSinceOptions{ChannelId: channelID, Time: time})
@@ -723,7 +746,12 @@
 	}
 	return post, appErr
 }
-
+func (api *PluginAPI) UpdatePostWithCachereRefresh(post *model.Post) (*model.Post, *model.AppError) {
+	return api.app.UpdatePostWithCachereRefresh(api.ctx, post, false)
+}
+func (api *PluginAPI) GetUsersInChannelPageByStatus(options *model.UserGetOptions, asAdmin bool) ([]*model.User, *model.AppError) {
+	return api.app.GetUsersInChannelPageByStatus(options, asAdmin)
+}
 func (api *PluginAPI) GetProfileImage(userID string) ([]byte, *model.AppError) {
 	user, err := api.app.GetUser(userID)
 	if err != nil {
@@ -1263,3 +1291,10 @@
 	}
 	return fi, nil
 }
+
+/* Ryobi Systems CloudOffice Files Mod 20211103 START */
+func (api *PluginAPI) GetFilesTotalSize() (float64, *model.AppError) {
+	totalSize, _ := api.app.GetFileTotalSize()
+	return totalSize, nil
+}
+/* Ryobi Systems CloudOffice Files Mod 20211103 END */
\ No newline at end of file
Index: mattermost-server-7.8.1/app/poll_field.go
===================================================================
--- mattermost-server-7.8.1/app/poll_field.go	(nonexistent)
+++ mattermost-server-7.8.1/app/poll_field.go	(revision 4485)
@@ -0,0 +1,52 @@
+package app
+
+import (
+	"errors"
+	"github.com/mattermost/mattermost-server/v6/model"
+	"github.com/mattermost/mattermost-server/v6/store"
+	"net/http"
+)
+
+func (a *App) GetPollFields(postID string) ([]*model.PollFields, *model.AppError) {
+	fields, err := a.Srv().Store().PollField().GetPollFields(postID)
+	if err != nil {
+		var nfErr *store.ErrNotFound
+		switch {
+		case errors.As(err, &nfErr):
+			return nil, model.NewAppError("GetSinglePost", "app.post.get.app_error", nil, nfErr.Error(), http.StatusNotFound)
+		default:
+			return nil, model.NewAppError("GetSinglePost", "app.post.get.app_error", nil, err.Error(), http.StatusInternalServerError)
+		}
+	}
+
+	return fields, nil
+}
+func (a *App) PollFieldsInsert(field *model.PollFields) *model.AppError {
+	err := a.Srv().Store().PollField().PollFieldsInsert(field)
+	if err != nil {
+		var nfErr *store.ErrNotFound
+		switch {
+		case errors.As(err, &nfErr):
+			return model.NewAppError("GetSinglePost", "app.post.get.app_error", nil, nfErr.Error(), http.StatusNotFound)
+		default:
+			return model.NewAppError("GetSinglePost", "app.post.get.app_error", nil, err.Error(), http.StatusInternalServerError)
+		}
+	}
+
+	return nil
+}
+
+func (a *App) DeletePollFields(userId string, postId string) *model.AppError {
+	err := a.Srv().Store().PollField().DeletePollFields(userId, postId)
+	if err != nil {
+		var nfErr *store.ErrNotFound
+		switch {
+		case errors.As(err, &nfErr):
+			return model.NewAppError("GetSinglePost", "app.post.get.app_error", nil, nfErr.Error(), http.StatusNotFound)
+		default:
+			return model.NewAppError("GetSinglePost", "app.post.get.app_error", nil, err.Error(), http.StatusInternalServerError)
+		}
+	}
+
+	return nil
+}
Index: mattermost-server-7.8.1/app/post.go
===================================================================
--- mattermost-server-7.8.1/app/post.go	(revision 4484)
+++ mattermost-server-7.8.1/app/post.go	(revision 4485)
@@ -779,7 +779,205 @@
 
 	return true, nil
 }
+func (a *App) UpdatePostWithCachereRefresh(c *request.Context, post *model.Post, safeUpdate bool) (*model.Post, *model.AppError) {
+	post.SanitizeProps()
 
+	postLists, nErr := a.Srv().Store().Post().Get(context.Background(), post.Id, model.GetPostsOptions{}, post.UserId, a.Config().GetSanitizeOptions())
+
+	if nErr != nil {
+		var nfErr *store.ErrNotFound
+		var invErr *store.ErrInvalidInput
+		switch {
+		case errors.As(nErr, &invErr):
+			return nil, model.NewAppError("UpdatePost", "app.post.get.app_error", nil, "", http.StatusBadRequest).Wrap(nErr)
+		case errors.As(nErr, &nfErr):
+			return nil, model.NewAppError("UpdatePost", "app.post.get.app_error", nil, "", http.StatusNotFound).Wrap(nErr)
+		default:
+			return nil, model.NewAppError("UpdatePost", "app.post.get.app_error", nil, "", http.StatusInternalServerError).Wrap(nErr)
+		}
+	}
+	oldPost := postLists.Posts[post.Id]
+	anonymous, _ := oldPost.GetProp("anonymous").(bool)
+	status, _ := post.GetProp("status").(string)
+	oldDBPost := oldPost
+	if len(oldPost.Attachments()) != 0 {
+		attachment := oldPost.Attachments()[0]
+		pollFields, _ := a.Srv().Store().PollField().GetPollFields(oldPost.Id)
+		if len(pollFields) != 0 {
+			model.ParseSlackAttachment(oldPost, getReplaceAttachment(attachment, pollFields, anonymous, status))
+		}
+	}
+	var err *model.AppError
+	if oldPost == nil {
+		err = model.NewAppError("UpdatePost", "api.post.update_post.find.app_error", nil, "id="+post.Id, http.StatusBadRequest)
+		return nil, err
+	}
+
+	if oldPost.DeleteAt != 0 {
+		err = model.NewAppError("UpdatePost", "api.post.update_post.permissions_details.app_error", map[string]any{"PostId": post.Id}, "", http.StatusBadRequest)
+		return nil, err
+	}
+
+	if oldPost.IsSystemMessage() {
+		err = model.NewAppError("UpdatePost", "api.post.update_post.system_message.app_error", nil, "id="+post.Id, http.StatusBadRequest)
+		return nil, err
+	}
+
+	if *a.Config().ServiceSettings.PostEditTimeLimit != -1 && model.GetMillis() > oldPost.CreateAt+int64(*a.Config().ServiceSettings.PostEditTimeLimit*1000) && post.Message != oldPost.Message {
+		err = model.NewAppError("UpdatePost", "api.post.update_post.permissions_time_limit.app_error", map[string]any{"timeLimit": *a.Config().ServiceSettings.PostEditTimeLimit}, "", http.StatusBadRequest)
+		return nil, err
+	}
+
+	channel, err := a.GetChannel(c, oldPost.ChannelId)
+	if err != nil {
+		return nil, err
+	}
+
+	if channel.DeleteAt != 0 {
+		return nil, model.NewAppError("UpdatePost", "api.post.update_post.can_not_update_post_in_deleted.error", nil, "", http.StatusBadRequest)
+	}
+
+	newPost := oldDBPost.Clone()
+
+	if newPost.Message != post.Message {
+		newPost.Message = post.Message
+		newPost.EditAt = model.GetMillis()
+		newPost.Hashtags, _ = model.ParseHashtags(post.Message)
+	}
+
+	if !safeUpdate {
+		newPost.IsPinned = post.IsPinned
+		newPost.HasReactions = post.HasReactions
+		newPost.FileIds = post.FileIds
+		newPost.SetProps(post.GetProps())
+	}
+
+	// Avoid deep-equal checks if EditAt was already modified through message change
+	if newPost.EditAt == oldPost.EditAt && (!oldPost.FileIds.Equals(newPost.FileIds) || !oldPost.AttachmentsEqual(newPost)) {
+		newPost.EditAt = model.GetMillis()
+	}
+
+	if err = a.FillInPostProps(c, post, nil); err != nil {
+		return nil, err
+	}
+
+	if post.IsRemote() {
+		oldPost.RemoteId = model.NewString(*post.RemoteId)
+	}
+	pluginContext := pluginContext(c)
+	var rejectionReason string
+	a.ch.RunMultiHook(func(hooks plugin.Hooks) bool {
+		newPost, rejectionReason = hooks.MessageWillBeUpdated(pluginContext, newPost.ForPlugin(), oldPost.ForPlugin())
+		return post != nil
+	}, plugin.MessageWillBeUpdatedID)
+	if newPost == nil {
+		return nil, model.NewAppError("UpdatePost", "Post rejected by plugin. "+rejectionReason, nil, "", http.StatusBadRequest)
+	}
+	newDBPost := newPost.Clone()
+	pollFields, _ := a.Srv().Store().PollField().GetPollFields(post.Id)
+	if len(post.Attachments()) != 0 {
+		attachment := post.Attachments()[0]
+		if len(pollFields) != 0 {
+			model.ParseSlackAttachment(newDBPost, removeFields(attachment))
+		}
+	}
+	rpost, nErr := a.Srv().Store().Post().Update(newDBPost, oldDBPost)
+	if len(post.Attachments()) != 0 {
+		attachment := post.Attachments()[0]
+		if len(pollFields) != 0 {
+			model.ParseSlackAttachment(newPost, getReplaceAttachment(attachment, pollFields, anonymous, status))
+			model.ParseSlackAttachment(rpost, getReplaceAttachment(attachment, pollFields, anonymous, status))
+		}
+	}
+	if nErr != nil {
+		var appErr *model.AppError
+		switch {
+		case errors.As(nErr, &appErr):
+			return nil, appErr
+		default:
+			return nil, model.NewAppError("UpdatePost", "app.post.update.app_error", nil, "", http.StatusInternalServerError).Wrap(nErr)
+		}
+	}
+
+	pluginOldPost := oldPost.ForPlugin()
+	pluginNewPost := newPost.ForPlugin()
+	a.Srv().Go(func() {
+		a.ch.RunMultiHook(func(hooks plugin.Hooks) bool {
+			hooks.MessageHasBeenUpdated(pluginContext, pluginNewPost, pluginOldPost)
+			return true
+		}, plugin.MessageHasBeenUpdatedID)
+	})
+
+	rpost = a.PreparePostForClientWithEmbedsAndImages(c, rpost, false, true, true)
+
+	// Ensure IsFollowing is nil since this updated post will be broadcast to all users
+	// and we don't want to have to populate it for every single user and broadcast to each
+	// individually.
+	rpost.IsFollowing = nil
+
+	rpost, nErr = a.addPostPreviewProp(rpost)
+	if nErr != nil {
+		return nil, model.NewAppError("UpdatePost", "app.post.update.app_error", nil, "", http.StatusInternalServerError).Wrap(nErr)
+	}
+
+	message := model.NewWebSocketEvent(model.WebsocketEventPostEdited, "", rpost.ChannelId, "", nil, "")
+	postJSON, jsonErr := rpost.ToJSON()
+	if jsonErr != nil {
+		return nil, model.NewAppError("UpdatePost", "app.post.marshal.app_error", nil, "", http.StatusInternalServerError).Wrap(jsonErr)
+	}
+	message.Add("post", postJSON)
+
+	published, err := a.publishWebsocketEventForPermalinkPost(c, rpost, message)
+	if err != nil {
+		return nil, err
+	}
+	if !published {
+		a.Publish(message)
+	}
+
+	a.invalidateCacheForChannelPosts(rpost.ChannelId)
+
+	return rpost, nil
+}
+
+func removeFields(attachment *model.SlackAttachment) []*model.SlackAttachment {
+	return []*model.SlackAttachment{{
+		AuthorName: attachment.AuthorName,
+		Title:      attachment.Title,
+		Text:       attachment.Text,
+		Actions:    attachment.Actions,
+		Fields:     nil,
+	}}
+}
+func getReplaceAttachment(attachment *model.SlackAttachment, fields []*model.PollFields, anonymous bool, status string) []*model.SlackAttachment {
+	pollFields := []*model.SlackAttachmentField{}
+	for _, field := range fields {
+		value := field.Voter
+		webValue := field.Voter
+		if status != "end" {
+			webValue = ""
+			value = ""
+		}
+		if anonymous {
+			webValue = ""
+			value = ""
+		}
+		pollFields = append(pollFields, &model.SlackAttachmentField{
+			Short:    true,
+			Title:    field.Answer,
+			Value:    value,
+			WebValue: webValue,
+		})
+	}
+	return []*model.SlackAttachment{{
+		AuthorName: attachment.AuthorName,
+		Title:      attachment.Title,
+		Text:       attachment.Text,
+		Actions:    attachment.Actions,
+		Fields:     pollFields,
+	}}
+}
+
 func (a *App) PatchPost(c *request.Context, postID string, patch *model.PostPatch) (*model.Post, *model.AppError) {
 	post, err := a.GetSinglePost(postID, false)
 	if err != nil {
Index: mattermost-server-7.8.1/app/server.go
===================================================================
--- mattermost-server-7.8.1/app/server.go	(revision 4484)
+++ mattermost-server-7.8.1/app/server.go	(revision 4485)
@@ -393,6 +393,20 @@
 		s.EmailService.InitEmailBatching()
 	})
 
+	/* Ryobi Systems CloudOffice Update Service-version Mod 20230224 start */
+	mlog.Info("System built-in version:" + model.CurrentVersion)
+	pluginOpenStatus := s.Config().PluginSettings.PluginStates["extrasrvversionsettingplugin"]
+	if pluginOpenStatus != nil && pluginOpenStatus.Enable {
+		if versionPluginData, ok := s.Config().PluginSettings.Plugins["extrasrvversionsettingplugin"]; ok {
+			if versionFromPlugin, isOk := versionPluginData["extrasrvversion"]; isOk {
+				if versionFromPlugin.(string) != "" {
+					model.CurrentVersion = versionFromPlugin.(string)
+				}
+			}
+		}
+	}
+	/* Ryobi Systems CloudOffice Update Service-version Mod 20230224 end */
+
 	logCurrentVersion := fmt.Sprintf("Current version is %v (%v/%v/%v/%v)", model.CurrentVersion, model.BuildNumber, model.BuildDate, model.BuildHash, model.BuildHashEnterprise)
 	mlog.Info(
 		logCurrentVersion,
Index: mattermost-server-7.8.1/app/session.go
===================================================================
--- mattermost-server-7.8.1/app/session.go	(revision 4484)
+++ mattermost-server-7.8.1/app/session.go	(revision 4485)
@@ -19,7 +19,34 @@
 )
 
 func (a *App) CreateSession(session *model.Session) (*model.Session, *model.AppError) {
+	/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 START */
+	var sessionDefault model.Session
+	sessionDefault = *session
+	sessiondefault := &sessionDefault
+	/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 END */
 	session, err := a.ch.srv.platform.CreateSession(session)
+	/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 START */
+	if len(session.TeamMembers) == 0 {
+
+		sessiondefault.Token = ""
+		sessiondefault, err = a.Srv().Store().Session().Save(sessiondefault)
+
+		if err != nil {
+
+			var invErr *store.ErrInvalidInput
+			switch {
+			case errors.As(err, &invErr):
+				return nil, model.NewAppError("CreateSession", "app.session.save.existing.app_error", nil, invErr.Error(), http.StatusBadRequest)
+			default:
+				return nil, model.NewAppError("CreateSession", "app.session.save.app_error", nil, err.Error(), http.StatusInternalServerError)
+			}
+		}
+
+		a.AddSessionToCache(sessiondefault)
+
+		return sessiondefault, nil
+	}
+	/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 END */
 	if err != nil {
 		var invErr *store.ErrInvalidInput
 		switch {
@@ -148,6 +175,23 @@
 	return nil
 }
 
+/**
+Revoke Sessions By userID SessionState
+*/
+func (a *App) RevokeUserSession(userID string, sessionState string) *model.AppError {
+	if err := a.ch.srv.platform.RevokeSessionsBySid(userID, sessionState); err != nil {
+		switch {
+		case errors.Is(err, users.GetSessionError):
+			return model.NewAppError("RevokeUserSession", "app.session.get_sessions.app_error", nil, err.Error(), http.StatusInternalServerError)
+		case errors.Is(err, users.DeleteSessionError):
+			return model.NewAppError("RevokeUserSession", "app.session.remove.app_error", nil, err.Error(), http.StatusInternalServerError)
+		default:
+			return model.NewAppError("RevokeUserSession", "app.session.remove.app_error", nil, err.Error(), http.StatusInternalServerError)
+		}
+	}
+	return nil
+}
+
 func (a *App) AddSessionToCache(session *model.Session) {
 	a.ch.srv.platform.AddSessionToCache(session)
 }
Index: mattermost-server-7.8.1/app/status.go
===================================================================
--- mattermost-server-7.8.1/app/status.go	(revision 4484)
+++ mattermost-server-7.8.1/app/status.go	(revision 4485)
@@ -12,11 +12,42 @@
 	"github.com/mattermost/mattermost-server/v6/shared/mlog"
 )
 
+func (a *App) GetUserWebMeetingStatus(userId string) (*model.Status, error) {
+	var status *model.Status
+	if err := a.Srv().Platform().StatusCache().Get(userId, &status); err == nil {
+		return status, err
+	}
+	status, error := a.Srv().Store().Status().Get(userId)
+
+	return status, error
+}
+
 // GetUserStatusesByIds used by apiV4
 func (a *App) GetUserStatusesByIds(userIDs []string) ([]*model.Status, *model.AppError) {
 	return a.Srv().Platform().GetUserStatusesByIds(userIDs)
 }
 
+func (a *App) SetStatusMeetingIfNeeded(userId string, manual bool) {
+	if !*a.Config().ServiceSettings.EnableUserStatuses {
+		return
+	}
+
+	status, err := a.GetStatus(userId)
+
+	if err != nil {
+		status = &model.Status{UserId: userId, Status: model.STATUS_MEETING, Manual: manual, LastActivityAt: 0, ActiveChannel: ""}
+	}
+	if status.Manual == false && manual == false {
+		status.PrevStatus = status.Status
+	}
+
+	status.Status = model.STATUS_MEETING
+	status.Manual = manual
+	status.ActiveChannel = ""
+
+	a.Srv().Platform().SaveAndBroadcastStatus(status)
+}
+
 // SetStatusLastActivityAt sets the last activity at for a user on the local app server and updates
 // status to away if needed. Used by the WS to set status to away if an 'online' device disconnects
 // while an 'away' device is still connected
Index: mattermost-server-7.8.1/app/team.go
===================================================================
--- mattermost-server-7.8.1/app/team.go	(revision 4484)
+++ mattermost-server-7.8.1/app/team.go	(revision 4485)
@@ -325,7 +325,9 @@
 
 	// Force a regeneration of the invite token if changing a team to restricted.
 	if (allowOpenInvite != oldTeam.AllowOpenInvite || teamType != oldTeam.Type) && (!allowOpenInvite || teamType == model.TeamInvite) {
-		oldTeam.InviteId = model.NewId()
+		if !*a.Config().TeamSettings.EnableMultiTenancySupport {
+			oldTeam.InviteId = model.NewId()
+		}
 	}
 
 	oldTeam.Type = teamType
@@ -385,9 +387,10 @@
 	if err != nil {
 		return nil, err
 	}
+	if !*a.Config().TeamSettings.EnableMultiTenancySupport {
+		team.InviteId = model.NewId()
+	}
 
-	team.InviteId = model.NewId()
-
 	updatedTeam, nErr := a.Srv().Store().Team().Update(team)
 	if nErr != nil {
 		var invErr *store.ErrInvalidInput
@@ -1171,6 +1174,21 @@
 	return teamUnread, nil
 }
 
+/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 START */
+func (a *App) GetDefaultTeama(teamId string) int {
+	var DefaultTeama int
+	DefaultTeama = 0
+	DefaultTeamid, _ := a.Srv().Store().Session().SqlGetDefaultTeam()
+
+	if DefaultTeamid == teamId {
+		DefaultTeama = 1
+		return DefaultTeama
+	}
+	return DefaultTeama
+}
+
+/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 END */
+
 func (a *App) RemoveUserFromTeam(c request.CTX, teamID string, userID string, requestorId string) *model.AppError {
 	tchan := make(chan store.StoreResult, 1)
 	go func() {
@@ -1328,9 +1346,11 @@
 func (a *App) postLeaveTeamMessage(c request.CTX, user *model.User, channel *model.Channel) *model.AppError {
 	post := &model.Post{
 		ChannelId: channel.Id,
-		Message:   fmt.Sprintf(i18n.T("api.team.leave.left"), user.Username),
-		Type:      model.PostTypeLeaveTeam,
-		UserId:    user.Id,
+		/* Ryobi Systems CloudOffice Meeting Mod メール本文にIDを姓名に変更 20210609 START */
+		Message: fmt.Sprintf(i18n.T("api.team.leave.left"), user.GetFullName()),
+		/* Ryobi Systems CloudOffice Meeting Mod メール本文にIDを姓名に変更 20210609 END */
+		Type:   model.PostTypeLeaveTeam,
+		UserId: user.Id,
 		Props: model.StringInterface{
 			"username": user.Username,
 		},
@@ -1346,9 +1366,10 @@
 func (a *App) postRemoveFromTeamMessage(c request.CTX, user *model.User, channel *model.Channel) *model.AppError {
 	post := &model.Post{
 		ChannelId: channel.Id,
-		Message:   fmt.Sprintf(i18n.T("api.team.remove_user_from_team.removed"), user.Username),
-		Type:      model.PostTypeRemoveFromTeam,
-		UserId:    user.Id,
+		/* Ryobi Systems CloudOffice Meeting Mod メール本文にIDを姓名に変更 20210609 START */
+		Message: fmt.Sprintf(i18n.T("api.team.remove_user_from_team.removed"), user.GetFullName()),
+		/* Ryobi Systems CloudOffice Meeting Mod メール本文にIDを姓名に変更 20210609 END */
+		UserId: user.Id,
 		Props: model.StringInterface{
 			"username": user.Username,
 		},
Index: mattermost-server-7.8.1/app/teams/teams.go
===================================================================
--- mattermost-server-7.8.1/app/teams/teams.go	(revision 4484)
+++ mattermost-server-7.8.1/app/teams/teams.go	(revision 4485)
@@ -111,7 +111,9 @@
 
 	team.Patch(patch)
 	if patch.AllowOpenInvite != nil && !*patch.AllowOpenInvite {
-		team.InviteId = model.NewId()
+		if !*ts.config().TeamSettings.EnableMultiTenancySupport {
+			team.InviteId = model.NewId()
+		}
 	}
 
 	if err = ts.checkValidDomains(team); err != nil {
Index: mattermost-server-7.8.1/app/user.go
===================================================================
--- mattermost-server-7.8.1/app/user.go	(revision 4484)
+++ mattermost-server-7.8.1/app/user.go	(revision 4485)
@@ -1270,6 +1270,35 @@
 	return nil
 }
 
+/* Ryobi Systems MM_NC_連動SSOログアウト Mod 20201130 START */
+func (a *App) RevokeAllSessionsById(userId string) *model.AppError {
+	_, err := a.GetUser(userId)
+
+	if err != nil {
+		return err
+	}
+
+	if err = a.RevokeAllSessions(userId); err != nil {
+		return err
+	}
+
+	return nil
+}
+
+/* Ryobi Systems MM_NC_連動SSOログアウト Mod 20201130 END */
+// delete session by userid sessionState
+func (a *App) RevokeUserSessionById(userId string,sessionState string) *model.AppError {
+	_, err := a.GetUser(userId)
+	if err != nil {
+		return err
+	}
+	if err = a.RevokeUserSession(userId,sessionState); err != nil {
+		return err
+	}
+	return nil
+}
+
+
 func (a *App) updateUserNotifyProps(userID string, props map[string]string) *model.AppError {
 	err := a.ch.srv.userService.UpdateUserNotifyProps(userID, props)
 	if err != nil {
Index: mattermost-server-7.8.1/app/users/errors.go
===================================================================
--- mattermost-server-7.8.1/app/users/errors.go	(revision 4484)
+++ mattermost-server-7.8.1/app/users/errors.go	(revision 4485)
@@ -11,9 +11,10 @@
 	UserCountError            = errors.New("could not get the total number of the users.")
 	UserCreationDisabledError = errors.New("user creation is not allowed")
 	UserStoreIsEmptyError     = errors.New("could not check if the user store is empty")
+	GetSessionError           = errors.New("could not get session")
+	DeleteSessionError        = errors.New("could not delete session")
+	DeleteAllAccessDataError  = errors.New("could not delete all access data")
 
-	DeleteAllAccessDataError = errors.New("could not delete all access data")
-
 	DefaultFontError   = errors.New("could not get default font")
 	UserInitialsError  = errors.New("could not get user initials")
 	ImageEncodingError = errors.New("could not encode image")
Index: mattermost-server-7.8.1/cmd/mattermost/commands/import.go
===================================================================
--- mattermost-server-7.8.1/cmd/mattermost/commands/import.go	(revision 4484)
+++ mattermost-server-7.8.1/cmd/mattermost/commands/import.go	(revision 4485)
@@ -10,10 +10,8 @@
 
 	"github.com/spf13/cobra"
 
-	"github.com/mattermost/mattermost-server/v6/app"
 	"github.com/mattermost/mattermost-server/v6/app/request"
 	"github.com/mattermost/mattermost-server/v6/audit"
-	"github.com/mattermost/mattermost-server/v6/model"
 )
 
 var ImportCmd = &cobra.Command{
@@ -171,16 +169,3 @@
 
 	return nil
 }
-
-func getTeamFromTeamArg(a *app.App, teamArg string) *model.Team {
-	var team *model.Team
-	team, err := a.Srv().Store().Team().GetByName(teamArg)
-
-	if err != nil {
-		var t *model.Team
-		if t, err = a.Srv().Store().Team().Get(teamArg); err == nil {
-			team = t
-		}
-	}
-	return team
-}
Index: mattermost-server-7.8.1/cmd/mattermost/commands/init.go
===================================================================
--- mattermost-server-7.8.1/cmd/mattermost/commands/init.go	(revision 4484)
+++ mattermost-server-7.8.1/cmd/mattermost/commands/init.go	(revision 4485)
@@ -30,7 +30,9 @@
 func InitDBCommandContextCobra(command *cobra.Command, options ...app.Option) (*app.App, error) {
 	return initDBCommandContextCobra(command, true, options...)
 }
-
+func InitDBCommandContextCobraReadWrite(command *cobra.Command) (*app.App, error) {
+	return initDBCommandContextCobra(command, false)
+}
 func initDBCommandContext(configDSN string, readOnlyConfigStore bool, options ...app.Option) (*app.App, error) {
 	if err := utils.TranslationsPreInit(); err != nil {
 		return nil, err
Index: mattermost-server-7.8.1/cmd/mattermost/commands/plugin.go
===================================================================
--- mattermost-server-7.8.1/cmd/mattermost/commands/plugin.go	(nonexistent)
+++ mattermost-server-7.8.1/cmd/mattermost/commands/plugin.go	(revision 4485)
@@ -0,0 +1,465 @@
+// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
+// See LICENSE.txt for license information.
+
+package commands
+
+import (
+	"fmt"
+	"github.com/pkg/errors"
+	"github.com/spf13/cobra"
+	"net/http"
+	"os"
+	"path/filepath"
+	"regexp"
+
+	"github.com/mattermost/mattermost-server/v6/audit"
+	"github.com/mattermost/mattermost-server/v6/model"
+)
+
+var PluginCmd = &cobra.Command{
+	Use:   "plugin",
+	Short: "Management of plugins",
+}
+
+var PluginAddVersionSettingCmd = &cobra.Command{
+	Use:     "addVersionSetting [plugins]",
+	Short:   "addVersionSetting plugins",
+	Long:    "add addVersionSetting plugins to your Mattermost server.",
+	Example: `  plugin addVersionSetting version.tar.gz --version 5.37.1`,
+	RunE:    pluginAddVersionSettingCmd,
+}
+var PluginAddDefaultTeamCmd = &cobra.Command{
+	Use:     "addDefaultTeam [plugins]",
+	Short:   "addDefaultTeam plugins",
+	Long:    "add DefaultTeam plugins to your Mattermost server.",
+	Example: `  plugin addDefaultTeam pluginDefaultTeam.tar.gz --teamName defaultTeam`,
+	RunE:    pluginAddDefaultTeamCmdF,
+}
+var PluginAddCmd = &cobra.Command{
+	Use:     "add [plugins]",
+	Short:   "Add plugins",
+	Long:    "Add plugins to your Mattermost server.",
+	Example: `  plugin add hovercardexample.tar.gz pluginexample.tar.gz`,
+	RunE:    pluginAddCmdF,
+}
+
+var PluginDeleteCmd = &cobra.Command{
+	Use:     "delete [plugins]",
+	Short:   "Delete plugins",
+	Long:    "Delete previously uploaded plugins from your Mattermost server.",
+	Example: `  plugin delete hovercardexample pluginexample`,
+	RunE:    pluginDeleteCmdF,
+}
+
+var PluginEnableCmd = &cobra.Command{
+	Use:     "enable [plugins]",
+	Short:   "Enable plugins",
+	Long:    "Enable plugins for use on your Mattermost server.",
+	Example: `  plugin enable hovercardexample pluginexample`,
+	RunE:    pluginEnableCmdF,
+}
+
+var PluginDisableCmd = &cobra.Command{
+	Use:     "disable [plugins]",
+	Short:   "Disable plugins",
+	Long:    "Disable plugins. Disabled plugins are immediately removed from the user interface and logged out of all sessions.",
+	Example: `  plugin disable hovercardexample pluginexample`,
+	RunE:    pluginDisableCmdF,
+}
+
+var PluginListCmd = &cobra.Command{
+	Use:     "list",
+	Short:   "List plugins",
+	Long:    "List all enabled and disabled plugins installed on your Mattermost server.",
+	Example: `  plugin list`,
+	RunE:    pluginListCmdF,
+}
+
+var PluginPublicKeysCmd = &cobra.Command{
+	Use:   "keys",
+	Short: "List public keys",
+	Long:  "List names of all public keys installed on your Mattermost server.",
+	Example: `  plugin keys
+  plugin keys --verbose`,
+	RunE: pluginPublicKeysCmdF,
+}
+
+var PluginAddPublicKeyCmd = &cobra.Command{
+	Use:     "add [keys]",
+	Short:   "Adds public key(s)",
+	Long:    "Adds public key(s) for plugins on your Mattermost server.",
+	Example: `  plugin keys add my-pk-file1 my-pk-file2`,
+	RunE:    pluginAddPublicKeyCmdF,
+}
+
+var PluginDeletePublicKeyCmd = &cobra.Command{
+	Use:     "delete [keys]",
+	Short:   "Deletes public key(s)",
+	Long:    "Deletes public key(s) for plugins on your Mattermost server.",
+	Example: `  plugin keys delete my-pk-file1 my-pk-file2`,
+	RunE:    pluginDeletePublicKeyCmdF,
+}
+
+func init() {
+	PluginPublicKeysCmd.Flags().Bool("verbose", false, "List names and details of all public keys installed on your Mattermost server.")
+	PluginAddDefaultTeamCmd.Flags().String("teamName", "", "Set a default team .")
+	PluginAddVersionSettingCmd.Flags().String("version", "", "Set a default version .")
+	PluginPublicKeysCmd.AddCommand(
+		PluginAddPublicKeyCmd,
+		PluginDeletePublicKeyCmd,
+	)
+	PluginCmd.AddCommand(
+		PluginAddCmd,
+		PluginAddDefaultTeamCmd,
+		PluginDeleteCmd,
+		PluginEnableCmd,
+		PluginDisableCmd,
+		PluginListCmd,
+		PluginPublicKeysCmd,
+		PluginAddVersionSettingCmd,
+	)
+
+	RootCmd.AddCommand(PluginCmd)
+}
+
+func pluginAddCmdF(command *cobra.Command, args []string) error {
+	a, err := InitDBCommandContextCobraReadWrite(command)
+	if err != nil {
+		return err
+	}
+	defer a.Srv().Shutdown()
+
+	if len(args) < 1 {
+		return errors.New("Expected at least one argument. See help text for details.")
+	}
+
+	for i, plugin := range args {
+		fileReader, err := os.Open(plugin)
+		if err != nil {
+			return err
+		}
+
+		if _, err := a.InstallPlugin(fileReader, false); err != nil {
+			CommandPrintErrorln("Unable to add plugin: " + args[i] + ". Error: " + err.Error())
+		} else {
+			CommandPrettyPrintln("Added plugin: " + plugin)
+			auditRec := a.MakeAuditRecord("pluginAdd", audit.Success)
+			auditRec.AddMeta("plugin", plugin)
+			a.LogAuditRec(auditRec, nil)
+		}
+		fileReader.Close()
+	}
+	return nil
+}
+
+func pluginDeleteCmdF(command *cobra.Command, args []string) error {
+	a, err := InitDBCommandContextCobraReadWrite(command)
+	if err != nil {
+		return err
+	}
+	defer a.Srv().Shutdown()
+
+	if len(args) < 1 {
+		return errors.New("Expected at least one argument. See help text for details.")
+	}
+
+	for _, plugin := range args {
+		if err := a.Channels().RemovePlugin(plugin); err != nil {
+			CommandPrintErrorln("Unable to delete plugin: " + plugin + ". Error: " + err.Error())
+		} else {
+			CommandPrettyPrintln("Deleted plugin: " + plugin)
+			auditRec := a.MakeAuditRecord("pluginDelete", audit.Success)
+			auditRec.AddMeta("plugin", plugin)
+			a.LogAuditRec(auditRec, nil)
+		}
+	}
+	return nil
+}
+
+func pluginEnableCmdF(command *cobra.Command, args []string) error {
+	a, err := InitDBCommandContextCobraReadWrite(command)
+	if err != nil {
+		return err
+	}
+	defer a.Srv().Shutdown()
+
+	if len(args) < 1 {
+		return errors.New("Expected at least one argument. See help text for details.")
+	}
+
+	for _, plugin := range args {
+		if err := a.EnablePlugin(plugin); err != nil {
+			CommandPrintErrorln("Unable to enable plugin: " + plugin + ". Error: " + err.Error())
+		} else {
+			CommandPrettyPrintln("Enabled plugin: " + plugin)
+			auditRec := a.MakeAuditRecord("pluginEnable", audit.Success)
+			auditRec.AddMeta("plugin", plugin)
+			a.LogAuditRec(auditRec, nil)
+		}
+	}
+	return nil
+}
+
+func pluginDisableCmdF(command *cobra.Command, args []string) error {
+	a, err := InitDBCommandContextCobraReadWrite(command)
+	if err != nil {
+		return err
+	}
+	defer a.Srv().Shutdown()
+
+	if len(args) < 1 {
+		return errors.New("Expected at least one argument. See help text for details.")
+	}
+
+	for _, plugin := range args {
+		if err := a.DisablePlugin(plugin); err != nil {
+			CommandPrintErrorln("Unable to disable plugin: " + plugin + ". Error: " + err.Error())
+		} else {
+			CommandPrettyPrintln("Disabled plugin: " + plugin)
+			auditRec := a.MakeAuditRecord("pluginDisable", audit.Success)
+			auditRec.AddMeta("plugin", plugin)
+			a.LogAuditRec(auditRec, nil)
+		}
+	}
+	return nil
+}
+
+func pluginListCmdF(command *cobra.Command, args []string) error {
+	a, err := InitDBCommandContextCobra(command)
+	if err != nil {
+		return err
+	}
+	defer a.Srv().Shutdown()
+
+	pluginsResp, appErr := a.GetPlugins()
+	if appErr != nil {
+		return errors.Wrap(appErr, "Unable to list plugins.")
+	}
+
+	CommandPrettyPrintln("Listing enabled plugins")
+	for _, plugin := range pluginsResp.Active {
+		CommandPrettyPrintln(plugin.Manifest.Name + ", Version: " + plugin.Manifest.Version)
+	}
+
+	CommandPrettyPrintln("Listing disabled plugins")
+	for _, plugin := range pluginsResp.Inactive {
+		CommandPrettyPrintln(plugin.Manifest.Name + ", Version: " + plugin.Manifest.Version)
+	}
+
+	return nil
+}
+
+func pluginPublicKeysCmdF(command *cobra.Command, args []string) error {
+	a, err := InitDBCommandContextCobra(command)
+	if err != nil {
+		return err
+	}
+	defer a.Srv().Shutdown()
+
+	verbose, err := command.Flags().GetBool("verbose")
+	if err != nil {
+		return errors.Wrap(err, "Failed reading verbose flag.")
+	}
+
+	pluginPublicKeysResp := a.Srv().Config().PluginSettings.SignaturePublicKeyFiles
+
+	if verbose {
+		for _, publicKey := range pluginPublicKeysResp {
+			key, err := a.GetPublicKey(publicKey)
+			if err != nil {
+				CommandPrintErrorln("Unable to get plugin public key: " + publicKey + ". Error: " + err.Error())
+			}
+			CommandPrettyPrintln("Plugin name: " + publicKey + ". \nPublic key: \n" + string(key) + "\n")
+		}
+	} else {
+		for _, publicKey := range pluginPublicKeysResp {
+			CommandPrettyPrintln(publicKey)
+		}
+	}
+
+	return nil
+}
+
+func pluginAddPublicKeyCmdF(command *cobra.Command, args []string) error {
+	a, err := InitDBCommandContextCobraReadWrite(command)
+	if err != nil {
+		return err
+	}
+	defer a.Srv().Shutdown()
+
+	if len(args) < 1 {
+		return errors.New("Expected at least one argument. See help text for details.")
+	}
+
+	for _, pkFile := range args {
+		filename := filepath.Base(pkFile)
+		fileReader, err := os.Open(pkFile)
+		if err != nil {
+			return model.NewAppError("AddPublicKey", "api.plugin.add_public_key.open.app_error", nil, err.Error(), http.StatusInternalServerError)
+		}
+		defer fileReader.Close()
+
+		if err := a.AddPublicKey(filename, fileReader); err != nil {
+			CommandPrintErrorln("Unable to add public key: " + pkFile + ". Error: " + err.Error())
+		} else {
+			CommandPrettyPrintln("Added public key: " + pkFile)
+			auditRec := a.MakeAuditRecord("pluginAddPublicKey", audit.Success)
+			auditRec.AddMeta("file", pkFile)
+			a.LogAuditRec(auditRec, nil)
+		}
+	}
+	return nil
+}
+
+func pluginDeletePublicKeyCmdF(command *cobra.Command, args []string) error {
+	a, err := InitDBCommandContextCobraReadWrite(command)
+	if err != nil {
+		return err
+	}
+	defer a.Srv().Shutdown()
+
+	if len(args) < 1 {
+		return errors.New("Expected at least one argument. See help text for details.")
+	}
+
+	for _, pkFile := range args {
+		if err := a.DeletePublicKey(pkFile); err != nil {
+			CommandPrintErrorln("Unable to delete public key: " + pkFile + ". Error: " + err.Error())
+		} else {
+			CommandPrettyPrintln("Deleted public key: " + pkFile)
+			auditRec := a.MakeAuditRecord("pluginDeletePublicKey", audit.Success)
+			auditRec.AddMeta("file", pkFile)
+			a.LogAuditRec(auditRec, nil)
+		}
+	}
+	return nil
+}
+
+func pluginAddVersionSettingCmd(command *cobra.Command, args []string) error {
+	version, err := command.Flags().GetString("version")
+	if err != nil {
+		return errors.New("The command line is incorrect, example: plugin addVersionSetting version.tar.gz --version 5.37.1")
+	}
+	if version == "" {
+		return errors.New("--version is required to set a valid value, example: plugin addVersionSetting version.tar.gz --version 5.37.1")
+	}
+	match, _ := regexp.MatchString("^([1-9]\\d|[1-9])(.([1-9]\\d|\\d)){2}$", version)
+	if !match {
+		return errors.New("invalid version number, example: plugin addVersionSetting version.tar.gz --version 5.37.1")
+	}
+	a, err := InitDBCommandContextCobraReadWrite(command)
+	if err != nil {
+		return err
+	}
+	defer a.Srv().Shutdown()
+	if len(args) < 1 {
+		return errors.New("Expected at least one argument. See help text for details.")
+	}
+	for i, plugin := range args {
+		fileReader, err := os.Open(plugin)
+		if err != nil {
+			return err
+		}
+		if _, err := a.InstallPlugin(fileReader, false); err != nil {
+			CommandPrintErrorln("Unable to add plugin: " + args[i] + ". Error: " + err.Error())
+		} else {
+			CommandPrettyPrintln("Added plugin: " + plugin)
+			auditRec := a.MakeAuditRecord("pluginAdd", audit.Success)
+			auditRec.AddMeta("plugin", plugin)
+			a.LogAuditRec(auditRec, nil)
+		}
+		fileReader.Close()
+	}
+	//update config.json
+	plugins := make(map[string]map[string]interface{})
+	appCfg := a.Config()
+	oldPlugins := appCfg.PluginSettings.Plugins
+	newPlugin := map[string]map[string]interface{}{
+		"extrasrvversionsettingplugin": {
+			"extrasrvversion": version,
+		},
+	}
+	for s := range oldPlugins {
+		plugins[s] = oldPlugins[s]
+	}
+	for s := range newPlugin {
+		plugins[s] = newPlugin[s]
+	}
+	appCfg.PluginSettings.Plugins = plugins
+	a.SaveConfig(appCfg, true)
+	//
+	return nil
+}
+func pluginAddDefaultTeamCmdF(command *cobra.Command, args []string) error {
+	teamName, err := command.Flags().GetString("teamName")
+	if err != nil {
+		return errors.New("The command line is incorrect. example: plugin addDefaultTeam pluginDefaultTeam.tar.gz --teamName defaultTeam")
+	}
+	if teamName == "" {
+		return errors.New("--teamName is required to set a valid value, example: plugin addDefaultTeam pluginDefaultTeam.tar.gz --teamName defaultTeam")
+	}
+	a, newErr := InitDBCommandContextCobraReadWrite(command)
+	if newErr != nil {
+		return newErr
+	}
+	team, err := a.Srv().Store().Team().GetByName(teamName)
+	if err != nil {
+		return errors.New(fmt.Sprintf("team %s is not exist,please reinstall plugin with correct team name", teamName))
+	}
+	defer a.Srv().Shutdown()
+	if len(args) < 1 {
+		return errors.New("Expected at least one argument. See help text for details.")
+	}
+	for i, plugin := range args {
+		fileReader, err := os.Open(plugin)
+		if err != nil {
+			return err
+		}
+		if _, err := a.InstallPlugin(fileReader, false); err != nil {
+			_, err := CommandPrintErrorln("Unable to add plugin: " + args[i] + ". Error: " + err.Error())
+			if err != nil {
+				return err
+			}
+		} else {
+			_, err := CommandPrettyPrintln("Added plugin: " + plugin)
+			if err != nil {
+				return err
+			}
+			auditRec := a.MakeAuditRecord("pluginAdd", audit.Success)
+			auditRec.AddMeta("plugin", plugin)
+			a.LogAuditRec(auditRec, nil)
+		}
+		err = fileReader.Close()
+		if err != nil {
+			return err
+		}
+	}
+	//update config.json
+	plugins := make(map[string]map[string]interface{})
+	appCfg := a.Config()
+	oldPlugins := appCfg.PluginSettings.Plugins
+	newPlugin := map[string]map[string]interface{}{
+		"plugindefaultteam": {
+			"defaultteam": teamName,
+		},
+	}
+	for s := range oldPlugins {
+		plugins[s] = oldPlugins[s]
+	}
+	for s := range newPlugin {
+		plugins[s] = newPlugin[s]
+	}
+	appCfg.PluginSettings.Plugins = plugins
+	a.SaveConfig(appCfg, true)
+	//update defaultTeam settings to database
+	DefaultTeam, errDefaultTeam := a.Srv().Store().Session().SqlGetDefaultTeam()
+	if errDefaultTeam == nil && DefaultTeam != "" {
+		_ = a.Srv().Store().Session().SqlDeleteDefaultTeam()
+	}
+	dt := model.DefaultTeam{}
+	dt.Id = team.Id
+	dt.CreateAt = 0
+	dt.UpdateAt = 0
+	a.Srv().Store().Session().SqlSaveDefaultTeam(&dt)
+	return nil
+}
Index: mattermost-server-7.8.1/cmd/mattermost/commands/server.go
===================================================================
--- mattermost-server-7.8.1/cmd/mattermost/commands/server.go	(revision 4484)
+++ mattermost-server-7.8.1/cmd/mattermost/commands/server.go	(revision 4485)
@@ -93,6 +93,16 @@
 		}
 	}()
 
+	a := app.New(app.ServerConnector(server.Channels()))
+	// sinkatec 20211008 追加　start
+	go a.SubscribeRedisMeetingEnd()
+	// sinkatec 20211008 追加　end
+	// sinkatec 20210821 start
+	go a.SubscribeRedis()
+	// sinkatec 20210821 end
+	// sinkatec 20211129 追加　start
+	go a.SetCronChat()
+	// sinkatec 20211129 追加　end
 	api, err := api4.Init(server)
 	if err != nil {
 		mlog.Error(err.Error())
Index: mattermost-server-7.8.1/cmd/mattermost/commands/team.go
===================================================================
--- mattermost-server-7.8.1/cmd/mattermost/commands/team.go	(nonexistent)
+++ mattermost-server-7.8.1/cmd/mattermost/commands/team.go	(revision 4485)
@@ -0,0 +1,561 @@
+// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
+// See LICENSE.txt for license information.
+
+package commands
+
+import (
+	"context"
+	"errors"
+	"fmt"
+	"sort"
+	"strings"
+
+	"github.com/spf13/cobra"
+
+	"github.com/mattermost/mattermost-server/v6/app"
+	"github.com/mattermost/mattermost-server/v6/app/request"
+	"github.com/mattermost/mattermost-server/v6/audit"
+	"github.com/mattermost/mattermost-server/v6/model"
+)
+
+var TeamCmd = &cobra.Command{
+	Use:   "team",
+	Short: "Management of teams",
+}
+
+var TeamCreateCmd = &cobra.Command{
+	Use:   "create",
+	Short: "Create a team",
+	Long:  `Create a team.`,
+	Example: `  team create --name mynewteam --display_name "My New Team"
+  team create --name private --display_name "My New Private Team" --private`,
+	RunE: createTeamCmdF,
+}
+
+var RemoveUsersCmd = &cobra.Command{
+	Use:     "remove [team] [users]",
+	Short:   "Remove users from team",
+	Long:    "Remove some users from team",
+	Example: "  team remove myteam user@example.com username",
+	Args:    cobra.MinimumNArgs(2),
+	RunE:    removeUsersCmdF,
+}
+
+var AddUsersCmd = &cobra.Command{
+	Use:     "add [team] [users]",
+	Short:   "Add users to team",
+	Long:    "Add some users to team",
+	Example: "  team add myteam user@example.com username",
+	Args:    cobra.MinimumNArgs(2),
+	RunE:    addUsersCmdF,
+}
+
+var DeleteTeamsCmd = &cobra.Command{
+	Use:   "delete [teams]",
+	Short: "Delete teams",
+	Long: `Permanently delete some teams.
+Permanently deletes a team along with all related information including posts from the database.`,
+	Example: "  team delete myteam",
+	Args:    cobra.MinimumNArgs(1),
+	RunE:    deleteTeamsCmdF,
+}
+
+var ListTeamsCmd = &cobra.Command{
+	Use:     "list",
+	Short:   "List all teams.",
+	Long:    `List all teams on the server.`,
+	Example: "  team list",
+	RunE:    listTeamsCmdF,
+}
+
+var SearchTeamCmd = &cobra.Command{
+	Use:     "search [teams]",
+	Short:   "Search for teams",
+	Long:    "Search for teams based on name",
+	Example: "  team search team1",
+	Args:    cobra.MinimumNArgs(1),
+	RunE:    searchTeamCmdF,
+}
+
+var ArchiveTeamCmd = &cobra.Command{
+	Use:     "archive [teams]",
+	Short:   "Archive teams",
+	Long:    "Archive teams based on name",
+	Example: "  team archive team1",
+	Args:    cobra.MinimumNArgs(1),
+	RunE:    archiveTeamCmdF,
+}
+
+var RestoreTeamsCmd = &cobra.Command{
+	Use:     "restore [teams]",
+	Short:   "Restore some teams",
+	Long:    `Restore a previously deleted team`,
+	Example: "  team restore myteam",
+	Args:    cobra.MinimumNArgs(1),
+	RunE:    restoreTeamsCmdF,
+}
+
+var TeamRenameCmd = &cobra.Command{
+	Use:   "rename",
+	Short: "Rename a team",
+	Long:  `Rename a team.`,
+	Example: `  team rename myteam newteamname --display_name "My New Team Name"
+	team rename myteam - --display_name "My New Team Name"`,
+	Args: cobra.MinimumNArgs(2),
+	RunE: renameTeamCmdF,
+}
+
+var ModifyTeamCmd = &cobra.Command{
+	Use:     "modify [team] [flag]",
+	Short:   "Modify a team's privacy setting to public or private",
+	Long:    `Modify a team's privacy setting to public or private.`,
+	Example: "  team modify myteam --private",
+	Args:    cobra.ExactArgs(1),
+	RunE:    modifyTeamCmdF,
+}
+
+func init() {
+	TeamCreateCmd.Flags().String("name", "", "Team Name")
+	TeamCreateCmd.Flags().String("display_name", "", "Team Display Name")
+	TeamCreateCmd.Flags().Bool("private", false, "Create a private team.")
+	TeamCreateCmd.Flags().String("email", "", "Administrator Email (anyone with this email is automatically a team admin)")
+
+	DeleteTeamsCmd.Flags().Bool("confirm", false, "Confirm you really want to delete the team and a DB backup has been performed.")
+
+	TeamRenameCmd.Flags().String("display_name", "", "Team Display Name")
+
+	ModifyTeamCmd.Flags().Bool("private", false, "Convert the team to a private team")
+	ModifyTeamCmd.Flags().Bool("public", false, "Convert the team to a public team")
+
+	TeamCmd.AddCommand(
+		TeamCreateCmd,
+		RemoveUsersCmd,
+		AddUsersCmd,
+		DeleteTeamsCmd,
+		ListTeamsCmd,
+		SearchTeamCmd,
+		ArchiveTeamCmd,
+		RestoreTeamsCmd,
+		TeamRenameCmd,
+		ModifyTeamCmd,
+	)
+	RootCmd.AddCommand(TeamCmd)
+}
+
+func createTeamCmdF(command *cobra.Command, args []string) error {
+	a, err := InitDBCommandContextCobra(command)
+	if err != nil {
+		return err
+	}
+	defer a.Srv().Shutdown()
+
+	name, errn := command.Flags().GetString("name")
+	if errn != nil || name == "" {
+		return errors.New("Name is required")
+	}
+	displayname, errdn := command.Flags().GetString("display_name")
+	if errdn != nil || displayname == "" {
+		return errors.New("Display Name is required")
+	}
+	email, _ := command.Flags().GetString("email")
+	email = strings.ToLower(email)
+	useprivate, _ := command.Flags().GetBool("private")
+
+	teamType := model.TeamOpen
+	if useprivate {
+		teamType = model.TeamInvite
+	}
+
+	team := &model.Team{
+		Name:        name,
+		DisplayName: displayname,
+		Email:       email,
+		Type:        teamType,
+	}
+
+	createdTeam, errCreate := a.CreateTeam(&request.Context{}, team)
+	if errCreate != nil {
+		return errors.New("Team creation failed: " + errCreate.Error())
+	}
+
+	auditRec := a.MakeAuditRecord("createTeam", audit.Success)
+	auditRec.AddMeta("team", createdTeam)
+	a.LogAuditRec(auditRec, nil)
+
+	return nil
+}
+
+func removeUsersCmdF(command *cobra.Command, args []string) error {
+	a, err := InitDBCommandContextCobra(command)
+	if err != nil {
+		return err
+	}
+	defer a.Srv().Shutdown()
+
+	team := getTeamFromTeamArg(a, args[0])
+	if team == nil {
+		return errors.New("Unable to find team '" + args[0] + "'")
+	}
+
+	users := getUsersFromUserArgs(a, args[1:])
+	for i, user := range users {
+		removeUserFromTeam(a, team, user, args[i+1])
+	}
+
+	return nil
+}
+
+func removeUserFromTeam(a *app.App, team *model.Team, user *model.User, userArg string) {
+	if user == nil {
+		CommandPrintErrorln("Can't find user '" + userArg + "'")
+		return
+	}
+	if err := a.LeaveTeam(&request.Context{}, team, user, ""); err != nil {
+		CommandPrintErrorln("Unable to remove '" + userArg + "' from " + team.Name + ". Error: " + err.Error())
+		return
+	}
+
+	auditRec := a.MakeAuditRecord("removeUserFromTeam", audit.Success)
+	auditRec.AddMeta("user", user)
+	auditRec.AddMeta("team", team)
+	a.LogAuditRec(auditRec, nil)
+}
+
+func addUsersCmdF(command *cobra.Command, args []string) error {
+	a, err := InitDBCommandContextCobra(command)
+	if err != nil {
+		return err
+	}
+	defer a.Srv().Shutdown()
+
+	team := getTeamFromTeamArg(a, args[0])
+	if team == nil {
+		return errors.New("Unable to find team '" + args[0] + "'")
+	}
+
+	users := getUsersFromUserArgs(a, args[1:])
+	for i, user := range users {
+		addUserToTeam(a, team, user, args[i+1])
+	}
+	return nil
+}
+
+func addUserToTeam(a *app.App, team *model.Team, user *model.User, userArg string) {
+	if user == nil {
+		CommandPrintErrorln("Can't find user '" + userArg + "'")
+		return
+	}
+	if _, err := a.JoinUserToTeam(&request.Context{}, team, user, ""); err != nil {
+		CommandPrintErrorln("Unable to add '" + userArg + "' to " + team.Name)
+		return
+	}
+
+	auditRec := a.MakeAuditRecord("addUserToTeam", audit.Success)
+	auditRec.AddMeta("user", user)
+	auditRec.AddMeta("team", team)
+	a.LogAuditRec(auditRec, nil)
+}
+
+func deleteTeamsCmdF(command *cobra.Command, args []string) error {
+	a, err := InitDBCommandContextCobra(command)
+	if err != nil {
+		return err
+	}
+	defer a.Srv().Shutdown()
+
+	confirmFlag, _ := command.Flags().GetBool("confirm")
+	if !confirmFlag {
+		var confirm string
+		CommandPrettyPrintln("Have you performed a database backup? (YES/NO): ")
+		fmt.Scanln(&confirm)
+
+		if confirm != "YES" {
+			return errors.New("ABORTED: You did not answer YES exactly, in all capitals.")
+		}
+		CommandPrettyPrintln("Are you sure you want to delete the teams specified?  All data will be permanently deleted? (YES/NO): ")
+		fmt.Scanln(&confirm)
+		if confirm != "YES" {
+			return errors.New("ABORTED: You did not answer YES exactly, in all capitals.")
+		}
+	}
+
+	teams := getTeamsFromTeamArgs(a, args)
+	for i, team := range teams {
+		if team == nil {
+			CommandPrintErrorln("Unable to find team '" + args[i] + "'")
+			continue
+		}
+		if err := deleteTeam(a, team); err != nil {
+			CommandPrintErrorln("Unable to delete team '" + team.Name + "' error: " + err.Error())
+		} else {
+			CommandPrettyPrintln("Deleted team '" + team.Name + "'")
+
+			auditRec := a.MakeAuditRecord("deleteTeams", audit.Success)
+			auditRec.AddMeta("team", team)
+			a.LogAuditRec(auditRec, nil)
+
+			DefaultTeama := a.GetDefaultTeama(team.Id)
+			if DefaultTeama == 1 {
+				CommandPrettyPrintln("Default Teama delete : " + team.Name)
+				plugin := "plugindefaultteam"
+				if err := a.DisablePlugin(plugin); err != nil {
+					CommandPrintErrorln("Unable to disable plugin: " + plugin + ". Error: " + err.Error())
+				} else {
+					CommandPrettyPrintln("Disabled plugin: " + plugin)
+					auditRec := a.MakeAuditRecord("pluginDisable", audit.Success)
+					auditRec.AddMeta("plugin", plugin)
+					a.LogAuditRec(auditRec, nil)
+				}
+			}
+		}
+	}
+	return nil
+}
+
+func deleteTeam(a *app.App, team *model.Team) *model.AppError {
+	return a.PermanentDeleteTeam(nil, team)
+}
+
+func listTeamsCmdF(command *cobra.Command, args []string) error {
+	a, err := InitDBCommandContextCobra(command)
+	if err != nil {
+		return err
+	}
+	defer a.Srv().Shutdown()
+
+	teams, err2 := a.GetAllTeams()
+	if err2 != nil {
+		return err2
+	}
+
+	for _, team := range teams {
+		if team.DeleteAt > 0 {
+			CommandPrettyPrintln(team.Name + " (archived)")
+		} else {
+			CommandPrettyPrintln(team.Name)
+		}
+	}
+
+	return nil
+}
+
+func searchTeamCmdF(command *cobra.Command, args []string) error {
+	a, err := InitDBCommandContextCobra(command)
+	if err != nil {
+		return err
+	}
+	defer a.Srv().Shutdown()
+
+	var teams []*model.Team
+
+	for _, searchTerm := range args {
+		foundTeams, _, err := a.SearchAllTeams(&model.TeamSearch{Term: searchTerm})
+		if err != nil {
+			return err
+		}
+		teams = append(teams, foundTeams...)
+	}
+
+	sortedTeams := removeDuplicatesAndSortTeams(teams)
+
+	for _, team := range sortedTeams {
+		if team.DeleteAt > 0 {
+			CommandPrettyPrintln(team.Name + ": " + team.DisplayName + " (" + team.Id + ")" + " (archived)")
+		} else {
+			CommandPrettyPrintln(team.Name + ": " + team.DisplayName + " (" + team.Id + ")")
+		}
+	}
+
+	return nil
+}
+
+// Restores archived teams by name
+func restoreTeamsCmdF(command *cobra.Command, args []string) error {
+	a, err := InitDBCommandContextCobra(command)
+	if err != nil {
+		return err
+	}
+	defer a.Srv().Shutdown()
+	teams := getTeamsFromTeamArgs(a, args)
+	for i, team := range teams {
+		if team == nil {
+			CommandPrintErrorln("Unable to find team '" + args[i] + "'")
+			continue
+		}
+		err := a.RestoreTeam(team.Id)
+		if err != nil {
+			CommandPrintErrorln("Unable to restore team '" + team.Name + "' error: " + err.Error())
+		} else {
+			auditRec := a.MakeAuditRecord("restoreTeams", audit.Success)
+			auditRec.AddMeta("team", team)
+			a.LogAuditRec(auditRec, nil)
+		}
+	}
+	return nil
+}
+
+// Removes duplicates and sorts teams by name
+func removeDuplicatesAndSortTeams(teams []*model.Team) []*model.Team {
+	keys := make(map[string]bool)
+	result := []*model.Team{}
+	for _, team := range teams {
+		if _, value := keys[team.Name]; !value {
+			keys[team.Name] = true
+			result = append(result, team)
+		}
+	}
+	sort.Slice(result, func(i, j int) bool {
+		return result[i].Name < result[j].Name
+	})
+	return result
+}
+
+func archiveTeamCmdF(command *cobra.Command, args []string) error {
+	a, err := InitDBCommandContextCobra(command)
+	if err != nil {
+		return err
+	}
+	defer a.Srv().Shutdown()
+
+	foundTeams := getTeamsFromTeamArgs(a, args)
+	for i, team := range foundTeams {
+		if team == nil {
+			CommandPrintErrorln("Unable to find team '" + args[i] + "'")
+			continue
+		}
+		if err := a.SoftDeleteTeam(team.Id); err != nil {
+			CommandPrintErrorln("Unable to archive team '"+team.Name+"' error: ", err)
+		} else {
+			auditRec := a.MakeAuditRecord("archiveTeam", audit.Success)
+			auditRec.AddMeta("team", team)
+			a.LogAuditRec(auditRec, nil)
+		}
+	}
+	return nil
+}
+
+func renameTeamCmdF(command *cobra.Command, args []string) error {
+
+	a, err := InitDBCommandContextCobra(command)
+	if err != nil {
+		return err
+	}
+	defer a.Srv().Shutdown()
+
+	team := getTeamFromTeamArg(a, args[0])
+	if team == nil {
+		return errors.New("Unable to find team '" + args[0] + "'")
+	}
+
+	var newDisplayName, newTeamName string
+
+	newTeamName = args[1]
+
+	// let user use old team Name when only Display Name change is wanted
+	if newTeamName == team.Name {
+		newTeamName = "-"
+	}
+
+	newDisplayName, errdn := command.Flags().GetString("display_name")
+	if errdn != nil {
+		return errdn
+	}
+
+	updatedTeam, errrt := a.RenameTeam(team, newTeamName, newDisplayName)
+	if errrt != nil {
+		CommandPrintErrorln("Unable to rename team to '"+newTeamName+"' error: ", errrt)
+	}
+
+	auditRec := a.MakeAuditRecord("renameTeam", audit.Success)
+	auditRec.AddMeta("team", team)
+	auditRec.AddMeta("update", updatedTeam)
+	a.LogAuditRec(auditRec, nil)
+
+	return nil
+}
+
+func modifyTeamCmdF(command *cobra.Command, args []string) error {
+	a, err := InitDBCommandContextCobra(command)
+	if err != nil {
+		return err
+	}
+	defer a.Srv().Shutdown()
+
+	team := getTeamFromTeamArg(a, args[0])
+	if team == nil {
+		return errors.New("Unable to find team '" + args[0] + "'")
+	}
+
+	public, _ := command.Flags().GetBool("public")
+	private, _ := command.Flags().GetBool("private")
+
+	if public == private {
+		return errors.New("You must specify only one of --public or --private")
+	}
+
+	if public {
+		team.Type = model.TeamOpen
+		team.AllowOpenInvite = true
+	} else if private {
+		team.Type = model.TeamInvite
+		team.AllowOpenInvite = false
+	}
+
+	if err := a.UpdateTeamPrivacy(team.Id, team.Type, team.AllowOpenInvite); err != nil {
+		return errors.New("Failed to update privacy for team" + args[0])
+	}
+
+	auditRec := a.MakeAuditRecord("modifyTeam", audit.Success)
+	auditRec.AddMeta("team", team)
+	auditRec.AddMeta("type", team.Type)
+	auditRec.AddMeta("allow_open_invite", team.AllowOpenInvite)
+	a.LogAuditRec(auditRec, nil)
+
+	return nil
+}
+func getTeamsFromTeamArgs(a *app.App, teamArgs []string) []*model.Team {
+	teams := make([]*model.Team, 0, len(teamArgs))
+	for _, teamArg := range teamArgs {
+		team := getTeamFromTeamArg(a, teamArg)
+		teams = append(teams, team)
+	}
+	return teams
+}
+
+func getTeamFromTeamArg(a *app.App, teamArg string) *model.Team {
+	var team *model.Team
+	team, err := a.Srv().Store().Team().GetByName(teamArg)
+
+	if err != nil {
+		var t *model.Team
+		if t, err = a.Srv().Store().Team().Get(teamArg); err == nil {
+			team = t
+		}
+	}
+	return team
+}
+func getUsersFromUserArgs(a *app.App, userArgs []string) []*model.User {
+	users := make([]*model.User, 0, len(userArgs))
+	for _, userArg := range userArgs {
+		user := getUserFromUserArg(a, userArg)
+		users = append(users, user)
+	}
+	return users
+}
+
+func getUserFromUserArg(a *app.App, userArg string) *model.User {
+	user, _ := a.Srv().Store().User().GetByEmail(userArg)
+
+	if user == nil {
+		var err error
+		if user, err = a.Srv().Store().User().GetByUsername(userArg); err == nil {
+			return user
+		}
+	}
+
+	if user == nil {
+		user, _ = a.Srv().Store().User().Get(context.Background(), userArg)
+	}
+
+	return user
+}
Index: mattermost-server-7.8.1/config/client.go
===================================================================
--- mattermost-server-7.8.1/config/client.go	(revision 4484)
+++ mattermost-server-7.8.1/config/client.go	(revision 4485)
@@ -16,6 +16,7 @@
 	props := GenerateLimitedClientConfig(c, telemetryID, license)
 
 	props["EnableCustomUserStatuses"] = strconv.FormatBool(*c.TeamSettings.EnableCustomUserStatuses)
+	props["EnableMultiTenancySupport"] = strconv.FormatBool(*c.TeamSettings.EnableMultiTenancySupport)	
 	props["EnableLastActiveTime"] = strconv.FormatBool(*c.TeamSettings.EnableLastActiveTime)
 	props["EnableUserDeactivation"] = strconv.FormatBool(*c.TeamSettings.EnableUserDeactivation)
 	props["RestrictDirectMessage"] = *c.TeamSettings.RestrictDirectMessage
@@ -84,6 +85,9 @@
 
 	props["MaxNotificationsPerChannel"] = strconv.FormatInt(*c.TeamSettings.MaxNotificationsPerChannel, 10)
 	props["EnableConfirmNotificationsToChannel"] = strconv.FormatBool(*c.TeamSettings.EnableConfirmNotificationsToChannel)
+	/* Ryobi Systems CloudOffice Channel Mod 20210802 start */
+	props["EnableConfirmNotificationsToChannelUserCount"] = strconv.FormatInt(*c.TeamSettings.EnableConfirmNotificationsToChannelUserCount, 10)
+	/* Ryobi Systems CloudOffice Channel Mod 20210816 END */
 	props["TimeBetweenUserTypingUpdatesMilliseconds"] = strconv.FormatInt(*c.ServiceSettings.TimeBetweenUserTypingUpdatesMilliseconds, 10)
 	props["EnableUserTypingMessages"] = strconv.FormatBool(*c.ServiceSettings.EnableUserTypingMessages)
 	props["EnableChannelViewedMessages"] = strconv.FormatBool(*c.ServiceSettings.EnableChannelViewedMessages)
Index: mattermost-server-7.8.1/config/store.go
===================================================================
--- mattermost-server-7.8.1/config/store.go	(revision 4484)
+++ mattermost-server-7.8.1/config/store.go	(revision 4485)
@@ -155,6 +155,14 @@
 	return removeEnvOverrides(cfg, s.configNoEnv, s.GetEnvironmentOverrides())
 }
 
+// ReMulTotalSize change totalSize value in config.json
+// overrides.
+func (s *Store) ReMulTotalSize(totalSize float64) {
+	s.configLock.RLock()
+	defer s.configLock.RUnlock()
+	s.config.PluginSettings.Plugins["filepermissionsettingplugin"]["uploadedtotalsize"] = totalSize
+}
+
 // SetReadOnlyFF sets whether feature flags should be written out to
 // config or treated as read-only.
 func (s *Store) SetReadOnlyFF(readOnly bool) {
Index: mattermost-server-7.8.1/db/migrations/migrations.list
===================================================================
--- mattermost-server-7.8.1/db/migrations/migrations.list	(revision 4484)
+++ mattermost-server-7.8.1/db/migrations/migrations.list	(revision 4485)
@@ -202,6 +202,12 @@
 db/migrations/mysql/000100_add_draft_priority_column.up.sql
 db/migrations/mysql/000101_create_true_up_review_history.down.sql
 db/migrations/mysql/000101_create_true_up_review_history.up.sql
+db/migrations/mysql/000102_create_meetings.down.sql
+db/migrations/mysql/000102_create_meetings.up.sql
+db/migrations/mysql/000103_create_meeting_users.down.sql
+db/migrations/mysql/000103_create_meeting_users.up.sql
+db/migrations/mysql/000104_create_deleted_single_repeat_meetings.down.sql
+db/migrations/mysql/000104_create_deleted_single_repeat_meetings.up.sql
 db/migrations/postgres/000001_create_teams.down.sql
 db/migrations/postgres/000001_create_teams.up.sql
 db/migrations/postgres/000002_create_team_members.down.sql
Index: mattermost-server-7.8.1/db/migrations/mysql/000102_create_meetings.down.sql
===================================================================
--- mattermost-server-7.8.1/db/migrations/mysql/000102_create_meetings.down.sql	(nonexistent)
+++ mattermost-server-7.8.1/db/migrations/mysql/000102_create_meetings.down.sql	(revision 4485)
@@ -0,0 +1 @@
+DROP TABLE IF EXISTS Meetings;
Index: mattermost-server-7.8.1/db/migrations/mysql/000102_create_meetings.up.sql
===================================================================
--- mattermost-server-7.8.1/db/migrations/mysql/000102_create_meetings.up.sql	(nonexistent)
+++ mattermost-server-7.8.1/db/migrations/mysql/000102_create_meetings.up.sql	(revision 4485)
@@ -0,0 +1,21 @@
+CREATE TABLE IF NOT EXISTS Meetings
+(
+	MeetingItemId varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
+	ItemValid     tinyint(1) NULL DEFAULT NULL,
+	MeetingName   varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
+	MeetingId     varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
+	StartAt       bigint(20) NULL DEFAULT NULL,
+	EndAt         bigint(20) NULL DEFAULT NULL,
+	TimeZone      varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
+	HostId        varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
+	HostName      varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
+	CreateAt      bigint(20) NULL DEFAULT NULL,
+	IsRepeat      tinyint(1) NULL DEFAULT 0,
+	RepeatConfig  varchar(2550) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '',
+	RepeatEndDate bigint(20) NULL DEFAULT 0,
+	ICalUID       varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '',
+	PRIMARY KEY (`MeetingItemId`) USING BTREE,
+	INDEX           `idx_meetings_item_valid`(`ItemValid`) USING BTREE,
+	INDEX           `idx_meetings_start_at`(`StartAt`) USING BTREE,
+	INDEX           `idx_meetings_end_at`(`EndAt`) USING BTREE
+)ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
Index: mattermost-server-7.8.1/db/migrations/mysql/000103_create_meeting_users.down.sql
===================================================================
--- mattermost-server-7.8.1/db/migrations/mysql/000103_create_meeting_users.down.sql	(nonexistent)
+++ mattermost-server-7.8.1/db/migrations/mysql/000103_create_meeting_users.down.sql	(revision 4485)
@@ -0,0 +1 @@
+DROP TABLE IF EXISTS MeetingUsers;
Index: mattermost-server-7.8.1/db/migrations/mysql/000103_create_meeting_users.up.sql
===================================================================
--- mattermost-server-7.8.1/db/migrations/mysql/000103_create_meeting_users.up.sql	(nonexistent)
+++ mattermost-server-7.8.1/db/migrations/mysql/000103_create_meeting_users.up.sql	(revision 4485)
@@ -0,0 +1,12 @@
+CREATE TABLE IF NOT EXISTS MeetingUsers
+(
+	ItemId        varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
+	ItemValid     tinyint(1) NULL DEFAULT NULL,
+	MeetingItemId varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
+	UserId        varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
+	UserMail      varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
+	PRIMARY KEY (`ItemId`) USING BTREE,
+	INDEX           `idx_meeting_users_meeting_item_id`(`MeetingItemId`) USING BTREE,
+	INDEX           `idx_meeting_users_item_valid`(`ItemValid`) USING BTREE,
+	INDEX           `idx_meeting_users_user_mail`(`UserMail`) USING BTREE
+)ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
Index: mattermost-server-7.8.1/db/migrations/mysql/000104_create_deleted_single_repeat_meetings.down.sql
===================================================================
--- mattermost-server-7.8.1/db/migrations/mysql/000104_create_deleted_single_repeat_meetings.down.sql	(nonexistent)
+++ mattermost-server-7.8.1/db/migrations/mysql/000104_create_deleted_single_repeat_meetings.down.sql	(revision 4485)
@@ -0,0 +1 @@
+DROP TABLE IF EXISTS DeletedSingleRepeatMeetings;
Index: mattermost-server-7.8.1/db/migrations/mysql/000104_create_deleted_single_repeat_meetings.up.sql
===================================================================
--- mattermost-server-7.8.1/db/migrations/mysql/000104_create_deleted_single_repeat_meetings.up.sql	(nonexistent)
+++ mattermost-server-7.8.1/db/migrations/mysql/000104_create_deleted_single_repeat_meetings.up.sql	(revision 4485)
@@ -0,0 +1,8 @@
+CREATE TABLE IF NOT EXISTS DeletedSingleRepeatMeetings
+(
+	ItemId        varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
+	MeetingItemId varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
+	StartAt       bigint(20) NULL DEFAULT NULL,
+	EndAt         bigint(20) NULL DEFAULT NULL,
+	PRIMARY KEY (`ItemId`) USING BTREE
+)ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
Index: mattermost-server-7.8.1/db/migrations/mysql/000105_create_poll_fields.down.sql
===================================================================
--- mattermost-server-7.8.1/db/migrations/mysql/000105_create_poll_fields.down.sql	(nonexistent)
+++ mattermost-server-7.8.1/db/migrations/mysql/000105_create_poll_fields.down.sql	(revision 4485)
@@ -0,0 +1 @@
+DROP TABLE IF EXISTS Poll_Fields;
Index: mattermost-server-7.8.1/db/migrations/mysql/000105_create_poll_fields.up.sql
===================================================================
--- mattermost-server-7.8.1/db/migrations/mysql/000105_create_poll_fields.up.sql	(nonexistent)
+++ mattermost-server-7.8.1/db/migrations/mysql/000105_create_poll_fields.up.sql	(revision 4485)
@@ -0,0 +1,11 @@
+CREATE TABLE IF NOT EXISTS Poll_Fields
+(
+	Id     int(11) NOT NULL AUTO_INCREMENT,
+	PostId varchar(26)  DEFAULT NULL,
+	Voter  varchar(255) DEFAULT NULL,
+	Answer text,
+	UserId varchar(26)  DEFAULT NULL,
+	PRIMARY KEY (`Id`),
+	KEY      `idx_poll_fields_post_id` (`PostId`)
+) ENGINE=InnoDB AUTO_INCREMENT=54 DEFAULT CHARSET=utf8mb4
+
Index: mattermost-server-7.8.1/db/migrations/mysql/000106_create_meetings_end.down.sql
===================================================================
--- mattermost-server-7.8.1/db/migrations/mysql/000106_create_meetings_end.down.sql	(nonexistent)
+++ mattermost-server-7.8.1/db/migrations/mysql/000106_create_meetings_end.down.sql	(revision 4485)
@@ -0,0 +1 @@
+DROP TABLE IF EXISTS MeetingsEnd;
Index: mattermost-server-7.8.1/db/migrations/mysql/000106_create_meetings_end.up.sql
===================================================================
--- mattermost-server-7.8.1/db/migrations/mysql/000106_create_meetings_end.up.sql	(nonexistent)
+++ mattermost-server-7.8.1/db/migrations/mysql/000106_create_meetings_end.up.sql	(revision 4485)
@@ -0,0 +1,13 @@
+CREATE TABLE IF NOT EXISTS MeetingsEnd
+(
+	Id               int(11) NOT NULL AUTO_INCREMENT,
+	MeetingItemId    varchar(255) DEFAULT NULL,
+	MeetingStartTime bigint(20) DEFAULT NULL,
+	SumMemberCount   int(11) DEFAULT NULL,
+	UserMail         varchar(255) DEFAULT NULL,
+	MeetingEndTime   bigint(20) DEFAULT NULL,
+	PRIMARY KEY (`Id`),
+	KEY                `idx_meeting_end_meetingitem_id` (`MeetingItemId`),
+	KEY                `idx_meeting_end_meetingitem_starttime` (`MeetingStartTime`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
+
Index: mattermost-server-7.8.1/db/migrations/mysql/000107_create_meeting_end_users.down.sql
===================================================================
--- mattermost-server-7.8.1/db/migrations/mysql/000107_create_meeting_end_users.down.sql	(nonexistent)
+++ mattermost-server-7.8.1/db/migrations/mysql/000107_create_meeting_end_users.down.sql	(revision 4485)
@@ -0,0 +1 @@
+DROP TABLE IF EXISTS MeetingEndUsers;
Index: mattermost-server-7.8.1/db/migrations/mysql/000107_create_meeting_end_users.up.sql
===================================================================
--- mattermost-server-7.8.1/db/migrations/mysql/000107_create_meeting_end_users.up.sql	(nonexistent)
+++ mattermost-server-7.8.1/db/migrations/mysql/000107_create_meeting_end_users.up.sql	(revision 4485)
@@ -0,0 +1,16 @@
+CREATE TABLE IF NOT EXISTS MeetingEndUsers
+(
+	Id               int(11) NOT NULL AUTO_INCREMENT,
+	MeetingItemId    varchar(255) DEFAULT NULL,
+	MeetingStartTime bigint(20) DEFAULT NULL,
+	UserMail         varchar(255) DEFAULT NULL,
+	Owner            tinyint(1) DEFAULT NULL,
+	RemoteIp         varchar(50)  DEFAULT NULL,
+	LocalIp          varchar(50)  DEFAULT NULL,
+	StartTime        bigint(20) DEFAULT NULL,
+	EndTime          bigint(20) DEFAULT NULL,
+	PRIMARY KEY (`Id`),
+	KEY                `idx_meeting_end_user_meetingitem_id` (`MeetingItemId`),
+	KEY                `idx_meeting_end_user_meetingitem_starttime` (`MeetingStartTime`),
+	KEY                `idx_meeting_end_user_user_mail` (`UserMail`)
+) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4
Index: mattermost-server-7.8.1/db/migrations/mysql/000108_create_default_team.down.sql
===================================================================
--- mattermost-server-7.8.1/db/migrations/mysql/000108_create_default_team.down.sql	(nonexistent)
+++ mattermost-server-7.8.1/db/migrations/mysql/000108_create_default_team.down.sql	(revision 4485)
@@ -0,0 +1 @@
+DROP TABLE IF EXISTS DefaultTeam;
Index: mattermost-server-7.8.1/db/migrations/mysql/000108_create_default_team.up.sql
===================================================================
--- mattermost-server-7.8.1/db/migrations/mysql/000108_create_default_team.up.sql	(nonexistent)
+++ mattermost-server-7.8.1/db/migrations/mysql/000108_create_default_team.up.sql	(revision 4485)
@@ -0,0 +1,10 @@
+CREATE TABLE IF NOT EXISTS DefaultTeam
+(
+	Id       varchar(26) NOT NULL,
+	CreateAt bigint(20) DEFAULT NULL,
+	UpdateAt bigint(20) DEFAULT NULL,
+	PRIMARY KEY (`Id`),
+	KEY        `idx_teams_update_at` (`UpdateAt`),
+	KEY        `idx_teams_create_at` (`CreateAt`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
+
Index: mattermost-server-7.8.1/db/migrations/mysql/000109_create_channel_chat_save_settings.down.sql
===================================================================
--- mattermost-server-7.8.1/db/migrations/mysql/000109_create_channel_chat_save_settings.down.sql	(nonexistent)
+++ mattermost-server-7.8.1/db/migrations/mysql/000109_create_channel_chat_save_settings.down.sql	(revision 4485)
@@ -0,0 +1 @@
+DROP TABLE IF EXISTS ChannelChatSaveSettings;
Index: mattermost-server-7.8.1/db/migrations/mysql/000109_create_channel_chat_save_settings.up.sql
===================================================================
--- mattermost-server-7.8.1/db/migrations/mysql/000109_create_channel_chat_save_settings.up.sql	(nonexistent)
+++ mattermost-server-7.8.1/db/migrations/mysql/000109_create_channel_chat_save_settings.up.sql	(revision 4485)
@@ -0,0 +1,20 @@
+CREATE TABLE IF NOT EXISTS ChannelChatSaveSettings
+(
+	Id                int(11) NOT NULL AUTO_INCREMENT,
+	CreatorId         varchar(26) DEFAULT NULL,
+	CreateAt          bigint(20) DEFAULT NULL,
+	UpdatorId         varchar(26) DEFAULT NULL,
+	UpdateAt          bigint(20) DEFAULT NULL,
+	ChannelId         varchar(26) DEFAULT NULL,
+	MessagePermission tinyint(1) DEFAULT NULL,
+	MessageTime       bigint(20) DEFAULT NULL,
+	MessageUtil       varchar(26) DEFAULT NULL,
+	FilePermission    tinyint(1) DEFAULT NULL,
+	FileTime          bigint(20) DEFAULT NULL,
+	FileUtil          varchar(26) DEFAULT NULL,
+	ShowUserSettings   tinyint(1) DEFAULT NULL,
+	ShowUserFileSettings tinyint(1) DEFAULT NULL,
+	PRIMARY KEY (`Id`),
+	KEY                 `idx_channel_chat_save_settings_cron_id` (`ChannelId`)
+) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8mb4
+
Index: mattermost-server-7.8.1/db/migrations/mysql/000110_create_cron_settings.down.sql
===================================================================
--- mattermost-server-7.8.1/db/migrations/mysql/000110_create_cron_settings.down.sql	(nonexistent)
+++ mattermost-server-7.8.1/db/migrations/mysql/000110_create_cron_settings.down.sql	(revision 4485)
@@ -0,0 +1 @@
+DROP TABLE IF EXISTS CronSettings;
Index: mattermost-server-7.8.1/db/migrations/mysql/000110_create_cron_settings.up.sql
===================================================================
--- mattermost-server-7.8.1/db/migrations/mysql/000110_create_cron_settings.up.sql	(nonexistent)
+++ mattermost-server-7.8.1/db/migrations/mysql/000110_create_cron_settings.up.sql	(revision 4485)
@@ -0,0 +1,13 @@
+CREATE TABLE IF NOT EXISTS CronSettings
+(
+	Id       int(11) NOT NULL AUTO_INCREMENT,
+	CronId   int(11) DEFAULT NULL,
+	Spec     varchar(26) DEFAULT NULL,
+	CreateAt bigint(20) DEFAULT NULL,
+	DeleteAt bigint(20) DEFAULT '0',
+	UpdateAt bigint(20) DEFAULT NULL,
+	PRIMARY KEY (`Id`),
+	KEY        `idx_cron_settings_cron_id` (`CronId`),
+	KEY        `idx_cron_settings_delete_at` (`DeleteAt`)
+) ENGINE=InnoDB AUTO_INCREMENT=529 DEFAULT CHARSET=utf8mb4
+
Index: mattermost-server-7.8.1/go.mod
===================================================================
--- mattermost-server-7.8.1/go.mod	(revision 4484)
+++ mattermost-server-7.8.1/go.mod	(revision 4485)
@@ -5,6 +5,7 @@
 require (
 	code.sajari.com/docconv v1.3.5
 	github.com/Masterminds/semver/v3 v3.2.0
+	github.com/Masterminds/squirrel v1.5.3
 	github.com/avct/uasurfer v0.0.0-20191028135549-26b5daa857f1
 	github.com/aws/aws-sdk-go v1.44.173
 	github.com/blang/semver v3.5.1+incompatible
@@ -16,6 +17,7 @@
 	github.com/dyatlov/go-opengraph/opengraph v0.0.0-20220524092352-606d7b1e5f8a
 	github.com/francoispqt/gojay v1.2.13
 	github.com/fsnotify/fsnotify v1.6.0
+	github.com/garyburd/redigo v0.0.0-20150301180006-535138d7bcd7
 	github.com/getsentry/sentry-go v0.16.0
 	github.com/go-sql-driver/mysql v1.7.0
 	github.com/golang-migrate/migrate/v4 v4.15.2
@@ -49,6 +51,7 @@
 	github.com/pborman/uuid v1.2.1
 	github.com/pkg/errors v0.9.1
 	github.com/reflog/dateconstraints v0.2.1
+	github.com/robfig/cron v1.2.0
 	github.com/rs/cors v1.8.3
 	github.com/rudderlabs/analytics-go v3.3.3+incompatible
 	github.com/rwcarlsen/goexif v0.0.0-20190401172101-9e8deecbddbd
Index: mattermost-server-7.8.1/go.sum
===================================================================
--- mattermost-server-7.8.1/go.sum	(revision 4484)
+++ mattermost-server-7.8.1/go.sum	(revision 4485)
@@ -94,6 +94,8 @@
 github.com/JalfResi/justext v0.0.0-20221106200834-be571e3e3052/go.mod h1:0SURuH1rsE8aVWvutuMZghRNrNrYEUzibzJfhEYR8L0=
 github.com/Masterminds/semver/v3 v3.2.0 h1:3MEsd0SM6jqZojhjLWWeBY+Kcjy9i6MQAeY7YgDP83g=
 github.com/Masterminds/semver/v3 v3.2.0/go.mod h1:qvl/7zhW3nngYb5+80sSMF+FG2BjYrf8m9wsX0PNOMQ=
+github.com/Masterminds/squirrel v1.5.3 h1:YPpoceAcxuzIljlr5iWpNKaql7hLeG1KLSrhvdHpkZc=
+github.com/Masterminds/squirrel v1.5.3/go.mod h1:NNaOrjSoIDfDA40n7sr2tPNZRfjzjA400rg+riTZj10=
 github.com/Microsoft/go-winio v0.4.11/go.mod h1:VhR8bwka0BXejwEJY73c50VrPtXAaKcyvVC4A4RozmA=
 github.com/Microsoft/go-winio v0.4.14/go.mod h1:qXqCSQ3Xa7+6tgxaGTIe4Kpcdsi+P8jBhyzoq1bpyYA=
 github.com/Microsoft/go-winio v0.4.15-0.20190919025122-fc70bd9a86b5/go.mod h1:tTuCMEN+UleMWgg9dVx4Hu52b1bJo+59jBh3ajtinzw=
@@ -516,6 +518,7 @@
 github.com/fullsailor/pkcs7 v0.0.0-20190404230743-d7302db945fa/go.mod h1:KnogPXtdwXqoenmZCw6S+25EAm2MkxbG0deNDu4cbSA=
 github.com/gabriel-vasile/mimetype v1.3.1/go.mod h1:fA8fi6KUiG7MgQQ+mEWotXoEOvmxRtOJlERCzSmRvr8=
 github.com/gabriel-vasile/mimetype v1.4.0/go.mod h1:fA8fi6KUiG7MgQQ+mEWotXoEOvmxRtOJlERCzSmRvr8=
+github.com/garyburd/redigo v0.0.0-20150301180006-535138d7bcd7 h1:LofdAjjjqCSXMwLGgOgnE+rdPuvX9DxCqaHwKy7i/ko=
 github.com/garyburd/redigo v0.0.0-20150301180006-535138d7bcd7/go.mod h1:NR3MbYisc3/PwhQ00EMzDiPmrwpPxAn5GI05/YaO1SY=
 github.com/getsentry/raven-go v0.2.0/go.mod h1:KungGk8q33+aIAZUIVWZDr2OfAEBsO49PX4NzFV5kcQ=
 github.com/getsentry/sentry-go v0.16.0 h1:owk+S+5XcgJLlGR/3+3s6N4d+uKwqYvh/eS0AIMjPWo=
@@ -1269,6 +1272,8 @@
 github.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=
 github.com/rivo/uniseg v0.4.3 h1:utMvzDsuh3suAEnhH0RdHmoPbU648o6CvXxTx4SBMOw=
 github.com/rivo/uniseg v0.4.3/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=
+github.com/robfig/cron v1.2.0 h1:ZjScXvvxeQ63Dbyxy76Fj3AT3Ut0aKsyd2/tl3DTMuQ=
+github.com/robfig/cron v1.2.0/go.mod h1:JGuDeoQd7Z6yL4zQhZ3OPEVHB7fL6Ka6skscFHfmt2k=
 github.com/rogpeppe/fastuuid v0.0.0-20150106093220-6724a57986af/go.mod h1:XWv6SoW27p1b0cqNHllgS5HIMJraePCO15w5zCzIWYg=
 github.com/rogpeppe/fastuuid v1.2.0/go.mod h1:jVj6XXZzXRy/MSR5jhDC/2q6DgLz+nrA6LYCDYWNEvQ=
 github.com/rogpeppe/go-internal v1.1.0/go.mod h1:M8bDsm7K2OlrFYOpmOWEs/qY81heoFRclV5y23lUDJ4=
Index: mattermost-server-7.8.1/i18n/en.json
===================================================================
--- mattermost-server-7.8.1/i18n/en.json	(revision 4484)
+++ mattermost-server-7.8.1/i18n/en.json	(revision 4485)
@@ -165,7 +165,7 @@
   },
   {
     "id": "api.admin.test_email.body",
-    "translation": "It appears your Mattermost email is setup correctly!"
+    "translation": "It appears your RS-CloudOffice email is setup correctly!"
   },
   {
     "id": "api.admin.test_email.missing_server",
@@ -177,7 +177,7 @@
   },
   {
     "id": "api.admin.test_email.subject",
-    "translation": "Mattermost - Testing Email Settings"
+    "translation": "RS-CloudOffice - Testing Email Settings"
   },
   {
     "id": "api.admin.test_s3.missing_s3_bucket",
@@ -213,7 +213,7 @@
   },
   {
     "id": "api.bot.teams_channels.add_message_mobile",
-    "translation": "Please add me to teams and channels you want me to interact in. To do this, use the browser or Mattermost Desktop App."
+    "translation": "Please add me to teams and channels you want me to interact in. To do this, use the browser."
   },
   {
     "id": "api.channel.add_guest.added",
@@ -553,7 +553,7 @@
   },
   {
     "id": "api.command.invite_people.desc",
-    "translation": "Send an email invite to your Mattermost team"
+    "translation": "Send an email invite to your RS-CloudOffice team"
   },
   {
     "id": "api.command.invite_people.email_invitations_off",
@@ -980,7 +980,7 @@
   },
   {
     "id": "api.command_logout.desc",
-    "translation": "Logout of Mattermost"
+    "translation": "Logout of RS-CloudOffice"
   },
   {
     "id": "api.command_logout.name",
@@ -1099,6 +1099,14 @@
     "translation": "online"
   },
   {
+    "id": "api.command_meeting.desc",
+    "translation": "Set your status to Web conference"
+  },
+  {
+    "id": "api.command_meeting.name",
+    "translation": "In Web conference"
+  },
+  {
     "id": "api.command_online.success",
     "translation": "You are now online"
   },
@@ -1108,7 +1116,7 @@
   },
   {
     "id": "api.command_remote.accept.help",
-    "translation": "Accept an invitation from an external Mattermost instance"
+    "translation": "Accept an invitation from an external RS-CloudOffice instance"
   },
   {
     "id": "api.command_remote.accept_invitation",
@@ -1132,7 +1140,7 @@
   },
   {
     "id": "api.command_remote.desc",
-    "translation": "Invite secure connections for communication across Mattermost instances."
+    "translation": "Invite secure connections for communication across RS-CloudOffice instances."
   },
   {
     "id": "api.command_remote.displayname.help",
@@ -1184,7 +1192,7 @@
   },
   {
     "id": "api.command_remote.invite_summary",
-    "translation": "Send the following AES 256-bit encrypted invitation to the external Mattermost System Admin along with the password. They will use the `{{.Command}}` slash command to accept the invitation.\n\n```\n{{.Invitation}}\n```\n\n**Ensure the secure connection can access your Mattermost instance via** {{.SiteURL}}"
+    "translation": "Send the following AES 256-bit encrypted invitation to the external RS-CloudOffice System Admin along with the password. They will use the `{{.Command}}` slash command to accept the invitation.\n\n```\n{{.Invitation}}\n```\n\n**Ensure the secure connection can access your RS-CloudOffice instance via** {{.SiteURL}}"
   },
   {
     "id": "api.command_remote.missing_command",
@@ -1356,7 +1364,7 @@
   },
   {
     "id": "api.command_share.desc",
-    "translation": "Shares the current channel with an external Mattermost instance."
+    "translation": "Shares the current channel with an external RS-CloudOffice instance."
   },
   {
     "id": "api.command_share.fetch_remote.error",
@@ -1380,7 +1388,7 @@
   },
   {
     "id": "api.command_share.invite_remote.help",
-    "translation": "Invites an external Mattermost instance to the current shared channel"
+    "translation": "Invites an external RS-CloudOffice instance to the current shared channel"
   },
   {
     "id": "api.command_share.missing_action",
@@ -1676,7 +1684,7 @@
   },
   {
     "id": "api.email_batching.send_batched_email_notification.button",
-    "translation": "Open Mattermost"
+    "translation": "Open RS-CloudOffice"
   },
   {
     "id": "api.email_batching.send_batched_email_notification.messageButton",
@@ -2649,7 +2657,7 @@
   },
   {
     "id": "api.server.warn_metric.bot_response.notification_success.message",
-    "translation": "Thank you for contacting Mattermost. We will follow up with you soon."
+    "translation": "Thank you for contacting RS-CloudOffice. We will follow up with you soon."
   },
   {
     "id": "api.server.warn_metric.bot_response.start_trial_failure.message",
@@ -2657,11 +2665,11 @@
   },
   {
     "id": "api.server.warn_metric.email_domain.contact_us.email_body",
-    "translation": "Mattermost contact us request. I'm interested in learning more about using Guest Accounts.\r\n"
+    "translation": "RS-CloudOffice contact us request. I'm interested in learning more about using Guest Accounts.\r\n"
   },
   {
     "id": "api.server.warn_metric.email_domain.notification_body",
-    "translation": "Projects often involve people both inside and outside of an organization. With Guest Accounts, you can bring external partners into your Mattermost system and specify who they can work with and what they can see.\r\n\r\n[Learn more about enabling Guest Accounts](https://www.mattermost.com/docs-guest-accounts/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=guest-accounts).\r\n\r\nBy clicking Contact Us, you'll be sharing your information with Mattermost, Inc. [Learn more](https://mattermost.com/pl/default-admin-advisory)"
+    "translation": "Projects often involve people both inside and outside of an organization. With Guest Accounts, you can bring external partners into your RS-CloudOffice system and specify who they can work with and what they can see.\r\n\r\n[Learn more about enabling Guest Accounts](https://www.mattermost.com/docs-guest-accounts/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=guest-accounts).\r\n\r\nBy clicking Contact Us, you'll be sharing your information with Mattermost, Inc. [Learn more](https://mattermost.com/pl/default-admin-advisory)"
   },
   {
     "id": "api.server.warn_metric.email_domain.notification_title",
@@ -2669,7 +2677,7 @@
   },
   {
     "id": "api.server.warn_metric.email_domain.start_trial.notification_body",
-    "translation": "Projects often involve people both inside and outside of an organization. With Guest Accounts, you can bring external partners into your Mattermost system and specify who they can work with and what they can see.\r\n\r\n[Learn more about enabling Guest Accounts](https://www.mattermost.com/docs-guest-accounts/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=guest-accounts)\r\n\r\nBy clicking Start trial, I agree to the [Mattermost Software Evaluation Agreement](https://mattermost.com/software-evaluation-agreement/), [Privacy Policy](https://mattermost.com/privacy-policy/), and receiving product emails."
+    "translation": "Projects often involve people both inside and outside of an organization. With Guest Accounts, you can bring external partners into your RS-CloudOffice system and specify who they can work with and what they can see.\r\n\r\n[Learn more about enabling Guest Accounts](https://www.mattermost.com/docs-guest-accounts/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=guest-accounts)\r\n\r\nBy clicking Start trial, I agree to the [Mattermost Software Evaluation Agreement](https://mattermost.com/software-evaluation-agreement/), [Privacy Policy](https://mattermost.com/privacy-policy/), and receiving product emails."
   },
   {
     "id": "api.server.warn_metric.email_domain.start_trial_notification_success.message",
@@ -2681,11 +2689,11 @@
   },
   {
     "id": "api.server.warn_metric.mfa.contact_us.email_body",
-    "translation": "Mattermost contact us request. I'm interested in learning more about enforcing Multi-Factor Authentication.\r\n"
+    "translation": "RS-CloudOffice contact us request. I'm interested in learning more about enforcing Multi-Factor Authentication.\r\n"
   },
   {
     "id": "api.server.warn_metric.mfa.notification_body",
-    "translation": "Your Mattermost system has multi-factor authentication enabled, giving users the choice to secure their accounts with additional means of authentication beyond a password. To improve security across the system you can require all Mattermost accounts to use multi-factor authentication.\r\n\r\n[Learn more about enforcing Multi-Factor Authentication](https://www.mattermost.com/docs-multi-factor-authentication/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=multi-factor-authentication). \r\n\r\nBy clicking Contact Us, you'll be sharing your information with Mattermost, Inc. [Learn more](https://mattermost.com/pl/default-admin-advisory)"
+    "translation": "Your RS-CloudOffice system has multi-factor authentication enabled, giving users the choice to secure their accounts with additional means of authentication beyond a password. To improve security across the system you can require all RS-CloudOffice accounts to use multi-factor authentication.\r\n\r\n[Learn more about enforcing Multi-Factor Authentication](https://www.mattermost.com/docs-multi-factor-authentication/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=multi-factor-authentication). \r\n\r\nBy clicking Contact Us, you'll be sharing your information with Mattermost, Inc. [Learn more](https://mattermost.com/pl/default-admin-advisory)"
   },
   {
     "id": "api.server.warn_metric.mfa.notification_title",
@@ -2693,7 +2701,7 @@
   },
   {
     "id": "api.server.warn_metric.mfa.start_trial.notification_body",
-    "translation": "Your Mattermost system has multi-factor authentication enabled, giving users the choice to secure their accounts with additional means of authentication beyond a password. To improve security across the system you can require all Mattermost accounts to use multi-factor authentication.\r\n\r\n[Learn more about enforcing Multi-Factor Authentication](https://www.mattermost.com/docs-multi-factor-authentication/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=multi-factor-authentication)\r\n\r\nBy clicking Start trial, I agree to the [Mattermost Software Evaluation Agreement](https://mattermost.com/software-evaluation-agreement/), [Privacy Policy](https://mattermost.com/privacy-policy/), and receiving product emails."
+    "translation": "Your RS-CloudOffice system has multi-factor authentication enabled, giving users the choice to secure their accounts with additional means of authentication beyond a password. To improve security across the system you can require all RS-CloudOffice accounts to use multi-factor authentication.\r\n\r\n[Learn more about enforcing Multi-Factor Authentication](https://www.mattermost.com/docs-multi-factor-authentication/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=multi-factor-authentication)\r\n\r\nBy clicking Start trial, I agree to the [Mattermost Software Evaluation Agreement](https://mattermost.com/software-evaluation-agreement/), [Privacy Policy](https://mattermost.com/privacy-policy/), and receiving product emails."
   },
   {
     "id": "api.server.warn_metric.mfa.start_trial_notification_success.message",
@@ -2701,19 +2709,19 @@
   },
   {
     "id": "api.server.warn_metric.number_of_active_users_100.contact_us.email_body",
-    "translation": "Mattermost contact us request. My team now has 100 users, and I'm considering Mattermost Enterprise Edition.\r\n"
+    "translation": "RS-CloudOffice contact us request. My team now has 100 users, and I'm considering Mattermost Enterprise Edition.\r\n"
   },
   {
     "id": "api.server.warn_metric.number_of_active_users_100.notification_body",
-    "translation": "Your Mattermost system has over 100 users. As your user base grows, provisioning new accounts can become time-consuming. We recommend that you integrate your organization’s Active Directory/LDAP, which will allow anyone with an account to access Mattermost.\r\n\r\n[Learn more about integrating with AD/LDAP](https://www.mattermost.com/docs-adldap/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=adldap)\r\n\r\nBy clicking Contact Us, you'll be sharing your information with Mattermost, Inc. [Learn more](https://mattermost.com/pl/default-admin-advisory)"
+    "translation": "Your RS-CloudOffice system has over 100 users. As your user base grows, provisioning new accounts can become time-consuming. We recommend that you integrate your organization’s Active Directory/LDAP, which will allow anyone with an account to access RS-CloudOffice.\r\n\r\n[Learn more about integrating with AD/LDAP](https://www.mattermost.com/docs-adldap/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=adldap)\r\n\r\nBy clicking Contact Us, you'll be sharing your information with Mattermost, Inc. [Learn more](https://mattermost.com/pl/default-admin-advisory)"
   },
   {
     "id": "api.server.warn_metric.number_of_active_users_100.notification_title",
-    "translation": "Scaling with Mattermost"
+    "translation": "Scaling with RS-CloudOffice"
   },
   {
     "id": "api.server.warn_metric.number_of_active_users_100.start_trial.notification_body",
-    "translation": "Your Mattermost system has over 100 users. As your user base grows, provisioning new accounts can become time-consuming. We recommend that you integrate your organization’s Active Directory/LDAP, which will allow anyone with an account to access Mattermost.\r\n\r\n[Learn more about integrating with AD/LDAP](https://www.mattermost.com/docs-adldap/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=adldap)\r\n\r\nBy clicking Start trial, I agree to the [Mattermost Software Evaluation Agreement](https://mattermost.com/software-evaluation-agreement/), [Privacy Policy](https://mattermost.com/privacy-policy/), and receiving product emails."
+    "translation": "Your RS-CloudOffice system has over 100 users. As your user base grows, provisioning new accounts can become time-consuming. We recommend that you integrate your organization’s Active Directory/LDAP, which will allow anyone with an account to access RS-CloudOffice.\r\n\r\n[Learn more about integrating with AD/LDAP](https://www.mattermost.com/docs-adldap/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=adldap)\r\n\r\nBy clicking Start trial, I agree to the [Mattermost Software Evaluation Agreement](https://mattermost.com/software-evaluation-agreement/), [Privacy Policy](https://mattermost.com/privacy-policy/), and receiving product emails."
   },
   {
     "id": "api.server.warn_metric.number_of_active_users_100.start_trial.notification_success.message",
@@ -2721,19 +2729,19 @@
   },
   {
     "id": "api.server.warn_metric.number_of_active_users_200.contact_us.email_body",
-    "translation": "Mattermost contact us request. My team now has 200 users, and I'm considering Mattermost Enterprise Edition.\r\n"
+    "translation": "RS-CloudOffice contact us request. My team now has 200 users, and I'm considering Mattermost Enterprise Edition.\r\n"
   },
   {
     "id": "api.server.warn_metric.number_of_active_users_200.notification_body",
-    "translation": "Your Mattermost system now has 200 users. When you connect Mattermost with your organization's single sign-on provider, users can access Mattermost without having to re-enter their credentials. We recommend you integrate your SAML 2.0 provider with your Mattermost server.[Learn more about integrating with SAML 2.0](https://www.mattermost.com/docs-saml/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=saml).\r\n\r\nBy clicking Contact Us, you'll be sharing your information with Mattermost, Inc. [Learn more](https://mattermost.com/pl/default-admin-advisory)"
+    "translation": "Your RS-CloudOffice system now has 200 users. When you connect RS-CloudOffice with your organization's single sign-on provider, users can access RS-CloudOffice without having to re-enter their credentials. We recommend you integrate your SAML 2.0 provider with your RS-CloudOffice server.[Learn more about integrating with SAML 2.0](https://www.mattermost.com/docs-saml/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=saml).\r\n\r\nBy clicking Contact Us, you'll be sharing your information with Mattermost, Inc. [Learn more](https://mattermost.com/pl/default-admin-advisory)"
   },
   {
     "id": "api.server.warn_metric.number_of_active_users_200.notification_title",
-    "translation": "Scaling with Mattermost"
+    "translation": "Scaling with RS-CloudOffice"
   },
   {
     "id": "api.server.warn_metric.number_of_active_users_200.start_trial.notification_body",
-    "translation": "Your Mattermost system now has 200 users. When you connect Mattermost with your organization's single sign-on provider, users can access Mattermost without having to re-enter their credentials. We recommend you integrate your SAML 2.0 provider with your Mattermost server.[Learn more about integrating with SAML 2.0](https://www.mattermost.com/docs-saml/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=saml)\r\n\r\nBy clicking Start trial, I agree to the [Mattermost Software Evaluation Agreement](https://mattermost.com/software-evaluation-agreement/), [Privacy Policy](https://mattermost.com/privacy-policy/), and receiving product emails."
+    "translation": "Your RS-CloudOffice system now has 200 users. When you connect RS-CloudOffice with your organization's single sign-on provider, users can access RS-CloudOffice without having to re-enter their credentials. We recommend you integrate your SAML 2.0 provider with your RS-CloudOffice server.[Learn more about integrating with SAML 2.0](https://www.mattermost.com/docs-saml/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=saml)\r\n\r\nBy clicking Start trial, I agree to the [Mattermost Software Evaluation Agreement](https://mattermost.com/software-evaluation-agreement/), [Privacy Policy](https://mattermost.com/privacy-policy/), and receiving product emails."
   },
   {
     "id": "api.server.warn_metric.number_of_active_users_200.start_trial.notification_success.message",
@@ -2741,15 +2749,15 @@
   },
   {
     "id": "api.server.warn_metric.number_of_active_users_300.contact_us.email_body",
-    "translation": "Mattermost contact us request. I'm interested in learning more about creating read-only Announcement Channels.\r\n"
+    "translation": "RS-CloudOffice contact us request. I'm interested in learning more about creating read-only Announcement Channels.\r\n"
   },
   {
     "id": "api.server.warn_metric.number_of_active_users_300.notification_body",
-    "translation": "With so much conversation happening across Mattermost, it can be challenging to know where to look for important information. If you want to broadcast a message to a large audience, you can set up read-only Announcement Channels where anyone can join but only channel admins can post messages.\r\n\r\n[Learn more about creating read-only Announcement Channels](https://www.mattermost.com/docs-channel-moderation/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=channel-moderation)\r\n\r\nBy clicking Contact Us, you'll be sharing your information with Mattermost, Inc. [Learn more](https://mattermost.com/pl/default-admin-advisory)"
+    "translation": "With so much conversation happening across RS-CloudOffice, it can be challenging to know where to look for important information. If you want to broadcast a message to a large audience, you can set up read-only Announcement Channels where anyone can join but only channel admins can post messages.\r\n\r\n[Learn more about creating read-only Announcement Channels](https://www.mattermost.com/docs-channel-moderation/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=channel-moderation)\r\n\r\nBy clicking Contact Us, you'll be sharing your information with Mattermost, Inc. [Learn more](https://mattermost.com/pl/default-admin-advisory)"
   },
   {
     "id": "api.server.warn_metric.number_of_active_users_300.start_trial.notification_body",
-    "translation": "With so much conversation happening across Mattermost, it can be challenging to know where to look for important information. If you want to broadcast a message to a large audience, you can set up read-only Announcement Channels where anyone can join but only channel admins can post messages.\r\n\r\n[Learn more about creating read-only Announcement Channels](https://www.mattermost.com/docs-channel-moderation/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=channel-moderation)\r\n\r\nBy clicking Start trial, I agree to the [Mattermost Software Evaluation Agreement](https://mattermost.com/software-evaluation-agreement/), [Privacy Policy](https://mattermost.com/privacy-policy/), and receiving product emails."
+    "translation": "With so much conversation happening across RS-CloudOffice, it can be challenging to know where to look for important information. If you want to broadcast a message to a large audience, you can set up read-only Announcement Channels where anyone can join but only channel admins can post messages.\r\n\r\n[Learn more about creating read-only Announcement Channels](https://www.mattermost.com/docs-channel-moderation/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=channel-moderation)\r\n\r\nBy clicking Start trial, I agree to the [Mattermost Software Evaluation Agreement](https://mattermost.com/software-evaluation-agreement/), [Privacy Policy](https://mattermost.com/privacy-policy/), and receiving product emails."
   },
   {
     "id": "api.server.warn_metric.number_of_active_users_300.start_trial.notification_success.message",
@@ -2761,19 +2769,19 @@
   },
   {
     "id": "api.server.warn_metric.number_of_active_users_500.contact_us.email_body",
-    "translation": "Mattermost contact us request. My team now has 500 users, and I'm considering Mattermost Enterprise Edition.\r\n"
+    "translation": "RS-CloudOffice contact us request. My team now has 500 users, and I'm considering Mattermost Enterprise Edition.\r\n"
   },
   {
     "id": "api.server.warn_metric.number_of_active_users_500.notification_body",
-    "translation": "Mattermost strongly recommends that deployments of over 500 users take advantage of features such as user management, server clustering and performance monitoring. Contact us to learn more and let us know how we can help.\r\n\r\nBy clicking Contact Us, you'll be sharing your information with Mattermost, Inc. [Learn more](https://mattermost.com/pl/default-admin-advisory)"
+    "translation": "RS-CloudOffice strongly recommends that deployments of over 500 users take advantage of features such as user management, server clustering and performance monitoring. Contact us to learn more and let us know how we can help.\r\n\r\nBy clicking Contact Us, you'll be sharing your information with Mattermost, Inc. [Learn more](https://mattermost.com/pl/default-admin-advisory)"
   },
   {
     "id": "api.server.warn_metric.number_of_active_users_500.notification_title",
-    "translation": "Scaling with Mattermost"
+    "translation": "Scaling with RS-CloudOffice"
   },
   {
     "id": "api.server.warn_metric.number_of_active_users_500.start_trial.notification_body",
-    "translation": "Mattermost strongly recommends that deployments of over 500 users take advantage of features such as user management, server clustering and performance monitoring. Contact us to learn more and let us know how we can help.\r\n\r\nBy clicking Start trial, I agree to the [Mattermost Software Evaluation Agreement](https://mattermost.com/software-evaluation-agreement/), [Privacy Policy](https://mattermost.com/privacy-policy/), and receiving product emails."
+    "translation": "RS-CloudOffice strongly recommends that deployments of over 500 users take advantage of features such as user management, server clustering and performance monitoring. Contact us to learn more and let us know how we can help.\r\n\r\nBy clicking Start trial, I agree to the [Mattermost Software Evaluation Agreement](https://mattermost.com/software-evaluation-agreement/), [Privacy Policy](https://mattermost.com/privacy-policy/), and receiving product emails."
   },
   {
     "id": "api.server.warn_metric.number_of_active_users_500.start_trial.notification_success.message",
@@ -2781,11 +2789,11 @@
   },
   {
     "id": "api.server.warn_metric.number_of_channels_50.contact_us.email_body",
-    "translation": "Mattermost contact us request. I'm interested in learning more about using Advanced Permissions with System Schemes.\r\n"
+    "translation": "RS-CloudOffice contact us request. I'm interested in learning more about using Advanced Permissions with System Schemes.\r\n"
   },
   {
     "id": "api.server.warn_metric.number_of_channels_50.notification_body",
-    "translation": "Channels help improve communication, but with users across Mattermost joining and creating channels, the challenge of keeping the system organized increases. Advanced Permissions enable you to set which users or roles can perform certain actions, including managing channel settings and members, using @channel or @here to tag broad groups of users, and creating new webhooks.\r\n\r\n[Learn more about using Advanced Permissions](https://www.mattermost.com/docs-advanced-permissions/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=advanced-permissions)\r\n\r\nBy clicking Contact Us, you'll be sharing your information with Mattermost, Inc. [Learn more](https://mattermost.com/pl/default-admin-advisory)"
+    "translation": "Channels help improve communication, but with users across RS-CloudOffice joining and creating channels, the challenge of keeping the system organized increases. Advanced Permissions enable you to set which users or roles can perform certain actions, including managing channel settings and members, using @channel or @here to tag broad groups of users, and creating new webhooks.\r\n\r\n[Learn more about using Advanced Permissions](https://www.mattermost.com/docs-advanced-permissions/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=advanced-permissions)\r\n\r\nBy clicking Contact Us, you'll be sharing your information with Mattermost, Inc. [Learn more](https://mattermost.com/pl/default-admin-advisory)"
   },
   {
     "id": "api.server.warn_metric.number_of_channels_50.notification_title",
@@ -2793,7 +2801,7 @@
   },
   {
     "id": "api.server.warn_metric.number_of_channels_50.start_trial.notification_body",
-    "translation": "Channels help improve communication, but with users across Mattermost joining and creating channels, the challenge of keeping the system organized increases. Advanced Permissions enable you to set which users or roles can perform certain actions, including managing channel settings and members, using @channel or @here to tag broad groups of users, and creating new webhooks.\r\n\r\n[Learn more about using Advanced Permissions](https://www.mattermost.com/docs-advanced-permissions/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=advanced-permissions)\r\n\r\nBy clicking Start trial, I agree to the [Mattermost Software Evaluation Agreement](https://mattermost.com/software-evaluation-agreement/), [Privacy Policy](https://mattermost.com/privacy-policy/), and receiving product emails."
+    "translation": "Channels help improve communication, but with users across RS-CloudOffice joining and creating channels, the challenge of keeping the system organized increases. Advanced Permissions enable you to set which users or roles can perform certain actions, including managing channel settings and members, using @channel or @here to tag broad groups of users, and creating new webhooks.\r\n\r\n[Learn more about using Advanced Permissions](https://www.mattermost.com/docs-advanced-permissions/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=advanced-permissions)\r\n\r\nBy clicking Start trial, I agree to the [Mattermost Software Evaluation Agreement](https://mattermost.com/software-evaluation-agreement/), [Privacy Policy](https://mattermost.com/privacy-policy/), and receiving product emails."
   },
   {
     "id": "api.server.warn_metric.number_of_channels_50.start_trial.notification_success.message",
@@ -2801,11 +2809,11 @@
   },
   {
     "id": "api.server.warn_metric.number_of_posts_2M.contact_us.email_body",
-    "translation": "Mattermost contact us request. I'm interested in learning more about improving performance with Elasticsearch.\r\n"
+    "translation": "RS-CloudOffice contact us request. I'm interested in learning more about improving performance with Elasticsearch.\r\n"
   },
   {
     "id": "api.server.warn_metric.number_of_posts_2M.notification_body",
-    "translation": "Your Mattermost system has a large number of messages. The default Mattermost database search starts to show performance degradation at around 2.5 million posts. With over 5 million posts, Elasticsearch can help avoid significant performance issues, such as timeouts, with search and at-mentions. Contact us to learn more and let us know how we can help.\r\n\r\n[Learn more about improving performance](https://www.mattermost.com/docs-elasticsearch/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=elasticsearch)\r\n\r\nBy clicking Contact Us, you'll be sharing your information with Mattermost, Inc. [Learn more](https://mattermost.com/pl/default-admin-advisory)"
+    "translation": "Your RS-CloudOffice system has a large number of messages. The default RS-CloudOffice database search starts to show performance degradation at around 2.5 million posts. With over 5 million posts, Elasticsearch can help avoid significant performance issues, such as timeouts, with search and at-mentions. Contact us to learn more and let us know how we can help.\r\n\r\n[Learn more about improving performance](https://www.mattermost.com/docs-elasticsearch/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=elasticsearch)\r\n\r\nBy clicking Contact Us, you'll be sharing your information with Mattermost, Inc. [Learn more](https://mattermost.com/pl/default-admin-advisory)"
   },
   {
     "id": "api.server.warn_metric.number_of_posts_2M.notification_title",
@@ -2813,7 +2821,7 @@
   },
   {
     "id": "api.server.warn_metric.number_of_posts_2M.start_trial.notification_body",
-    "translation": "Your Mattermost system has a large number of messages. The default Mattermost database search starts to show performance degradation at around 2.5 million posts. With over 5 million posts, Elasticsearch can help avoid significant performance issues, such as timeouts, with search and at-mentions. Contact us to learn more and let us know how we can help.\r\n\r\n[Learn more about improving performance](https://www.mattermost.com/docs-elasticsearch/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=elasticsearch)\r\n\r\nBy clicking Start trial, I agree to the [Mattermost Software Evaluation Agreement](https://mattermost.com/software-evaluation-agreement/), [Privacy Policy](https://mattermost.com/privacy-policy/), and receiving product emails."
+    "translation": "Your RS-CloudOffice system has a large number of messages. The default RS-CloudOffice database search starts to show performance degradation at around 2.5 million posts. With over 5 million posts, Elasticsearch can help avoid significant performance issues, such as timeouts, with search and at-mentions. Contact us to learn more and let us know how we can help.\r\n\r\n[Learn more about improving performance](https://www.mattermost.com/docs-elasticsearch/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=elasticsearch)\r\n\r\nBy clicking Start trial, I agree to the [Mattermost Software Evaluation Agreement](https://mattermost.com/software-evaluation-agreement/), [Privacy Policy](https://mattermost.com/privacy-policy/), and receiving product emails."
   },
   {
     "id": "api.server.warn_metric.number_of_posts_2M.start_trial.notification_success.message",
@@ -2821,11 +2829,11 @@
   },
   {
     "id": "api.server.warn_metric.number_of_teams_5.contact_us.email_body",
-    "translation": "Mattermost contact us request. I'm interested in learning more about Advanced Permissions with Team Schemes.\r\n"
+    "translation": "RS-CloudOffice contact us request. I'm interested in learning more about Advanced Permissions with Team Schemes.\r\n"
   },
   {
     "id": "api.server.warn_metric.number_of_teams_5.notification_body",
-    "translation": "Your Mattermost system now has several teams. Many teams have their own preferred way of coordinating and collaborating, including how channels are created, who can invite new teammates, and how integrations are managed. Team Override Schemes allow you to customize user permissions within each team to meet their specific needs.\r\n\r\n[Learn more about using Advanced Permissions](https://www.mattermost.com/docs-advanced-permissions-team-override/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=advanced-permissions-team-override).\r\n\r\nBy clicking Contact Us, you'll be sharing your information with Mattermost, Inc. [Learn more](https://mattermost.com/pl/default-admin-advisory)"
+    "translation": "Your RS-CloudOffice system now has several teams. Many teams have their own preferred way of coordinating and collaborating, including how channels are created, who can invite new teammates, and how integrations are managed. Team Override Schemes allow you to customize user permissions within each team to meet their specific needs.\r\n\r\n[Learn more about using Advanced Permissions](https://www.mattermost.com/docs-advanced-permissions-team-override/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=advanced-permissions-team-override).\r\n\r\nBy clicking Contact Us, you'll be sharing your information with Mattermost, Inc. [Learn more](https://mattermost.com/pl/default-admin-advisory)"
   },
   {
     "id": "api.server.warn_metric.number_of_teams_5.notification_title",
@@ -2833,7 +2841,7 @@
   },
   {
     "id": "api.server.warn_metric.number_of_teams_5.start_trial.notification_body",
-    "translation": "Your Mattermost system now has several teams. Many teams have their own preferred way of coordinating and collaborating, including how channels are created, who can invite new teammates, and how integrations are managed. Team Override Schemes allow you to customize user permissions within each team to meet their specific needs.\r\n\r\n[Learn more about using Advanced Permissions](https://www.mattermost.com/docs-advanced-permissions-team-override/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=advanced-permissions-team-override)\r\n\r\nBy clicking Start trial, I agree to the [Mattermost Software Evaluation Agreement](https://mattermost.com/software-evaluation-agreement/), [Privacy Policy](https://mattermost.com/privacy-policy/), and receiving product emails."
+    "translation": "Your RS-CloudOffice system now has several teams. Many teams have their own preferred way of coordinating and collaborating, including how channels are created, who can invite new teammates, and how integrations are managed. Team Override Schemes allow you to customize user permissions within each team to meet their specific needs.\r\n\r\n[Learn more about using Advanced Permissions](https://www.mattermost.com/docs-advanced-permissions-team-override/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=advanced-permissions-team-override)\r\n\r\nBy clicking Start trial, I agree to the [Mattermost Software Evaluation Agreement](https://mattermost.com/software-evaluation-agreement/), [Privacy Policy](https://mattermost.com/privacy-policy/), and receiving product emails."
   },
   {
     "id": "api.server.warn_metric.number_of_teams_5.start_trial_notification_success.message",
@@ -2861,7 +2869,7 @@
   },
   {
     "id": "api.slackimport.slack_add_channels.merge",
-    "translation": "The Slack channel {{.DisplayName}} already exists as an active Mattermost channel. Both channels have been merged.\r\n"
+    "translation": "The Slack channel {{.DisplayName}} already exists as an active RS-CloudOffice channel. Both channels have been merged.\r\n"
   },
   {
     "id": "api.slackimport.slack_add_users.created",
@@ -2889,7 +2897,7 @@
   },
   {
     "id": "api.slackimport.slack_import.log",
-    "translation": "Mattermost Slack Import Log\r\n"
+    "translation": "RS-CloudOffice Slack Import Log\r\n"
   },
   {
     "id": "api.slackimport.slack_import.note1",
@@ -3229,7 +3237,7 @@
   },
   {
     "id": "api.templates.cloud_welcome_email.button",
-    "translation": "Open Mattermost"
+    "translation": "Open RS-CloudOffice"
   },
   {
     "id": "api.templates.cloud_welcome_email.download_mm_info",
@@ -3289,7 +3297,7 @@
   },
   {
     "id": "api.templates.copyright",
-    "translation": "© 2021 Mattermost, Inc. 530 Lytton Avenue, Second floor, Palo Alto, CA, 94301"
+    "translation": "© 2021 RS-CloudOffice"
   },
   {
     "id": "api.templates.deactivate_body.info",
@@ -3517,7 +3525,7 @@
   },
   {
     "id": "api.templates.email_footer_v2",
-    "translation": "© 2022 Mattermost, Inc. 530 Lytton Avenue, Second floor, Palo Alto, CA, 94301"
+    "translation": "© 2021 RS-CloudOffice"
   },
   {
     "id": "api.templates.email_info1",
@@ -3549,7 +3557,7 @@
   },
   {
     "id": "api.templates.invite_body.subTitle",
-    "translation": "Start collaborating with your team on Mattermost"
+    "translation": "Start collaborating with your team on RS-CloudOffice"
   },
   {
     "id": "api.templates.invite_body.title",
@@ -3561,7 +3569,7 @@
   },
   {
     "id": "api.templates.invite_body_footer.info",
-    "translation": "Mattermost is a flexible, open source messaging platform that enables secure team collaboration."
+    "translation": "RS-CloudOffice is a flexible, open source messaging platform that enables secure team collaboration."
   },
   {
     "id": "api.templates.invite_body_footer.learn_more",
@@ -3569,7 +3577,7 @@
   },
   {
     "id": "api.templates.invite_body_footer.title",
-    "translation": "What is Mattermost?"
+    "translation": "What is RS-CloudOffice?"
   },
   {
     "id": "api.templates.invite_body_guest.subTitle",
@@ -3817,7 +3825,7 @@
   },
   {
     "id": "api.templates.verify_body.info",
-    "translation": "This email address was used to create an account with Mattermost."
+    "translation": "This email address was used to create an account with RS-CloudOffice."
   },
   {
     "id": "api.templates.verify_body.info1",
@@ -3889,7 +3897,7 @@
   },
   {
     "id": "api.templates.welcome_body.info",
-    "translation": "This email address was used to create an account with Mattermost."
+    "translation": "This email address was used to create an account with RS-CloudOffice."
   },
   {
     "id": "api.templates.welcome_body.info1",
@@ -5853,7 +5861,7 @@
   },
   {
     "id": "app.notification.footer.infoLogin",
-    "translation": "Login to Mattermost"
+    "translation": "Login to RS-CloudOffice"
   },
   {
     "id": "app.notification.footer.title",
@@ -7673,7 +7681,7 @@
   },
   {
     "id": "ent.ldap.do_login.user_filtered.app_error",
-    "translation": "Your AD/LDAP account does not have permission to use this Mattermost server. Please ask your System Administrator to check the AD/LDAP user filter."
+    "translation": "Your AD/LDAP account does not have permission to use this RS-CloudOffice server. Please ask your System Administrator to check the AD/LDAP user filter."
   },
   {
     "id": "ent.ldap.do_login.user_not_registered.app_error",
@@ -7713,7 +7721,7 @@
   },
   {
     "id": "ent.ldap.syncronize.search_failure.app_error",
-    "translation": "Failed to search users in AD/LDAP. Test if the Mattermost server can connect to your AD/LDAP server and try again."
+    "translation": "Failed to search users in AD/LDAP. Test if the RS-CloudOffice server can connect to your AD/LDAP server and try again."
   },
   {
     "id": "ent.ldap.syncronize.search_failure_size_exceeded.app_error",
@@ -7845,7 +7853,7 @@
   },
   {
     "id": "ent.migration.migratetosaml.username_already_used_by_other_user",
-    "translation": "Username already used by another Mattermost user."
+    "translation": "Username already used by another RS-CloudOffice user."
   },
   {
     "id": "ent.saml.attribute.app_error",
@@ -8001,7 +8009,7 @@
   },
   {
     "id": "mattermost.bulletin.subject",
-    "translation": "Mattermost Security Bulletin"
+    "translation": "RS-CloudOffice Security Bulletin"
   },
   {
     "id": "mfa.activate.app_error",
@@ -9501,7 +9509,7 @@
   },
   {
     "id": "oauth.gitlab.tos.error",
-    "translation": "GitLab's Terms of Service have updated. Please go to {{.URL}} to accept them and then try logging into Mattermost again."
+    "translation": "GitLab's Terms of Service have updated. Please go to gitlab.com to accept them and then try logging into RS-CloudOffice again."
   },
   {
     "id": "plugin.api.get_users_in_channel",
@@ -9697,11 +9705,11 @@
   },
   {
     "id": "web.error.unsupported_browser.no_longer_support",
-    "translation": "This browser is no longer supported by Mattermost"
+    "translation": "This browser is no longer supported by RS-CloudOffice"
   },
   {
     "id": "web.error.unsupported_browser.no_longer_support_version",
-    "translation": "This version of your browser is no longer supported by Mattermost"
+    "translation": "This version of your browser is no longer supported by RS-CloudOffice"
   },
   {
     "id": "web.error.unsupported_browser.open_system_browser.edge",
@@ -9756,6 +9764,762 @@
     "translation": "Couldn't find the user."
   },
   {
+    "id": "api.meeting.timezone.Etc/GMT+12",
+    "translation": "(UTC-12:00) West side of the International Date Line"
+  },
+  {
+    "id": "api.meeting.timezone.Etc/GMT+11",
+    "translation": "(UTC-11:00) Coordinated Universal Time -11"
+  },
+  {
+    "id": "api.meeting.timezone.Pacific/Honolulu",
+    "translation": "(UTC-10:00) Hawaii"
+  },
+  {
+    "id": "api.meeting.timezone.Pacific/Marquesas",
+    "translation": "(UTC-09:30) Marquesas Islands"
+  },
+  {
+    "id": "api.meeting.timezone.America/Anchorage",
+    "translation": "(UTC-09:00) Alaska"
+  },
+  {
+    "id": "api.meeting.timezone.America/Santa_Isabel",
+    "translation": "(UTC-08:00) Baja California"
+  },
+  {
+    "id": "api.meeting.timezone.America/Los_Angeles",
+    "translation": "(UTC-08:00) Pacific Standard Time (US and Canada)"
+  },
+  {
+    "id": "api.meeting.timezone.America/Chihuahua",
+    "translation": "(UTC-07:00) Chihuahua, Lapas, Mazatlan"
+  },
+  {
+    "id": "api.meeting.timezone.America/Phoenix",
+    "translation": "(UTC-07:00) Arizona"
+  },
+  {
+    "id": "api.meeting.timezone.America/Denver",
+    "translation": "(UTC-07:00) Mountain Standard Time (US and Canada)"
+  },
+  {
+    "id": "api.meeting.timezone.America/Guatemala",
+    "translation": "(UTC-06:00) Central America"
+  },
+  {
+    "id": "api.meeting.timezone.America/Chicago",
+    "translation": "(UTC-06:00) Central Standard Time (US and Canada)"
+  },
+  {
+    "id": "api.meeting.timezone.America/Regina",
+    "translation": "(UTC-06:00) Saskatchewan"
+  },
+  {
+    "id": "api.meeting.timezone.America/Mexico_City",
+    "translation": "(UTC-06:00) Guadalajara, Mexico City, Monterrey"
+  },
+  {
+    "id": "api.meeting.timezone.America/Bogota",
+    "translation": "(UTC-05:00) Bogota, Lima, Quito"
+  },
+  {
+    "id": "api.meeting.timezone.America/Indiana/Indianapolis",
+    "translation": "(UTC-05:00) Eastern Indiana"
+  },
+  {
+    "id": "api.meeting.timezone.America/New_York",
+    "translation": "(UTC-05:00) Eastern Standard Time (US and Canada)"
+  },
+  {
+    "id": "api.meeting.timezone.America/Halifax",
+    "translation": "(UTC-04:00) Atlantic Standard Time (Canada)"
+  },
+  {
+    "id": "api.meeting.timezone.America/Asuncion",
+    "translation": "(UTC-04:00) Asuncion"
+  },
+  {
+    "id": "api.meeting.timezone.America/La_Paz",
+    "translation": "(UTC-04:00) Georgetown, Lapas, Manaus, San Juan"
+  },
+  {
+    "id": "api.meeting.timezone.America/Cuiaba",
+    "translation": "(UTC-04:00) Cuiabá"
+  },
+  {
+    "id": "api.meeting.timezone.America/Santiago",
+    "translation": "(UTC-04:00) Santiago"
+  },
+  {
+    "id": "api.meeting.timezone.America/St_Johns",
+    "translation": "(UTC-03:30) Newfoundland"
+  },
+  {
+    "id": "api.meeting.timezone.America/Sao_Paulo",
+    "translation": "(UTC-03:00) Brasilia"
+  },
+  {
+    "id": "api.meeting.timezone.America/Godthab",
+    "translation": "(UTC-03:00) Greenland"
+  },
+  {
+    "id": "api.meeting.timezone.America/Cayenne",
+    "translation": "(UTC-03:00) Cayenne, Fortaleza"
+  },
+  {
+    "id": "api.meeting.timezone.America/Argentina/Buenos_Aires",
+    "translation": "(UTC-03:00) Buenos Aires"
+  },
+  {
+    "id": "api.meeting.timezone.America/Montevideo",
+    "translation": "(UTC-03:00) Montevideo"
+  },
+  {
+    "id": "api.meeting.timezone.Etc/GMT+2",
+    "translation": "(UTC-02:00) Coordinated Universal Time -2"
+  },
+  {
+    "id": "api.meeting.timezone.Atlantic/Cape_Verde",
+    "translation": "(UTC-01:00) Cape Verde Islands"
+  },
+  {
+    "id": "api.meeting.timezone.Atlantic/Azores",
+    "translation": "(UTC-01:00) Azores"
+  },
+  {
+    "id": "api.meeting.timezone.Africa/Casablanca",
+    "translation": "(UTC+00:00) Casablanca"
+  },
+  {
+    "id": "api.meeting.timezone.Atlantic/Reykjavik",
+    "translation": "(UTC+00:00) Monrovia, Reykjavik"
+  },
+  {
+    "id": "api.meeting.timezone.Europe/London",
+    "translation": "(UTC+00:00) Dublin, Edinburgh, Lisbon, London"
+  },
+  {
+    "id": "api.meeting.timezone.Etc/GMT",
+    "translation": "(UTC+00:00) Coordinated Universal Time"
+  },
+  {
+    "id": "api.meeting.timezone.Europe/Berlin",
+    "translation": "(UTC+01:00) Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna"
+  },
+  {
+    "id": "api.meeting.timezone.Europe/Paris",
+    "translation": "(UTC+01:00) Brussels, Copenhagen, Madrid, Paris"
+  },
+  {
+    "id": "api.meeting.timezone.Africa/Lagos",
+    "translation": "(UTC+01:00) West Central Africa"
+  },
+  {
+    "id": "api.meeting.timezone.Europe/Budapest",
+    "translation": "(UTC+01:00) Belgrade, Bratislava, Budapest, Ljubljana, Prague"
+  },
+  {
+    "id": "api.meeting.timezone.Europe/Warsaw",
+    "translation": "(UTC+01:00) Sarajevo, Skopje, Warsaw, Zagreb"
+  },
+  {
+    "id": "api.meeting.timezone.Africa/Windhoek",
+    "translation": "(UTC+01:00) Windhoek"
+  },
+  {
+    "id": "api.meeting.timezone.Europe/Istanbul",
+    "translation": "(UTC+02:00) Athens, Bucharest, Istanbul"
+  },
+  {
+    "id": "api.meeting.timezone.Europe/Kiev",
+    "translation": "(UTC+02:00) Helsinki, Kiev, Riga, Sophia, Tallinn, Vilnius"
+  },
+  {
+    "id": "api.meeting.timezone.Africa/Cairo",
+    "translation": "(UTC+02:00) Cairo"
+  },
+  {
+    "id": "api.meeting.timezone.Asia/Damascus",
+    "translation": "(UTC+02:00) Damascus"
+  },
+  {
+    "id": "api.meeting.timezone.Asia/Amman",
+    "translation": "(UTC+02:00) Amman"
+  },
+  {
+    "id": "api.meeting.timezone.Africa/Johannesburg",
+    "translation": "(UTC+02:00) Harare, Pretoria"
+  },
+  {
+    "id": "api.meeting.timezone.Asia/Jerusalem",
+    "translation": "(UTC+02:00) Jerusalem"
+  },
+  {
+    "id": "api.meeting.timezone.Asia/Beirut",
+    "translation": "(UTC+02:00) Beirut"
+  },
+  {
+    "id": "api.meeting.timezone.Asia/Baghdad",
+    "translation": "(UTC+03:00) Baghdad"
+  },
+  {
+    "id": "api.meeting.timezone.Europe/Minsk",
+    "translation": "(UTC+03:00) Minsk"
+  },
+  {
+    "id": "api.meeting.timezone.Asia/Riyadh",
+    "translation": "(UTC+03:00) Kuwait, Riyadh"
+  },
+  {
+    "id": "api.meeting.timezone.Africa/Nairobi",
+    "translation": "(UTC+03:00) Nairobi"
+  },
+  {
+    "id": "api.meeting.timezone.Asia/Tehran",
+    "translation": "(UTC+03:30) Tehran"
+  },
+  {
+    "id": "api.meeting.timezone.Europe/Moscow",
+    "translation": "(UTC+04:00) Moscow, St. Petersburg, Volgograd"
+  },
+  {
+    "id": "api.meeting.timezone.Asia/Tbilisi",
+    "translation": "(UTC+04:00) Tbilisi"
+  },
+  {
+    "id": "api.meeting.timezone.Asia/Yerevan",
+    "translation": "(UTC+04:00) Yerevan"
+  },
+  {
+    "id": "api.meeting.timezone.Asia/Dubai",
+    "translation": "(UTC+04:00) Abu Dhabi, Muscat"
+  },
+  {
+    "id": "api.meeting.timezone.Asia/Baku",
+    "translation": "(UTC+04:00) Baku"
+  },
+  {
+    "id": "api.meeting.timezone.Indian/Mauritius",
+    "translation": "(UTC+04:00) Port Louis"
+  },
+  {
+    "id": "api.meeting.timezone.Asia/Kabul",
+    "translation": "(UTC+04:30) Kabul"
+  },
+  {
+    "id": "api.meeting.timezone.Asia/Tashkent",
+    "translation": "(UTC+05:00) Tashkent"
+  },
+  {
+    "id": "api.meeting.timezone.Asia/Karachi",
+    "translation": "(UTC+05:00) Islamabad, Karachi"
+  },
+  {
+    "id": "api.meeting.timezone.Asia/Colombo",
+    "translation": "(UTC+05:30) Sri Jayawardenepura Kotte"
+  },
+  {
+    "id": "api.meeting.timezone.Asia/Kolkata",
+    "translation": "(UTC+05:30) Chennai, Kolkata, Mumbai, New Delhi"
+  },
+  {
+    "id": "api.meeting.timezone.Asia/Kathmandu",
+    "translation": "(UTC+05:45) Kathmandu"
+  },
+  {
+    "id": "api.meeting.timezone.Asia/Almaty",
+    "translation": "(UTC+06:00) Astana"
+  },
+  {
+    "id": "api.meeting.timezone.Asia/Dhaka",
+    "translation": "(UTC+06:00) Dhaka"
+  },
+  {
+    "id": "api.meeting.timezone.Asia/Yekaterinburg",
+    "translation": "(UTC+06:00) Yekaterinburg"
+  },
+  {
+    "id": "api.meeting.timezone.Asia/Yangon",
+    "translation": "(UTC+06:30) Yangon"
+  },
+  {
+    "id": "api.meeting.timezone.Asia/Bangkok",
+    "translation": "(UTC+07:00) Bangkok, Hanoi, Jakarta"
+  },
+  {
+    "id": "api.meeting.timezone.Asia/Novosibirsk",
+    "translation": "(UTC+07:00) Novosibirsk"
+  },
+  {
+    "id": "api.meeting.timezone.Asia/Krasnoyarsk",
+    "translation": "(UTC+08:00) Krasnoyarsk"
+  },
+  {
+    "id": "api.meeting.timezone.Asia/Ulaanbaatar",
+    "translation": "(UTC+08:00) Ulaanbaatar"
+  },
+  {
+    "id": "api.meeting.timezone.Asia/Shanghai",
+    "translation": "(UTC+08:00) Beijing, Chongqing, HongKong, Urumqi"
+  },
+  {
+    "id": "api.meeting.timezone.Australia/Perth",
+    "translation": "(UTC+08:00) Perth"
+  },
+  {
+    "id": "api.meeting.timezone.Asia/Singapore",
+    "translation": "(UTC+08:00) Kuala Lumpur, Singapore"
+  },
+  {
+    "id": "api.meeting.timezone.Asia/Taipei",
+    "translation": "(UTC+08:00) Taipei"
+  },
+  {
+    "id": "api.meeting.timezone.Australia/Eucla",
+    "translation": "(UTC+08:45) Western Australia (Eucla)"
+  },
+  {
+    "id": "api.meeting.timezone.Asia/Irkutsk",
+    "translation": "(UTC+09:00) Irkutsk"
+  },
+  {
+    "id": "api.meeting.timezone.Asia/Seoul",
+    "translation": "(UTC+09:00) Seoul"
+  },
+  {
+    "id": "api.meeting.timezone.Asia/Tokyo",
+    "translation": "(UTC+09:00) Osaka, Sapporo, Tokyo"
+  },
+  {
+    "id": "api.meeting.timezone.Australia/Darwin",
+    "translation": "(UTC+09:30) Darwin"
+  },
+  {
+    "id": "api.meeting.timezone.Australia/Adelaide",
+    "translation": "(UTC+09:30) Adelaide"
+  },
+  {
+    "id": "api.meeting.timezone.Australia/Hobart",
+    "translation": "(UTC+10:00) Hobart"
+  },
+  {
+    "id": "api.meeting.timezone.Asia/Yakutsk",
+    "translation": "(UTC+10:00) Yakutsk"
+  },
+  {
+    "id": "api.meeting.timezone.Australia/Brisbane",
+    "translation": "(UTC+10:00) Brisbane"
+  },
+  {
+    "id": "api.meeting.timezone.Pacific/Port_Moresby",
+    "translation": "(UTC+10:00) Guam, Port Moresby"
+  },
+  {
+    "id": "api.meeting.timezone.Australia/Sydney",
+    "translation": "(UTC+10:00) Canberra, Melbourne, Sydney"
+  },
+  {
+    "id": "api.meeting.timezone.Australia/LHI",
+    "translation": "(UTC+10:30) Lord Howe Island"
+  },
+  {
+    "id": "api.meeting.timezone.Asia/Vladivostok",
+    "translation": "(UTC+11:00) Vladivostok"
+  },
+  {
+    "id": "api.meeting.timezone.Pacific/Guadalcanal",
+    "translation": "(UTC+11:00) Solomon Islands, New Caledonia"
+  },
+  {
+    "id": "api.meeting.timezone.Etc/GMT-12",
+    "translation": "(UTC+12:00) Coordinated Universal Time +12"
+  },
+  {
+    "id": "api.meeting.timezone.Pacific/Fiji",
+    "translation": "(UTC+12:00) Fiji, Marshall Islands"
+  },
+  {
+    "id": "api.meeting.timezone.Asia/Magadan",
+    "translation": "(UTC+12:00) Magadan"
+  },
+  {
+    "id": "api.meeting.timezone.Pacific/Auckland",
+    "translation": "(UTC+12:00) Auckland, Wellington"
+  },
+  {
+    "id": "api.meeting.timezone.Pacific/Chatham",
+    "translation": "(UTC+12:45) Chatham Islands"
+  },
+  {
+    "id": "api.meeting.timezone.Pacific/Tongatapu",
+    "translation": "(UTC+13:00) Nuku'alofa"
+  },
+  {
+    "id": "api.meeting.timezone.Pacific/Apia",
+    "translation": "(UTC+13:00) Samoa"
+  },
+  {
+    "id": "api.meeting.timezone.Pacific/Kiritimati",
+    "translation": "(UTC+14:00) Line Islands"
+  },
+  {
+    "id": "api.meeting.server_opt.app_error",
+    "translation": "Internal server error, please contact administrator."
+  },
+  {
+      "id": "api.meeting.meeting_not_exist.app_error",
+      "translation": "Meeting information does not exist."
+  },
+  {
+    "id": "api.meeting.mail_send.app_error",
+    "translation": "Failed to send the following email address. {{ .FailedMailAddrs }}. please contact administrator."
+  },
+  {
+    "id": "api.meeting.mail_format.app_error",
+    "translation": "Please check the email address. Please use ';' as a delimiter for email addresses."
+  },
+  {
+    "id": "api.meeting.meeting_duplicated.app_error",
+    "translation": "Cannot make a reservation because there is a meeting with the same name and participants. please confirm."
+  },
+  {
+    "id": "api.meeting.mail.terminate_template",
+    "translation": "{{ .UserName }} canceled the meeting.<br/><br/>{{ .RepeatMeetingInfo }}{{ .StartAtYear }}/{{ .StartAtMonth }}/{{ .StartAtDay }} {{ .StartAtHour }}:{{ .StartAtMinute }} - {{ .EndAtYear }}/{{ .EndAtMonth }}/{{ .EndAtDay }} {{ .EndAtHour }}:{{ .EndAtMinute }}<br/>{{ .TimeZone }}"
+  },
+  {
+    "id": "api.meeting.mail.change_template",
+    "translation": "{{ .UserName }} changed the scheduled meeting. Please participate in the meeting from here.<br/><br/>{{ .RepeatMeetingInfo }}{{ .StartAtYear }}/{{ .StartAtMonth }}/{{ .StartAtDay }} {{ .StartAtHour }}:{{ .StartAtMinute }} - {{ .EndAtYear }}/{{ .EndAtMonth }}/{{ .EndAtDay }} {{ .EndAtHour }}:{{ .EndAtMinute }}<br/>{{ .TimeZone }}<br/><br/>Join the meeting<br/>&lt;{{ .MeetingUrl }}&gt;<br/>Click the attachment to add the meeting to the calendar"
+  },
+  {
+    "id": "api.meeting.mail.invite_template",
+    "translation": "{{ .UserName }} invites you to a scheduled meeting.<br/><br/>{{ .RepeatMeetingInfo }}{{ .StartAtYear }}/{{ .StartAtMonth }}/{{ .StartAtDay }} {{ .StartAtHour }}:{{ .StartAtMinute }} - {{ .EndAtYear }}/{{ .EndAtMonth }}/{{ .EndAtDay }} {{ .EndAtHour }}:{{ .EndAtMinute }}<br/>{{ .TimeZone }}<br/><br/>Join the meeting<br/>&lt;{{ .MeetingUrl }}&gt;<br/>Click the attachment to add the meeting to the calendar"
+  },
+  {
+    "id": "api.meeting.mail.terminate_template_host",
+    "translation": "You ({{ .UserName }}) canceled the meeting.<br/><br/>{{ .RepeatMeetingInfo }}{{ .StartAtYear }}/{{ .StartAtMonth }}/{{ .StartAtDay }} {{ .StartAtHour }}:{{ .StartAtMinute }} - {{ .EndAtYear }}/{{ .EndAtMonth }}/{{ .EndAtDay }} {{ .EndAtHour }}:{{ .EndAtMinute }}<br/>{{ .TimeZone }}"
+  },
+  {
+    "id": "api.meeting.mail.change_template_host",
+    "translation": "You ({{ .UserName }}) changed the scheduled meeting. Please start meeting from here.<br/><br/>{{ .RepeatMeetingInfo }}{{ .StartAtYear }}/{{ .StartAtMonth }}/{{ .StartAtDay }} {{ .StartAtHour }}:{{ .StartAtMinute }} - {{ .EndAtYear }}/{{ .EndAtMonth }}/{{ .EndAtDay }} {{ .EndAtHour }}:{{ .EndAtMinute }}<br/>{{ .TimeZone }}<br/><br/>Start the meeting<br/>&lt;{{ .MeetingUrl }}&gt;<br/>Click the attachment to add the meeting to the calendar"
+  },
+  {
+    "id": "api.meeting.mail.invite_template_host",
+    "translation": "You ({{ .UserName }}) are the host of this meeting.<br/>Please start meeting from here.<br/><br/>{{ .RepeatMeetingInfo }}{{ .StartAtYear }}/{{ .StartAtMonth }}/{{ .StartAtDay }} {{ .StartAtHour }}:{{ .StartAtMinute }} - {{ .EndAtYear }}/{{ .EndAtMonth }}/{{ .EndAtDay }} {{ .EndAtHour }}:{{ .EndAtMinute }}<br/>{{ .TimeZone }}<br/><br/>Start the meeting<br/>&lt;{{ .MeetingUrl }}&gt;<br/>Click the attachment to add the meeting to the calendar"
+  },
+  {
+    "id": "api.meeting.mail.ics.filename",
+    "translation": "Meeting_info"
+  },
+  {
+    "id": "api.meeting.mail.terminate_title_prefix",
+    "translation": "[RS-CloudOffice Meeting Cancel Notice] "
+  },
+  {
+    "id": "api.meeting.mail.change_title_prefix",
+    "translation": "[RS-CloudOffice Meeting Change Notice] "
+  },
+  {
+    "id": "api.meeting.mail.invite_title_prefix",
+    "translation": "[RS-CloudOffice Meeting Invitation Notice] "
+  },
+  {
+    "id": "api.meeting.mail.invite_title_prefix_host",
+    "translation": "[RS-CloudOffice Meeting Hold Notice] "
+  },
+  {
+    "id": "api.meeting.Mon",
+    "translation": "Monday"
+  },
+  {
+    "id": "api.meeting.Tues",
+    "translation": "Tuesday"
+  },
+  {
+    "id": "api.meeting.Wed",
+    "translation": "Wednesday"
+  },
+  {
+    "id": "api.meeting.Thur",
+    "translation": "Thursday"
+  },
+  {
+    "id": "api.meeting.Fri",
+    "translation": "Friday"
+  },
+  {
+    "id": "api.meeting.Sat",
+    "translation": "Saturday"
+  },
+  {
+    "id": "api.meeting.Sun",
+    "translation": "Sunday"
+  },
+  {
+    "id": "api.meeting.comma",
+    "translation": ", "
+  },
+  {
+    "id": "api.meeting.day",
+    "translation": "day{{ .Day }}"
+  },
+  {
+    "id": "api.meeting.first",
+    "translation": "the first "
+  },
+  {
+    "id": "api.meeting.second",
+    "translation": "the second "
+  },
+  {
+    "id": "api.meeting.third",
+    "translation": "the third "
+  },
+  {
+    "id": "api.meeting.fourth",
+    "translation": "the fourth "
+  },
+  {
+    "id": "api.meeting.last",
+    "translation": "the last "
+  },
+  {
+    "id": "api.meeting.mail.repeat_end_type.none",
+    "translation": "effective from {{ .RepeatStartAtYear }}/{{ .RepeatStartAtMonth }}/{{ .RepeatStartAtDay }}"
+  },
+  {
+    "id": "api.meeting.mail.repeat_end_type.date",
+    "translation": "effective from {{ .RepeatStartAtYear }}/{{ .RepeatStartAtMonth }}/{{ .RepeatStartAtDay }} until {{ .RepeatEndAtYear }}/{{ .RepeatEndAtMonth }}/{{ .RepeatEndAtDay }}"
+  },
+  {
+    "id": "api.meeting.mail.repeat_end_type.times",
+    "translation": "effective from {{ .RepeatStartAtYear }}/{{ .RepeatStartAtMonth }}/{{ .RepeatStartAtDay }} Times:{{ .RepeatTimes }} time(s)"
+  },
+  {
+    "id": "api.meeting.mail.repeat_type.everyday",
+    "translation": "Recurrence: every weekday "
+  },
+  {
+    "id": "api.meeting.mail.repeat_type.day",
+    "translation": "Recurrence: every {{ .RepeatDay }} day(s) "
+  },
+  {
+    "id": "api.meeting.mail.repeat_type.week",
+    "translation": "Recurrence: every {{ .RepeatWeek }} week(s) on {{ .RepeatWeekDays }} "
+  },
+  {
+    "id": "api.meeting.mail.repeat_type.month_day",
+    "translation": "Recurrence: {{ .RepeatDays }} of every {{ .RepeatMonth }} month(s) "
+  },
+  {
+    "id": "api.meeting.mail.repeat_type.month_week",
+    "translation": "Recurrence: {{ .RepeatWeekDay }} of every {{ .RepeatMonth }} month(s) "
+  },
+  {
+    "id": "api.meeting.mail.repeat_type.year_day",
+    "translation": "Recurrence: {{ .RepeatDays }} of every {{ .RepeatYear }} "
+  },
+  {
+    "id": "api.meeting.mail.repeat_type.year_week",
+    "translation": "Recurrence: {{ .RepeatWeekDay }} of every {{ .RepeatYear }} "
+  },
+  {
+    "id": "app.meeting.repeat.begin",
+    "translation": "Recurrence:"
+  },
+  {
+    "id": "api.meeting.mail.repeat_day",
+    "translation": "Daily,"
+  },
+  {
+    "id": "api.meeting.mail.repeat_week",
+    "translation": "Weekly,"
+  },
+  {
+    "id": "api.meeting.mail.repeat_month",
+    "translation": "Monthly,"
+  },
+  {
+    "id": "api.meeting.mail.repeat_year",
+    "translation": "Yearly,"
+  },
+  {
+    "id": "api.file.upload_file.not_upload_permission.app_error",
+    "translation": "You do not have permission to upload files."
+  },
+  {
+    "id": "api.file.upload_file.not_download_permission.app_error",
+    "translation": "You do not have permission to download files."
+  },
+  {
+    "id": "app.meeting.repeat_start",
+    "translation": "repeat_meeting"
+  },
+  {
+    "id": "app.meeting.repeat_end",
+    "translation": "repeat_endrule"
+  },
+  {
+    "id": "app.meeting.repeat_title",
+    "translation": "(repeat)"
+  },
+  {
+    "id": "api.meeting.mail.delete_title_prefix",
+    "translation": "The reservation meeting was cancelled by the administrator."
+  },
+  {
+    "id": "api.meeting.mail.repeat_unit_day",
+    "translation": "repeat unit：day(s)"
+  },
+  {
+    "id": "api.meeting.mail.repeat_unit_week",
+    "translation": "repeat unit：week(s)"
+  },
+  {
+    "id": "api.meeting.mail.repeat_unit_month",
+    "translation": "repeat unit：month(s)"
+  },
+  {
+    "id": "api.meeting.mail.repeat_unit_year",
+    "translation": "repeat unit：year(s)"
+  },
+  {
+    "id": "api.meeting.mail.repeat_frequency_everyday",
+    "translation": "repeat frequency：every weekday"
+  },
+  {
+    "id": "api.meeting.mail.repeat_frequency_day",
+    "translation": "repeat frequency：{{ .RepeatDay }}day(s) "
+  },
+  {
+    "id": "api.meeting.mail.repeat_frequency_week",
+    "translation": "repeat frequency: {{ .RepeatWeek }}week(s)"
+  },
+  {
+    "id": "api.meeting.mail.repeat_frequency_weekdays",
+    "translation": "{{ .RepeatWeekDays }}"
+  },
+  {
+    "id": "api.meeting.mail.repeat_frequency_month_day",
+    "translation": "repeat frequency: {{ .RepeatMonth }}of every{{ .RepeatDays }} month(s)"
+  },
+  {
+    "id": "api.meeting.mail.repeat_frequency_month_week",
+    "translation": "repeat frequency: {{ .RepeatMonth }}of every{{ .RepeatWeekDay }} month(s)"
+  },
+  {
+    "id": "api.meeting.mail.repeat_frequency_year_day",
+    "translation": "repeat frequency: {{ .RepeatYear }}of every{{ .RepeatDays }} "
+  },
+  {
+    "id": "api.meeting.mail.repeat_frequency_year_week",
+    "translation": "repeat frequency: {{ .RepeatYear }}of every{{ .RepeatWeekDay }} "
+  },
+  {
+    "id": "api.meeting.mail.repeat_over_none",
+    "translation": "repeat over: {{ .RepeatStartAtYear }}/{{ .RepeatStartAtMonth }}/{{ .RepeatStartAtDay }}"
+  },
+  {
+    "id": "api.meeting.mail.repeat_over_date",
+    "translation": "repeat over: {{ .RepeatStartAtYear }}/{{ .RepeatStartAtMonth }}/{{ .RepeatStartAtDay }}-{{ .RepeatEndAtYear }}/{{ .RepeatEndAtMonth }}/{{ .RepeatEndAtDay }}"
+  },
+  {
+    "id": "api.meeting.mail.repeat_over_times",
+    "translation": "repeat over: {{ .RepeatStartAtYear }}/{{ .RepeatStartAtMonth }}/{{ .RepeatStartAtDay }} repeat times:{{ .RepeatTimes }}"
+  },
+  {
+    "id": "api.meeting.mail.startat",
+    "translation": "meeting start: {{ .StartAtYear }}/{{ .StartAtMonth }}/{{ .StartAtDay }} {{ .StartAtHour }}:{{ .StartAtMinute }}"
+  },
+  {
+    "id": "api.meeting.mail.endat",
+    "translation": "meeting end: {{ .EndAtYear }}/{{ .EndAtMonth }}/{{ .EndAtDay }} {{ .EndAtHour }}:{{ .EndAtMinute }}"
+  },
+  {
+    "id": "api.meeting.mail.nousers",
+    "translation": "No entertainers"
+  },
+  {
+    "id": "api.meeting.mail.delete_template",
+    "translation": "A reservation meeting was cancelled by the administrator.<br/><br/>Cancelled booking conference information<br/>meetingName：{{ .MeetingName }}<br/>creator：{{ .HostName }}<br/>{{ .MeetingInfo }}<br/><br/>users：{{ .Users }}"
+  },
+  {
+    "id": "api.meeting.monday",
+    "translation": "Monday"
+  },
+  {
+    "id": "api.meeting.tuesday",
+    "translation": "Tuesday"
+  },
+  {
+    "id": "api.meeting.wednesday",
+    "translation": "Wednesday"
+  },
+  {
+    "id": "api.meeting.thursday",
+    "translation": "Thursday"
+  },
+  {
+    "id": "api.meeting.friday",
+    "translation": "Friday"
+  },
+  {
+    "id": "api.meeting.saturday",
+    "translation": "Saturday"
+  },
+  {
+    "id": "api.meeting.sunday",
+    "translation": "Sunday"
+  },
+  {
+    "id": "api.meeting.sikaku",
+    "translation": "■"
+  },
+  {
+    "id": "app.meeting.redis_connect_error",
+    "translation": "Redis connect error has occurred."
+  },
+  {
+    "id": "app.meeting.redis_pass_error",
+    "translation": "Redis password error occurred."
+  },
+  {
+    "id": "api.meeting.search.app_error",
+    "translation": "Failed to acquire conference information."
+  },
+  {
+    "id": "api.meeting.server.app_error",
+    "translation": "System error occurred and contact system administrator."
+  },
+  {
+      "id": "jp.co.ryobi.webconferencingsettingup_maxnumbermeeting_error",
+      "translation": "The maximum number of network meetings set by the conference usage limit is invalid.Specify a positive integer or 0."
+  },
+  {
+      "id": "jp.co.ryobi.webconferencingsettingup_maxnumbermeetinguser_error",
+      "translation": "The maximum number of participants per web meeting set by the meeting using a number limit is improper.Specify a positive integer or 0."
+  },
+  {
+      "id": "jp.co.ryobi.webconferencingsettingup_maxnumberallmeetinguser_error",
+      "translation": "The maximum number of Web conference connections set by the conference usage limit is invalid.Specify a positive integer or 0."
+  },
+  {
+      "id": "jp.co.ryobi.webconferencingsettingup_maxnumbermeetinguser_maxnumberallmeetinguser_error",
+      "translation": "The maximum number of participants in a network meeting must be smaller than the maximum number of connections in a network meeting."
+  },
+  {
+    "id": "api.cron_chat.chat_delete_batch.startup",
+    "translation": "chat delete batch startup"
+  },
+  {
+    "id": "api.cron_chat.chat_delete_batch.start",
+    "translation": "chat delete batch start"
+  },
+  {
+    "id": "api.cron_chat.chat_delete_batch.end",
+    "translation": "chat delete end"
+  },
+  {
     "id": "worktemplate.category.product_teams",
     "translation": "Product Teams"
   },
Index: mattermost-server-7.8.1/i18n/ja.json
===================================================================
--- mattermost-server-7.8.1/i18n/ja.json	(revision 4484)
+++ mattermost-server-7.8.1/i18n/ja.json	(revision 4485)
@@ -97,7 +97,7 @@
   },
   {
     "id": "api.admin.test_email.subject",
-    "translation": "Mattermost - 電子メール設定のテスト"
+    "translation": "RS-CloudOffice - 電子メール設定のテスト"
   },
   {
     "id": "api.admin.test_s3.missing_s3_bucket",
@@ -141,13 +141,21 @@
   },
   {
     "id": "api.channel.change_channel_privacy.private_to_public",
-    "translation": "このチャンネルは公開チャンネルに変更されたため、全てのチームメンバーが参加できるようになりました。"
+    "translation": "このチャンネルはパブリックチャンネルに変更されたため、全てのチームメンバーが参加できるようになりました。"
   },
   {
     "id": "api.channel.change_channel_privacy.public_to_private",
-    "translation": "このチャンネルは非公開チャンネルに変更されました。"
+    "translation": "このチャンネルはプライベートチャンネルに変更されました。"
   },
   {
+    "id": "api.channel.convert_channel_to_private.default_channel_error",
+    "translation": "このデフォルトチャンネルはプライベートチャンネルに変更できません。"
+  },
+  {
+    "id": "api.channel.convert_channel_to_private.private_channel_error",
+    "translation": "変更しようとしているチャンネルはすでにプライベートチャンネルです。"
+  },
+  {
     "id": "api.channel.create_channel.direct_channel.app_error",
     "translation": "ダイレクトメッセージチャンネルを作成するにはcreateDirectChannel APIを使用してください。"
   },
@@ -157,11 +165,11 @@
   },
   {
     "id": "api.channel.create_default_channels.off_topic",
-    "translation": "オフトピック"
+    "translation": "情報発信の場"
   },
   {
     "id": "api.channel.create_default_channels.town_square",
-    "translation": "タウンスクウェア"
+    "translation": "交流の場"
   },
   {
     "id": "api.channel.create_direct_channel.invalid_user.app_error",
@@ -209,7 +217,7 @@
   },
   {
     "id": "api.channel.leave.last_member.app_error",
-    "translation": "あなたが最後のメンバーです。脱退する代わりに非公開チャンネルを削除しましょう。"
+    "translation": "あなたが最後のメンバーです。脱退する代わりにプライベートチャンネルを削除しましょう。"
   },
   {
     "id": "api.channel.leave.left",
@@ -345,7 +353,7 @@
   },
   {
     "id": "api.command.invite_people.desc",
-    "translation": "あなたのMattermostチームへ招待する電子メールを送る"
+    "translation": "あなたのRS-CloudOfficeチームへ招待する電子メールを送る"
   },
   {
     "id": "api.command.invite_people.email_invitations_off",
@@ -683,7 +691,7 @@
   },
   {
     "id": "api.command_join.desc",
-    "translation": "公開されているチャンネルに参加する"
+    "translation": "パブリックなチャンネルに参加する"
   },
   {
     "id": "api.command_join.fail.app_error",
@@ -723,7 +731,7 @@
   },
   {
     "id": "api.command_logout.desc",
-    "translation": "Mattermostからログアウトする"
+    "translation": "RS-CloudOfficeからログアウトする"
   },
   {
     "id": "api.command_logout.name",
@@ -830,6 +838,14 @@
     "translation": "オンライン"
   },
   {
+    "id": "api.command_meeting.name",
+    "translation": "Web会議中に"
+  },
+  {
+    "id": "api.command_meeting.desc",
+    "translation": "あなたのステータスをWeb会議中に設定"
+  },
+  {
     "id": "api.command_online.success",
     "translation": "あなたはオンライン状態です"
   },
@@ -1513,7 +1529,7 @@
   },
   {
     "id": "api.slackimport.slack_add_channels.merge",
-    "translation": "Slackチャンネル {{.DisplayName}} は有効なMattermostのチャンネルとして既に存在しています。両方のチャンネルがマージされます。\r\n"
+    "translation": "Slackチャンネル {{.DisplayName}} は有効なRS-CloudOfficeのチャンネルとして既に存在しています。両方のチャンネルがマージされます。\r\n"
   },
   {
     "id": "api.slackimport.slack_add_users.created",
@@ -1525,11 +1541,11 @@
   },
   {
     "id": "api.slackimport.slack_add_users.merge_existing",
-    "translation": "電子メールアドレス {{.Email}} とユーザー名 {{.Username}} を持つ既存のMattermostユーザーとSlackユーザーをマージしました。\r\n"
+    "translation": "電子メールアドレス {{.Email}} とユーザー名 {{.Username}} を持つ既存のRS-CloudOfficeユーザーとSlackユーザーをマージしました。\r\n"
   },
   {
     "id": "api.slackimport.slack_add_users.merge_existing_failed",
-    "translation": "電子メールアドレス {{.Email}} とユーザー名 {{.Username}} を持つ既存のMattermostユーザーとSlackユーザーをマージしましたが、そのユーザーをチームに追加できませんでした。\r\n"
+    "translation": "電子メールアドレス {{.Email}} とユーザー名 {{.Username}} を持つ既存のRS-CloudOfficeユーザーとSlackユーザーをマージしましたが、そのユーザーをチームに追加できませんでした。\r\n"
   },
   {
     "id": "api.slackimport.slack_add_users.missing_email_address",
@@ -1541,7 +1557,7 @@
   },
   {
     "id": "api.slackimport.slack_import.log",
-    "translation": "Mattermost Slackインポートログ\r\n"
+    "translation": "RS-CloudOffice Slackインポートログ\r\n"
   },
   {
     "id": "api.slackimport.slack_import.note1",
@@ -1773,7 +1789,7 @@
   },
   {
     "id": "api.templates.email_change_verify_body.title",
-    "translation": "電子メールアドレスが正常に更新されました"
+    "translation": "あなたは電子メールアドレスを更新しました"
   },
   {
     "id": "api.templates.email_change_verify_subject",
@@ -1909,7 +1925,7 @@
   },
   {
     "id": "api.templates.verify_body.info",
-    "translation": "この電子メールアドレスがMattermostアカウントの作成に使用されました。"
+    "translation": "この電子メールアドレスがRS-CloudOfficeアカウントの作成に使用されました。"
   },
   {
     "id": "api.templates.verify_body.title",
@@ -2281,7 +2297,7 @@
   },
   {
     "id": "api.webhook.create_outgoing.not_open.app_error",
-    "translation": "外向きのウェブフックは、公開チャンネルに対してのみ作成できます。"
+    "translation": "外向きのウェブフックは、パブリックチャンネルに対してのみ作成できます。"
   },
   {
     "id": "api.webhook.create_outgoing.permissions.app_error",
@@ -3197,7 +3213,7 @@
   },
   {
     "id": "ent.ldap.do_login.user_filtered.app_error",
-    "translation": "あなたのAD/LDAPアカウントにはMattermostサーバを利用する権限がありません。システム管理者にAD/LDAPのユーザーフィルターをチェックするよう依頼してください。"
+    "translation": "あなたのAD/LDAPアカウントにはRS-CloudOfficeサーバを利用する権限がありません。システム管理者にAD/LDAPのユーザーフィルターをチェックするよう依頼してください。"
   },
   {
     "id": "ent.ldap.do_login.user_not_registered.app_error",
@@ -3217,7 +3233,7 @@
   },
   {
     "id": "ent.ldap.syncronize.search_failure.app_error",
-    "translation": "AD/LDAPでのユーザー検索に失敗しました。MattermostサーバーがAD/LDAPサーバーに接続できることを確認し、再度実行してください。"
+    "translation": "AD/LDAPでのユーザー検索に失敗しました。RS-CloudOfficeサーバーがAD/LDAPサーバーに接続できることを確認し、再度実行してください。"
   },
   {
     "id": "ent.ldap.validate_filter.app_error",
@@ -3313,7 +3329,7 @@
   },
   {
     "id": "ent.migration.migratetosaml.username_already_used_by_other_user",
-    "translation": "ユーザー名は既に別のMattermostユーザーによって使用されています。"
+    "translation": "ユーザー名は既に別のRS-CloudOfficeユーザーによって使用されています。"
   },
   {
     "id": "ent.saml.attribute.app_error",
@@ -3413,7 +3429,7 @@
   },
   {
     "id": "mattermost.bulletin.subject",
-    "translation": "Mattermostセキュリティー通知"
+    "translation": "RS-CloudOfficeセキュリティー通知"
   },
   {
     "id": "mfa.activate.bad_token.app_error",
@@ -4565,7 +4581,7 @@
   },
   {
     "id": "oauth.gitlab.tos.error",
-    "translation": "GitLabの利用規約が更新されました。{{.URL}}で新しい利用規約に同意してから、もう一度Mattermostへログインしてみてください。"
+    "translation": "GitLabの利用規約が更新されました。gitlab.comで新しい利用規約に同意してから、もう一度RS-CloudOfficeへログインしてみてください。"
   },
   {
     "id": "plugin.api.update_user_status.bad_status",
@@ -4729,11 +4745,11 @@
   },
   {
     "id": "web.error.unsupported_browser.no_longer_support_version",
-    "translation": "あなたのブラウザのバージョンはMattermostではサポートされていません"
+    "translation": "あなたのブラウザのバージョンはRS-CloudOfficeではサポートされていません"
   },
   {
     "id": "web.error.unsupported_browser.no_longer_support",
-    "translation": "このブラウザはMattermostではサポートされていません"
+    "translation": "このブラウザはRS-CloudOfficeではサポートされていません"
   },
   {
     "id": "web.error.unsupported_browser.min_os_version.windows",
@@ -4777,7 +4793,7 @@
   },
   {
     "id": "web.error.unsupported_browser.download_app_or_upgrade_browser",
-    "translation": "より良い体験のために、Mattermostアプリかサポートされたブラウザをダウンロードしてください。"
+    "translation": "より良い体験のために、サポートされたブラウザをダウンロードしてください。"
   },
   {
     "id": "web.error.unsupported_browser.download",
@@ -5565,11 +5581,11 @@
   },
   {
     "id": "api.team.search_teams.pagination_not_implemented.public_team_search",
-    "translation": "公開のみのチーム検索ではページネーションは利用できません。"
+    "translation": "パブリックのみのチーム検索ではページネーションは利用できません。"
   },
   {
     "id": "api.team.search_teams.pagination_not_implemented.private_team_search",
-    "translation": "非公開のみのチーム検索ではページネーションは利用できません。"
+    "translation": "プライベートのみのチーム検索ではページネーションは利用できません。"
   },
   {
     "id": "api.team.remove_member.group_constrained.app_error",
@@ -5713,7 +5729,7 @@
   },
   {
     "id": "api.channel.update_channel_privacy.default_channel_error",
-    "translation": "デフォルトチャンネルは非公開にできません。"
+    "translation": "デフォルトチャンネルはプライベートにできません。"
   },
   {
     "id": "api.channel.update_channel_member_roles.guest_and_user.app_error",
@@ -5777,7 +5793,7 @@
   },
   {
     "id": "api.bot.teams_channels.add_message_mobile",
-    "translation": "ブラウザ、もしくはMattermostデスクトップアプリから、Botをチーム・チャンネルに追加してください。"
+    "translation": "ブラウザから、Botをチーム・チャンネルに追加してください。"
   },
   {
     "id": "api.bot.create_disabled",
@@ -6329,7 +6345,7 @@
   },
   {
     "id": "api.server.warn_metric.number_of_active_users_200.notification_body",
-    "translation": "あなたのMattermostには200ユーザーが登録しています。Mattermostをあなたの組織のシングルサインオンプロバイダーに接続することで、ユーザーは再度認証情報を入力することなくMattermostへアクセスできるようになります。MattermostサーバーをSAML 2.0プロバイダーと連携することをおすすめします。詳しくは[SAML2.0連携に関する説明](https://www.mattermost.com/docs-saml/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=saml)を参照してください。\n\n問い合わせ をクリックすると、あなたの情報をMattermost, Inc. へ共有します。詳しくは[説明文書](https://mattermost.com/pl/default-admin-advisory)を参照してください"
+    "translation": "あなたのRS-CloudOfficeには200ユーザーが登録しています。RS-CloudOfficeをあなたの組織のシングルサインオンプロバイダーに接続することで、ユーザーは再度認証情報を入力することなくRS-CloudOfficeへアクセスできるようになります。RS-CloudOfficeサーバーをSAML 2.0プロバイダーと連携することをおすすめします。詳しくは[SAML2.0連携に関する説明](https://www.mattermost.com/docs-saml/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=saml)を参照してください。\n\n問い合わせ をクリックすると、あなたの情報をMattermost, Inc. へ共有します。詳しくは[説明文書](https://mattermost.com/pl/default-admin-advisory)を参照してください"
   },
   {
     "id": "model.command.is_valid.plugin_id.app_error",
@@ -6357,7 +6373,7 @@
   },
   {
     "id": "api.server.warn_metric.number_of_active_users_500.notification_title",
-    "translation": "Mattermostをスケーリングする"
+    "translation": "RS-CloudOfficeをスケーリングする"
   },
   {
     "id": "api.server.warn_metric.number_of_active_users_500.notification_body",
@@ -6365,7 +6381,7 @@
   },
   {
     "id": "api.server.warn_metric.number_of_active_users_200.notification_title",
-    "translation": "Mattermostをスケーリングする"
+    "translation": "RS-CloudOfficeをスケーリングする"
   },
   {
     "id": "api.server.warn_metric.email_us",
@@ -6373,7 +6389,7 @@
   },
   {
     "id": "api.server.warn_metric.bot_response.notification_success.message",
-    "translation": "Mattermostへお問い合わせていただき、ありがとうございます。すぐにこちらからご連絡いたします。"
+    "translation": "RS-CloudOfficeへお問い合わせていただき、ありがとうございます。すぐにこちらからご連絡いたします。"
   },
   {
     "id": "api.server.warn_metric.bot_response.notification_failure.message",
@@ -6641,11 +6657,11 @@
   },
   {
     "id": "app.team.search_private_team.app_error",
-    "translation": "非公開チームを検索する際にエラーが発生しました。"
+    "translation": "プライベートチームを検索する際にエラーが発生しました。"
   },
   {
     "id": "app.team.search_open_team.app_error",
-    "translation": "公開されているチームを検索する際にエラーが発生しました。"
+    "translation": "パブリックチームを検索する際にエラーが発生しました。"
   },
   {
     "id": "app.team.search_all_team.app_error",
@@ -6869,7 +6885,7 @@
   },
   {
     "id": "app.team.get_all_private_team_listing.app_error",
-    "translation": "全ての非公開チームを取得できませんでした。"
+    "translation": "全てのプライベートチームを取得できませんでした。"
   },
   {
     "id": "app.team.clear_all_custom_role_assignments.select.app_error",
@@ -6941,11 +6957,11 @@
   },
   {
     "id": "app.channel.get_public_channels.get.app_error",
-    "translation": "公開チャンネルを取得できませんでした。"
+    "translation": "パブリックチャンネルを取得できませんでした。"
   },
   {
     "id": "app.channel.get_private_channels.get.app_error",
-    "translation": "非公開チャンネルを取得できませんでした。"
+    "translation": "プライベートチャンネルを取得できませんでした。"
   },
   {
     "id": "app.channel.get_member_count.app_error",
@@ -7133,7 +7149,7 @@
   },
   {
     "id": "api.server.warn_metric.number_of_teams_5.start_trial.notification_body",
-    "translation": "あなたのMattermostにはいくつかのチームが存在します。多くのチームは、チャンネルの作成方法や、誰が新しいチームメイトを招待できるか、また、どのように統合機能を管理するかなどのチーム運営について各々が好む方法を持っています。チーム上書きスキームにより、それぞれの要求を満たすようチームごとにユーザー権限設定をカスタマイズできます。\n\n詳しくは[高度な権限設定に関する説明](https://www.mattermost.com/docs-advanced-permissions-team-override/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=advanced-permissions-team-override)を参照してください。\n\nトライアル開始 をクリックすると、[Mattermost Software Evaluation Agreement](https://mattermost.com/software-evaluation-agreement/) と [プライバシーポリシー](https://mattermost.com/privacy-policy/)に同意したことになり、製品に関する電子メールを受信するようになります。"
+    "translation": "あなたのRS-CloudOfficeにはいくつかのチームが存在します。多くのチームは、チャンネルの作成方法や、誰が新しいチームメイトを招待できるか、また、どのように統合機能を管理するかなどのチーム運営について各々が好む方法を持っています。チーム上書きスキームにより、それぞれの要求を満たすようチームごとにユーザー権限設定をカスタマイズできます。\n\n詳しくは[高度な権限設定に関する説明](https://www.mattermost.com/docs-advanced-permissions-team-override/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=advanced-permissions-team-override)を参照してください。\n\nトライアル開始 をクリックすると、[Mattermost Software Evaluation Agreement](https://mattermost.com/software-evaluation-agreement/) と [プライバシーポリシー](https://mattermost.com/privacy-policy/)に同意し、製品に関する電子メールを受信するようになります。"
   },
   {
     "id": "api.server.warn_metric.number_of_teams_5.notification_title",
@@ -7141,11 +7157,11 @@
   },
   {
     "id": "api.server.warn_metric.number_of_teams_5.notification_body",
-    "translation": "あなたのMattermostにはいくつかのチームが存在します。多くのチームは、チャンネルの作成方法や、誰が新しいチームメイトを招待できるか、また、どのように統合機能を管理するかなどのチーム運営について各々が好む方法を持っています。チーム上書きスキームにより、それぞれの要求を満たすようチームごとにユーザー権限設定をカスタマイズできます。\n\n詳しくは[高度な権限設定に関する説明](https://www.mattermost.com/docs-advanced-permissions-team-override/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=advanced-permissions-team-override)を参照してください。\n\n問い合わせ をクリックすることで、あなたの情報を Mattermost, Inc. へ共有します。詳しくは[説明文書](https://mattermost.com/pl/default-admin-advisory)を参照してください"
+    "translation": "あなたのRS-CloudOfficeにはいくつかのチームが存在します。多くのチームは、チャンネルの作成方法や、誰が新しいチームメイトを招待できるか、また、どのように統合機能を管理するかなどのチーム運営について各々が好む方法を持っています。チーム上書きスキームにより、それぞれの要求を満たすようチームごとにユーザー権限設定をカスタマイズできます。\n\n詳しくは[高度な権限設定に関する説明](https://www.mattermost.com/docs-advanced-permissions-team-override/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=advanced-permissions-team-override)を参照してください。\n\n問い合わせ をクリックすることで、あなたの情報を Mattermost, Inc. へ共有します。詳しくは[説明文書](https://mattermost.com/pl/default-admin-advisory)を参照してください"
   },
   {
     "id": "api.server.warn_metric.number_of_teams_5.contact_us.email_body",
-    "translation": "Mattermostへ問い合わせる。チームスキームによる高度な権限設定に興味があります。\n"
+    "translation": "RS-CloudOfficeへ問い合わせる。チームスキームによる高度な権限設定に興味があります。\n"
   },
   {
     "id": "api.server.warn_metric.number_of_posts_2M.start_trial.notification_success.message",
@@ -7153,7 +7169,7 @@
   },
   {
     "id": "api.server.warn_metric.number_of_posts_2M.start_trial.notification_body",
-    "translation": "あなたのMattermostシステムには非常に多くのメッセージがあります。Mattermostのデフォルトのデータベース検索は約250万投稿からパフォーマンスが劣化し始めます。500万投稿以上ある場合、Elasticsearchを導入することで、検索のタイムアウトなどの深刻なパフォーマンスの問題を回避することができます。Elasticsearchとの連携について詳しく知りたい場合や、何かサポートできることがないか私たちに問い合わせてください。\n\n詳しくは[パフォーマンス改善に関する説明](https://www.mattermost.com/docs-elasticsearch/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=elasticsearch)を参照してください\n\nトライアル開始 をクリックすると、[Mattermost Software Evaluation Agreement](https://mattermost.com/software-evaluation-agreement/) と [プライバシーポリシー](https://mattermost.com/privacy-policy/)に同意したことになり、製品に関する電子メールを受信するようになります。"
+    "translation": "あなたのRS-CloudOfficeシステムには非常に多くのメッセージがあります。RS-CloudOfficeのデフォルトのデータベース検索は約250万投稿からパフォーマンスが劣化し始めます。500万投稿以上ある場合、Elasticsearchを導入することで、検索のタイムアウトなどの深刻なパフォーマンスの問題を回避することができます。Elasticsearchとの連携について詳しく知りたい場合や、何かサポートできることがないか私たちに問い合わせてください。\n\n詳しくは[パフォーマンス改善に関する説明](https://www.mattermost.com/docs-elasticsearch/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=elasticsearch)を参照してください\n\nトライアル開始 をクリックすると、[Mattermost Software Evaluation Agreement](https://mattermost.com/software-evaluation-agreement/) と [プライバシーポリシー](https://mattermost.com/privacy-policy/)に同意し、製品に関する電子メールを受信するようになります。"
   },
   {
     "id": "api.server.warn_metric.number_of_posts_2M.notification_title",
@@ -7161,11 +7177,11 @@
   },
   {
     "id": "api.server.warn_metric.number_of_posts_2M.notification_body",
-    "translation": "あなたのMattermostシステムには非常に多くのメッセージがあります。Mattermostのデフォルトのデータベース検索は約250万投稿からパフォーマンスが劣化し始めます。500万投稿以上ある場合、Elasticsearchを導入することで、検索のタイムアウトなどの深刻なパフォーマンスの問題を回避することができます。Elasticsearchとの連携について詳しく知りたい場合や、何かサポートできることがないか私たちに問い合わせてください。\n\n詳しくは[パフォーマンス改善に関する説明](https://www.mattermost.com/docs-elasticsearch/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=elasticsearch)を参照してください\n\n問い合わせ をクリックすると、あなたの情報は Mattermost, Inc. へ共有されます。詳しくは[説明文書}(https://mattermost.com/pl/default-admin-advisory)を参照してください"
+    "translation": "あなたのRS-CloudOfficeシステムには非常に多くのメッセージがあります。RS-CloudOfficeのデフォルトのデータベース検索は約250万投稿からパフォーマンスが劣化し始めます。500万投稿以上ある場合、Elasticsearchを導入することで、検索のタイムアウトなどの深刻なパフォーマンスの問題を回避することができます。Elasticsearchとの連携について詳しく知りたい場合や、何かサポートできることがないか私たちに問い合わせてください。\n\n詳しくは[パフォーマンス改善に関する説明](https://www.mattermost.com/docs-elasticsearch/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=elasticsearch)を参照してください\n\n問い合わせ をクリックすると、あなたの情報は Mattermost, Inc. へ共有されます。詳しくは[説明文書}(https://mattermost.com/pl/default-admin-advisory)を参照してください"
   },
   {
     "id": "api.server.warn_metric.number_of_posts_2M.contact_us.email_body",
-    "translation": "Mattermostへ問い合わせる。Elasticsearchによるパフォーマンスの改善に興味があります。\n"
+    "translation": "RS-CloudOfficeへ問い合わせる。Elasticsearchによるパフォーマンスの改善に興味があります。\n"
   },
   {
     "id": "api.server.warn_metric.number_of_channels_50.start_trial.notification_success.message",
@@ -7173,15 +7189,15 @@
   },
   {
     "id": "api.server.warn_metric.number_of_channels_50.start_trial.notification_body",
-    "translation": "チャンネルはコミュニケーションの改善をサポートするものですが、Mattermost全体でチャンネルの作成や参加が多くなるにつれ、システムを整理されたものにし続けることが課題になってきます。高度な権限設定により、どのユーザー、もしくはどのロールの人が何のアクションを実行可能かを設定することができます。例えば、チャンネル設定やメンバーの管理や、@channel、@hereなどのタグによるグループへの発信、新たなウェブフックの作成などを制限できます。\n\n詳しくは[高度な権限設定の利用に関する説明](https://www.mattermost.com/docs-advanced-permissions/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=advanced-permissions)を参照してください\n\nトライアル開始 をクリックすると、[Mattermost Software Evaluation Agreement](https://mattermost.com/software-evaluation-agreement/) と [プライバシーポリシー](https://mattermost.com/privacy-policy/)に同意したことになり、製品に関する電子メールを受信するようになります。"
+    "translation": "チャンネルはコミュニケーションの改善をサポートするものですが、RS-CloudOffice全体でチャンネルの作成や参加が多くなるにつれ、システムを整理されたものにし続けることが課題になってきます。高度な権限設定により、どのユーザー、もしくはどの役割の人が何のアクションを実行可能かを設定することができます。例えば、チャンネル設定やメンバーの管理や、@channel、@hereなどのタグによるグループへの発信、新たなウェブフックの作成などを制限できます。\n\n詳しくは[高度な権限設定の利用に関する説明](https://www.mattermost.com/docs-advanced-permissions/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=advanced-permissions)を参照してください\n\nトライアル開始 をクリックすると、[Mattermost Software Evaluation Agreement](https://mattermost.com/software-evaluation-agreement/) と [プライバシーポリシー](https://mattermost.com/privacy-policy/)に同意し、製品に関する電子メールを受信するようになります。"
   },
   {
     "id": "api.server.warn_metric.number_of_channels_50.contact_us.email_body",
-    "translation": "Mattermostへ問い合わせる。システムスキーマによる高度な権限設定に興味があります。\n"
+    "translation": "RS-CloudOfficeへ問い合わせる。システムスキーマによる高度な権限設定に興味があります。\n"
   },
   {
     "id": "api.server.warn_metric.number_of_channels_50.notification_body",
-    "translation": "チャンネルはコミュニケーションの改善をサポートするものですが、Mattermost全体でチャンネルの作成や参加が多くなるにつれ、システムを整理されたものにし続けることが課題になってきます。高度な権限設定により、どのユーザー、もしくはどのロールの人が何のアクションを実行可能かを設定することができます。例えば、チャンネル設定やメンバーの管理や、@channel、@hereなどのタグによるグループへの発信、新たなウェブフックの作成などを制限できます。\n\n詳しくは[高度な権限設定の利用に関する説明](https://www.mattermost.com/docs-advanced-permissions/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=advanced-permissions)を参照してください\n\n問い合わせ をクリックすると、あなたの情報が Mattermost, Inc. へ共有されます。詳しくは[説明文書](https://mattermost.com/pl/default-admin-advisory)を参照してください"
+    "translation": "チャンネルはコミュニケーションの改善をサポートするものですが、RS-CloudOffice全体でチャンネルの作成や参加が多くなるにつれ、システムを整理されたものにし続けることが課題になってきます。高度な権限設定により、どのユーザー、もしくはどの役割の人が何のアクションを実行可能かを設定することができます。例えば、チャンネル設定やメンバーの管理や、@channel、@hereなどのタグによるグループへの発信、新たなウェブフックの作成などを制限できます。\n\n詳しくは[高度な権限設定の利用に関する説明](https://www.mattermost.com/docs-advanced-permissions/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=advanced-permissions)を参照してください\n\n問い合わせ をクリックすると、あなたの情報が Mattermost, Inc. へ共有されます。詳しくは[説明文書](https://mattermost.com/pl/default-admin-advisory)を参照してください"
   },
   {
     "id": "api.server.warn_metric.number_of_channels_50.notification_title",
@@ -7197,7 +7213,7 @@
   },
   {
     "id": "api.server.warn_metric.number_of_active_users_500.contact_us.email_body",
-    "translation": "Mattermostに問い合わせる。我々のチームには500名以上のユーザーがおり、Mattermost Enterprise Editionを検討しています。\n"
+    "translation": "RS-CloudOfficeに問い合わせる。我々のチームには500名以上のユーザーがおり、Mattermost Enterprise Editionを検討しています。\n"
   },
   {
     "id": "api.server.warn_metric.number_of_active_users_300.start_trial.notification_title",
@@ -7209,15 +7225,15 @@
   },
   {
     "id": "api.server.warn_metric.number_of_active_users_300.start_trial.notification_body",
-    "translation": "Mattermost全体で多くの会話がなされている場合、どこに重要な情報があるかを知るのは難しいことかもしれません。多くのユーザーに対してメッセージを配信したい場合、誰でも参加可能だがチャンネル管理者しかメッセージの投稿ができないような閲覧専用の連絡チャンネルを立てることができます。\n\n詳しくは[閲覧専用の連絡チャンネルの作成に関する説明](https://www.mattermost.com/docs-channel-moderation/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=channel-moderation)を参照してください\n\nトライアル開始 をクリックすると、[Mattermost Software Evaluation Agreement](https://mattermost.com/software-evaluation-agreement/) と [プライバシーポリシー](https://mattermost.com/privacy-policy/)に同意したことになり、製品に関する電子メールを受信するようになります。"
+    "translation": "RS-CloudOffice全体で多くの会話がなされている場合、どこに重要な情報があるかを知るのは難しいことかもしれません。多くのユーザーに対してメッセージを配信したい場合、誰でも参加可能だがチャンネル管理者しかメッセージの投稿ができないような閲覧専用の連絡チャンネルを立てることができます。\n\n詳しくは[閲覧専用の連絡チャンネルの作成に関する説明](https://www.mattermost.com/docs-channel-moderation/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=channel-moderation)を参照してください\n\nトライアル開始 をクリックすると、[Mattermost Software Evaluation Agreement](https://mattermost.com/software-evaluation-agreement/) と [プライバシーポリシー](https://mattermost.com/privacy-policy/)に同意し、製品に関する電子メールを受信するようになります。"
   },
   {
     "id": "api.server.warn_metric.number_of_active_users_300.notification_body",
-    "translation": "Mattermost全体で多くの会話がなされている場合、どこに重要な情報があるかを知るのは難しいことかもしれません。多くのユーザーに対してメッセージを配信したい場合、誰でも参加可能だがチャンネル管理者しかメッセージの投稿ができないような閲覧専用の連絡チャンネルを立てることができます。\n\n詳しくは[閲覧専用の連絡チャンネルの作成に関する説明](https://www.mattermost.com/docs-channel-moderation/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=channel-moderation)を参照してください\n\n問い合わせ をクリックすると、あなたの情報を Mattermost, Inc. へ共有します。詳しくは[説明文書](https://mattermost.com/pl/default-admin-advisory)を参照してください"
+    "translation": "RS-CloudOffice全体で多くの会話がなされている場合、どこに重要な情報があるかを知るのは難しいことかもしれません。多くのユーザーに対してメッセージを配信したい場合、誰でも参加可能だがチャンネル管理者しかメッセージの投稿ができないような閲覧専用の連絡チャンネルを立てることができます。\n\n詳しくは[閲覧専用の連絡チャンネルの作成に関する説明](https://www.mattermost.com/docs-channel-moderation/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=channel-moderation)を参照してください\n\n問い合わせ をクリックすると、あなたの情報を Mattermost, Inc. へ共有します。詳しくは[説明文書](https://mattermost.com/pl/default-admin-advisory)を参照してください"
   },
   {
     "id": "api.server.warn_metric.number_of_active_users_300.contact_us.email_body",
-    "translation": "Mattermostへ問い合わせる。閲覧専用の連絡チャンネル機能に興味があります。\n"
+    "translation": "RS-CloudOfficeへ問い合わせる。閲覧専用の連絡チャンネル機能に興味があります。\n"
   },
   {
     "id": "api.server.warn_metric.number_of_active_users_200.start_trial.notification_success.message",
@@ -7225,11 +7241,11 @@
   },
   {
     "id": "api.server.warn_metric.number_of_active_users_200.start_trial.notification_body",
-    "translation": "あなたのMattermostには200ユーザーが登録しています。Mattermostをあなたの組織のシングルサインオンプロバイダーに接続することで、ユーザーは再度認証情報を入力することなくMattermostへアクセスできるようになります。MattermostサーバーをSAML 2.0プロバイダーと連携することをおすすめします。詳しくは[SAML2.0連携に関する説明](https://www.mattermost.com/docs-saml/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=saml)を参照してください。\n\nトライアル開始 をクリックすると、[Mattermost Software Evaluation Agreement](https://mattermost.com/software-evaluation-agreement/) と [プライバシーポリシー](https://mattermost.com/privacy-policy/)に同意したことになり、製品に関する電子メールを受信するようになります。"
+    "translation": "あなたのRS-CloudOfficeには200ユーザーが登録しています。RS-CloudOfficeをあなたの組織のシングルサインオンプロバイダーに接続することで、ユーザーは再度認証情報を入力することなくRS-CloudOfficeへアクセスできるようになります。RS-CloudOfficeサーバーをSAML 2.0プロバイダーと連携することをおすすめします。詳しくは[SAML2.0連携に関する説明](https://www.mattermost.com/docs-saml/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=saml)を参照してください。\n\nトライアル開始 をクリックすると、[Mattermost Software Evaluation Agreement](https://mattermost.com/software-evaluation-agreement/) と [プライバシーポリシー](https://mattermost.com/privacy-policy/)に同意し、製品に関する電子メールを受信するようになります。"
   },
   {
     "id": "api.server.warn_metric.number_of_active_users_200.contact_us.email_body",
-    "translation": "Mattermostへ問い合わせる。我々のチームには200名以上のユーザーがおり、Mattermost Enterprise Editionを検討しています。\n"
+    "translation": "RS-CloudOfficeへ問い合わせる。我々のチームには200名以上のユーザーがおり、Mattermost Enterprise Editionを検討しています。\n"
   },
   {
     "id": "api.server.warn_metric.number_of_active_users_100.start_trial.notification_success.message",
@@ -7237,19 +7253,19 @@
   },
   {
     "id": "api.server.warn_metric.number_of_active_users_100.start_trial.notification_body",
-    "translation": "あなたのMattermostには100名以上のユーザーがいます。ユーザー数が増加するにつれ、新しいアカウントの準備などは時間のかかる作業となっていく可能性があります。組織のActive Directory/LDAPと連携し、誰でも組織のアカウントでMattermostにアクセス可能となるよう設定することをおすすめします。\n\n詳しくは[AD/LDAP連携に関する説明](https://www.mattermost.com/docs-adldap/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=adldap)を参照してください\n\nトライアル開始 をクリックすると、[Mattermost Software Evaluation Agreement](https://mattermost.com/software-evaluation-agreement/) と [プライバシーポリシー](https://mattermost.com/privacy-policy/) に同意したことになり、製品に関する電子メールを受信するようになります。"
+    "translation": "あなたのRS-CloudOfficeには100名以上のユーザーがいます。ユーザー数が増加するにつれ、新しいアカウントの準備などは時間のかかる作業となっていく可能性があります。組織のActive Directory/LDAPと連携し、誰でも組織のアカウントでRS-CloudOfficeにアクセス可能となるよう設定することをおすすめします。\n\n詳しくは[AD/LDAP連携に関する説明](https://www.mattermost.com/docs-adldap/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=adldap)を参照してください\n\nトライアル開始 をクリックすると、[Mattermost Software Evaluation Agreement](https://mattermost.com/software-evaluation-agreement/) と [プライバシーポリシー](https://mattermost.com/privacy-policy/) に同意し、製品に関する電子メールを受信するようになります。"
   },
   {
     "id": "api.server.warn_metric.number_of_active_users_100.notification_title",
-    "translation": "Mattermostをスケールする"
+    "translation": "RS-CloudOfficeをスケールする"
   },
   {
     "id": "api.server.warn_metric.number_of_active_users_100.notification_body",
-    "translation": "あなたのMattermostには100名以上のユーザーがいます。ユーザー数が増加するにつれ、新しいアカウントの準備などは時間のかかる作業となっていく可能性があります。組織のActive Directory/LDAPと連携し、誰でも組織のアカウントでMattermostにアクセス可能となるよう設定することをおすすめします。\n\n詳しくは[AD/LDAP連携に関する説明](https://www.mattermost.com/docs-adldap/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=adldap)を参照してください\n\n問い合わせ をクリックすると、あなたの情報を Mattermost, Inc. へ共有します。詳しくは[説明文書](https://mattermost.com/pl/default-admin-advisory)を参照してください"
+    "translation": "あなたのRS-CloudOfficeには100名以上のユーザーがいます。ユーザー数が増加するにつれ、新しいアカウントの準備などは時間のかかる作業となっていく可能性があります。組織のActive Directory/LDAPと連携し、誰でも組織のアカウントでRS-CloudOfficeにアクセス可能となるよう設定することをおすすめします。\n\n詳しくは[AD/LDAP連携に関する説明](https://www.mattermost.com/docs-adldap/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=adldap)を参照してください\n\n問い合わせ をクリックすると、あなたの情報を Mattermost, Inc. へ共有します。詳しくは[説明文書](https://mattermost.com/pl/default-admin-advisory)を参照してください"
   },
   {
     "id": "api.server.warn_metric.number_of_active_users_100.contact_us.email_body",
-    "translation": "Mattermostへ問い合わせる。我々のチームには100名以上のユーザーがおり、Mattermost Enterprise Editionを検討しています。\n"
+    "translation": "RS-CloudOfficeへ問い合わせる。我々のチームには100名以上のユーザーがおり、Mattermost Enterprise Editionを検討しています。\n"
   },
   {
     "id": "api.server.warn_metric.mfa.start_trial_notification_success.message",
@@ -7257,7 +7273,7 @@
   },
   {
     "id": "api.server.warn_metric.mfa.start_trial.notification_body",
-    "translation": "このMattermostでは多要素認証が有効になっており、ユーザーはパスワードとは別の認証を追加することで、アカウントをより安全にすることを選択できます。システム全体のセキュリティを改善するために、すべてのアカウントに対して多要素認証の利用を要求することもできます。\n\n詳しくは[多要素認証の強制についての説明](https://www.mattermost.com/docs-multi-factor-authentication/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=multi-factor-authentication)を参照してください。\n\nトライアル開始 をクリックすると、[Mattermost Software Evaluation Agreement](https://mattermost.com/software-evaluation-agreement/) と [プライバシーポリシー](https://mattermost.com/privacy-policy/)に同意したことになり、製品に関する電子メールを受信するようになります。"
+    "translation": "このRS-CloudOfficeでは多要素認証が有効になっており、ユーザーはパスワードとは別の認証を追加することで、アカウントをより安全にすることを選択できます。システム全体のセキュリティを改善するために、すべてのアカウントに対して多要素認証の利用を要求することもできます。\n\n詳しくは[多要素認証の強制についての説明](https://www.mattermost.com/docs-multi-factor-authentication/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=multi-factor-authentication)を参照してください。\n\nトライアル開始 をクリックすると、[Mattermost Software Evaluation Agreement](https://mattermost.com/software-evaluation-agreement/) と [プライバシーポリシー](https://mattermost.com/privacy-policy/)に同意し、製品に関する電子メールを受信するようになります。"
   },
   {
     "id": "api.server.warn_metric.mfa.notification_title",
@@ -7265,11 +7281,11 @@
   },
   {
     "id": "api.server.warn_metric.mfa.notification_body",
-    "translation": "このMattermostでは多要素認証が有効になっており、ユーザーはパスワードとは別の認証を追加することで、アカウントをより安全にすることを選択できます。システム全体のセキュリティを改善するために、すべてのアカウントに対して多要素認証の利用を要求することもできます。\n\n詳しくは[多要素認証の強制についての説明](https://www.mattermost.com/docs-multi-factor-authentication/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=multi-factor-authentication)を参照してください。\n\n問い合わせ をクリックすると、あなたの情報が Mattermost, Inc. へ共有されます。詳しくは[説明文書](https://mattermost.com/pl/default-admin-advisory)を参照してください"
+    "translation": "このRS-CloudOfficeでは多要素認証が有効になっており、ユーザーはパスワードとは別の認証を追加することで、アカウントをより安全にすることを選択できます。システム全体のセキュリティを改善するために、すべてのアカウントに対して多要素認証の利用を要求することもできます。\n\n詳しくは[多要素認証の強制についての説明](https://www.mattermost.com/docs-multi-factor-authentication/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=multi-factor-authentication)を参照してください。\n\n問い合わせ をクリックすると、あなたの情報が Mattermost, Inc. へ共有されます。詳しくは[説明文書](https://mattermost.com/pl/default-admin-advisory)を参照してください"
   },
   {
     "id": "api.server.warn_metric.mfa.contact_us.email_body",
-    "translation": "Mattermostへ問い合わせる。多要素認証の強制機能について興味があります。\n"
+    "translation": "RS-CloudOfficeへ問い合わせる。多要素認証の強制機能について興味があります。\n"
   },
   {
     "id": "api.server.warn_metric.email_domain.start_trial_notification_success.message",
@@ -7277,7 +7293,7 @@
   },
   {
     "id": "api.server.warn_metric.email_domain.start_trial.notification_body",
-    "translation": "プロジェクトには組織内、組織外の両方の人が参画することがあります。ゲストアカウント機能により、外部のパートナーをMattermostに参加させることができ、ゲストが閲覧可能な情報などの設定を行うことができます。\n\n詳しくは[ゲストアカウントに関する説明](https://www.mattermost.com/docs-guest-accounts/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=guest-accounts)を参照してください。\n\nトライアル開始 をクリックすると、[Mattermost Software Evaluation Agreement](https://mattermost.com/software-evaluation-agreement/) と [プライバシーポリシー](https://mattermost.com/privacy-policy/) に同意したことになり、製品に関する電子メールを受信するようになります。"
+    "translation": "プロジェクトには組織内、組織外の両方の人が参画することがあります。ゲストアカウント機能により、外部のパートナーをRS-CloudOfficeに参加させることができ、ゲストが閲覧可能な情報などの設定を行うことができます。\n\n詳しくは[ゲストアカウントに関する説明](https://www.mattermost.com/docs-guest-accounts/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=guest-accounts)を参照してください。\n\nトライアル開始 をクリックすると、[Mattermost Software Evaluation Agreement](https://mattermost.com/software-evaluation-agreement/) と [プライバシーポリシー](https://mattermost.com/privacy-policy/) に同意し、製品に関する電子メールを受信するようになります。"
   },
   {
     "id": "api.server.warn_metric.email_domain.notification_title",
@@ -7285,11 +7301,11 @@
   },
   {
     "id": "api.server.warn_metric.email_domain.notification_body",
-    "translation": "プロジェクトには組織内、組織外の両方の人が参画することがあります。ゲストアカウント機能により、外部のパートナーをMattermostに参加させることができ、ゲストが閲覧可能な情報などの設定を行うことができます。\n\n詳しくは[ゲストアカウントに関する説明](https://www.mattermost.com/docs-guest-accounts/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=guest-accounts)を参照してください。\n\n問い合わせ をクリックすると、あなたの情報が Mattermost Inc. へ送信されます。詳しくは[説明文書](https://mattermost.com/pl/default-admin-advisory)を参照してください"
+    "translation": "プロジェクトには組織内、組織外の両方の人が参画することがあります。ゲストアカウント機能により、外部のパートナーをRS-CloudOfficeに参加させることができ、ゲストが閲覧可能な情報などの設定を行うことができます。\n\n詳しくは[ゲストアカウントに関する説明](https://www.mattermost.com/docs-guest-accounts/?utm_medium=product&utm_source=mattermost-advisor-bot&utm_content=guest-accounts)を参照してください。\n\n問い合わせ をクリックすると、あなたの情報が Mattermost Inc. へ送信されます。詳しくは[説明文書](https://mattermost.com/pl/default-admin-advisory)を参照してください"
   },
   {
     "id": "api.server.warn_metric.email_domain.contact_us.email_body",
-    "translation": "Mattermostへ問い合わせる。ゲストアカウント機能について興味があります。\n"
+    "translation": "RS-CloudOfficeへ問い合わせる。ゲストアカウント機能について興味があります。\n"
   },
   {
     "id": "api.server.warn_metric.bot_response.start_trial_failure.message",
@@ -7441,7 +7457,7 @@
   },
   {
     "id": "api.templates.copyright",
-    "translation": "© 2021 Mattermost, Inc. 530 Lytton Avenue, Second floor, Palo Alto, CA, 94301"
+    "translation": "© 2021 RS-CloudOffice"
   },
   {
     "id": "app.user.permanent_delete.app_error",
@@ -8045,7 +8061,7 @@
   },
   {
     "id": "api.templates.email_footer_v2",
-    "translation": "© 2022 Mattermost, Inc. 530 Lytton Avenue, Second floor, Palo Alto, CA, 94301"
+    "translation": "© 2021 RS-CloudOffice"
   },
   {
     "id": "store.sql_file_info.search.disabled",
@@ -8157,7 +8173,7 @@
   },
   {
     "id": "api.templates.invite_body_footer.title",
-    "translation": "Mattermostとは?"
+    "translation": "RS-CloudOfficeとは?"
   },
   {
     "id": "api.templates.invite_body_footer.learn_more",
@@ -8165,11 +8181,11 @@
   },
   {
     "id": "api.templates.invite_body_footer.info",
-    "translation": "Mattermostは、セキュアなチームコラボレーションを可能にする、柔軟なオープンソースのメッセージングプラットフォームです。"
+    "translation": "RS-CloudOfficeは、セキュアなチームコラボレーションを可能にする、柔軟なオープンソースのメッセージングプラットフォームです。"
   },
   {
     "id": "api.templates.invite_body.subTitle",
-    "translation": "Mattermostでチームとの共同作業を始める"
+    "translation": "RS-CloudOfficeでチームとの共同作業を始める"
   },
   {
     "id": "api.templates.cloud_welcome_email.title",
@@ -8233,7 +8249,7 @@
   },
   {
     "id": "api.templates.cloud_welcome_email.button",
-    "translation": "Mattermostを開く"
+    "translation": "RS-CloudOfficeを開く"
   },
   {
     "id": "api.templates.cloud_welcome_email.add_apps_info",
@@ -8405,7 +8421,7 @@
   },
   {
     "id": "api.command_share.invite_remote.help",
-    "translation": "現在の共有チャネルに外部Mattermostインスタンスを招待する"
+    "translation": "現在の共有チャネルに外部RS-CloudOfficeインスタンスを招待する"
   },
   {
     "id": "api.command_share.invitation_sent",
@@ -8429,7 +8445,7 @@
   },
   {
     "id": "api.command_share.desc",
-    "translation": "現在のチャンネルを外部Mattermostインスタンスへ共有します。"
+    "translation": "現在のチャンネルを外部RS-CloudOfficeインスタンスへ共有します。"
   },
   {
     "id": "api.command_share.check_channel_exist.error",
@@ -8533,7 +8549,7 @@
   },
   {
     "id": "api.command_remote.invite_summary",
-    "translation": "以下の AES-256bit で暗号化されたデータを、パスワードと共に外部Mattermostのシステム管理者に送信します。彼らは `{{.Command}}` のスラッシュコマンドを使って招待を受け付けます。\n\n```\n{{.Invitation}}\n```\n\n**安全な接続により、あなたのMattermostインスタンスに次のURLでアクセスできるようにします** {{.SiteURL}}"
+    "translation": "以下の AES-256bit で暗号化されたデータを、パスワードと共に外部RS-CloudOfficeのシステム管理者に送信します。彼らは `{{.Command}}` のスラッシュコマンドを使って招待を受け付けます。\n\n```\n{{.Invitation}}\n```\n\n**安全な接続により、あなたのRS-CloudOfficeインスタンスに次のURLでアクセスできるようにします** {{.SiteURL}}"
   },
   {
     "id": "api.command_remote.invite_password.hint",
@@ -8577,7 +8593,7 @@
   },
   {
     "id": "api.command_remote.desc",
-    "translation": "Mattermostインスタンス間のコミュニケーションのために、安全な接続を構築します。"
+    "translation": "RS-CloudOfficeインスタンス間のコミュニケーションのために、安全な接続を構築します。"
   },
   {
     "id": "api.command_remote.decode_invitation.error",
@@ -8601,7 +8617,7 @@
   },
   {
     "id": "api.command_remote.accept.help",
-    "translation": "外部のMattermostインスタンスからの招待を受け付ける"
+    "translation": "外部のRS-CloudOfficeインスタンスからの招待を受け付ける"
   },
   {
     "id": "api.cloud.cws_webhook_event_missing_error",
@@ -8657,7 +8673,7 @@
   },
   {
     "id": "app.notification.footer.infoLogin",
-    "translation": "Mattermostへログインし"
+    "translation": "RS-CloudOfficeへログインし"
   },
   {
     "id": "app.notification.footer.info",
@@ -8713,7 +8729,7 @@
   },
   {
     "id": "api.email_batching.send_batched_email_notification.button",
-    "translation": "Mattermostを開く"
+    "translation": "RS-CloudOfficeを開く"
   },
   {
     "id": "api.channel.create_channel.direct_channel.team_restricted_error",
@@ -8811,6 +8827,766 @@
     "id": "api.templates.license_up_for_renewal_title",
     "translation": "あなたのMattermostのサブスクリプションは更新が必要です"
   },
+      {
+        "id": "api.meeting.timezone.Etc/GMT+12",
+        "translation": "(UTC-12:00) 国際日付変更線 西側"
+    },
+    {
+        "id": "api.meeting.timezone.Etc/GMT+11",
+        "translation": "(UTC-11:00) 協定世界時-11"
+    },
+    {
+        "id": "api.meeting.timezone.Pacific/Honolulu",
+        "translation": "(UTC-10:00) ハワイ"
+    },
+    {
+        "id": "api.meeting.timezone.Pacific/Marquesas",
+        "translation": "(UTC-09:30) マルキーズ諸島"
+    },
+    {
+        "id": "api.meeting.timezone.America/Anchorage",
+        "translation": "(UTC-09:00) アラスカ"
+    },
+    {
+        "id": "api.meeting.timezone.America/Santa_Isabel",
+        "translation": "(UTC-08:00) バハカリフォルニア"
+    },
+    {
+        "id": "api.meeting.timezone.America/Los_Angeles",
+        "translation": "(UTC-08:00) 太平洋標準時(米国およびカナダ)"
+    },
+    {
+        "id": "api.meeting.timezone.America/Chihuahua",
+        "translation": "(UTC-07:00) チワワ、ラパス、マサトラン"
+    },
+    {
+        "id": "api.meeting.timezone.America/Phoenix",
+        "translation": "(UTC-07:00) アリゾナ"
+    },
+    {
+        "id": "api.meeting.timezone.America/Denver",
+        "translation": "(UTC-07:00) 山地標準時(米国およびカナダ)"
+    },
+    {
+        "id": "api.meeting.timezone.America/Guatemala",
+        "translation": "(UTC-06:00) 中央アメリカ"
+    },
+    {
+        "id": "api.meeting.timezone.America/Chicago",
+        "translation": "(UTC-06:00) 中部標準時(米国およびカナダ)"
+    },
+    {
+        "id": "api.meeting.timezone.America/Regina",
+        "translation": "(UTC-06:00) サスカチュワン"
+    },
+    {
+        "id": "api.meeting.timezone.America/Mexico_City",
+        "translation": "(UTC-06:00) グアダラハラ、メキシコシティ、モンテレー"
+    },
+    {
+        "id": "api.meeting.timezone.America/Bogota",
+        "translation": "(UTC-05:00) ボゴタ、リマ、キト"
+    },
+    {
+        "id": "api.meeting.timezone.America/Indiana/Indianapolis",
+        "translation": "(UTC-05:00) インディアナ東部"
+    },
+    {
+        "id": "api.meeting.timezone.America/New_York",
+        "translation": "(UTC-05:00) 東部標準時(米国およびカナダ)"
+    },
+    {
+        "id": "api.meeting.timezone.America/Halifax",
+        "translation": "(UTC-04:00) 大西洋標準時(カナダ)"
+    },
+    {
+        "id": "api.meeting.timezone.America/Asuncion",
+        "translation": "(UTC-04:00) アスンシオン"
+    },
+    {
+        "id": "api.meeting.timezone.America/La_Paz",
+        "translation": "(UTC-04:00) ジョージタウン、ラパス、マナウス、サンフアン"
+    },
+    {
+        "id": "api.meeting.timezone.America/Cuiaba",
+        "translation": "(UTC-04:00) クイアバ"
+    },
+    {
+        "id": "api.meeting.timezone.America/Santiago",
+        "translation": "(UTC-04:00) サンチアゴ"
+    },
+    {
+        "id": "api.meeting.timezone.America/St_Johns",
+        "translation": "(UTC-03:30) ニューファンドランド"
+    },
+    {
+        "id": "api.meeting.timezone.America/Sao_Paulo",
+        "translation": "(UTC-03:00) ブラジリア"
+    },
+    {
+        "id": "api.meeting.timezone.America/Godthab",
+        "translation": "(UTC-03:00) グリーンランド"
+    },
+    {
+        "id": "api.meeting.timezone.America/Cayenne",
+        "translation": "(UTC-03:00) カイエンヌ、フォルタレザ"
+    },
+    {
+        "id": "api.meeting.timezone.America/Argentina/Buenos_Aires",
+        "translation": "(UTC-03:00) ブエノスアイレス"
+    },
+    {
+        "id": "api.meeting.timezone.America/Montevideo",
+        "translation": "(UTC-03:00) モンテビデオ"
+    },
+    {
+        "id": "api.meeting.timezone.Etc/GMT+2",
+        "translation": "(UTC-02:00) 協定世界時-2"
+    },
+    {
+        "id": "api.meeting.timezone.Atlantic/Cape_Verde",
+        "translation": "(UTC-01:00) カーボベルデ諸島"
+    },
+    {
+        "id": "api.meeting.timezone.Atlantic/Azores",
+        "translation": "(UTC-01:00) アゾレス"
+    },
+    {
+        "id": "api.meeting.timezone.Africa/Casablanca",
+        "translation": "(UTC+00:00) カサブランカ"
+    },
+    {
+        "id": "api.meeting.timezone.Atlantic/Reykjavik",
+        "translation": "(UTC+00:00) モンロビア、レイキャビク"
+    },
+    {
+        "id": "api.meeting.timezone.Europe/London",
+        "translation": "(UTC+00:00) ダブリン、エジンバラ、リスボン、ロンドン"
+    },
+    {
+        "id": "api.meeting.timezone.Etc/GMT",
+        "translation": "(UTC+00:00) 協定世界時"
+    },
+    {
+        "id": "api.meeting.timezone.Europe/Berlin",
+        "translation": "(UTC+01:00) アムステルダム、ベルリン、ベルン、ローマ、ストックホルム、ウィーン"
+    },
+    {
+        "id": "api.meeting.timezone.Europe/Paris",
+        "translation": "(UTC+01:00) ブリュッセル、コペンハーゲン、マドリード、パリ"
+    },
+    {
+        "id": "api.meeting.timezone.Africa/Lagos",
+        "translation": "(UTC+01:00) 西中央アフリカ"
+    },
+    {
+        "id": "api.meeting.timezone.Europe/Budapest",
+        "translation": "(UTC+01:00) ベオグラード、ブラチスラバ、ブダペスト、リュブリャナ、プラハ"
+    },
+    {
+        "id": "api.meeting.timezone.Europe/Warsaw",
+        "translation": "(UTC+01:00) サラエボ、スコピエ、ワルシャワ、ザグレブ"
+    },
+    {
+        "id": "api.meeting.timezone.Africa/Windhoek",
+        "translation": "(UTC+01:00) ウィントフック"
+    },
+    {
+        "id": "api.meeting.timezone.Europe/Istanbul",
+        "translation": "(UTC+02:00) アテネ、ブカレスト、イスタンブール"
+    },
+    {
+        "id": "api.meeting.timezone.Europe/Kiev",
+        "translation": "(UTC+02:00) ヘルシンキ、キエフ、リガ、ソフィア、タリン、ビリニュス"
+    },
+    {
+        "id": "api.meeting.timezone.Africa/Cairo",
+        "translation": "(UTC+02:00) カイロ"
+    },
+    {
+        "id": "api.meeting.timezone.Asia/Damascus",
+        "translation": "(UTC+02:00) ダマスカス"
+    },
+    {
+        "id": "api.meeting.timezone.Asia/Amman",
+        "translation": "(UTC+02:00) アンマン"
+    },
+    {
+        "id": "api.meeting.timezone.Africa/Johannesburg",
+        "translation": "(UTC+02:00) ハラーレ、プレトリア"
+    },
+    {
+        "id": "api.meeting.timezone.Asia/Jerusalem",
+        "translation": "(UTC+02:00) エルサレム"
+    },
+    {
+        "id": "api.meeting.timezone.Asia/Beirut",
+        "translation": "(UTC+02:00) ベイルート"
+    },
+    {
+        "id": "api.meeting.timezone.Asia/Baghdad",
+        "translation": "(UTC+03:00) バグダッド"
+    },
+    {
+        "id": "api.meeting.timezone.Europe/Minsk",
+        "translation": "(UTC+03:00) ミンスク"
+    },
+    {
+        "id": "api.meeting.timezone.Asia/Riyadh",
+        "translation": "(UTC+03:00) クエート、リヤド"
+    },
+    {
+        "id": "api.meeting.timezone.Africa/Nairobi",
+        "translation": "(UTC+03:00) ナイロビ"
+    },
+    {
+        "id": "api.meeting.timezone.Asia/Tehran",
+        "translation": "(UTC+03:30) テヘラン"
+    },
+    {
+        "id": "api.meeting.timezone.Europe/Moscow",
+        "translation": "(UTC+04:00) モスクワ、サンクトペテルブルグ、ボルゴグラード"
+    },
+    {
+        "id": "api.meeting.timezone.Asia/Tbilisi",
+        "translation": "(UTC+04:00) トビリシ"
+    },
+    {
+        "id": "api.meeting.timezone.Asia/Yerevan",
+        "translation": "(UTC+04:00) エレバン"
+    },
+    {
+        "id": "api.meeting.timezone.Asia/Dubai",
+        "translation": "(UTC+04:00) アブダビ、マスカット"
+    },
+    {
+        "id": "api.meeting.timezone.Asia/Baku",
+        "translation": "(UTC+04:00) バクー"
+    },
+    {
+        "id": "api.meeting.timezone.Indian/Mauritius",
+        "translation": "(UTC+04:00) ポートルイス"
+    },
+    {
+        "id": "api.meeting.timezone.Asia/Kabul",
+        "translation": "(UTC+04:30) カブール"
+    },
+    {
+        "id": "api.meeting.timezone.Asia/Tashkent",
+        "translation": "(UTC+05:00) タシケント"
+    },
+    {
+        "id": "api.meeting.timezone.Asia/Karachi",
+        "translation": "(UTC+05:00) イスラマバード、カラチ"
+    },
+    {
+        "id": "api.meeting.timezone.Asia/Colombo",
+        "translation": "(UTC+05:30) スリジャヤワルダナプラコッテ"
+    },
+    {
+        "id": "api.meeting.timezone.Asia/Kolkata",
+        "translation": "(UTC+05:30) チェンナイ、コルカタ、ムンバイ、ニューデリー"
+    },
+    {
+        "id": "api.meeting.timezone.Asia/Kathmandu",
+        "translation": "(UTC+05:45) カトマンズ"
+    },
+    {
+        "id": "api.meeting.timezone.Asia/Almaty",
+        "translation": "(UTC+06:00) アスタナ"
+    },
+    {
+        "id": "api.meeting.timezone.Asia/Dhaka",
+        "translation": "(UTC+06:00) ダッカ"
+    },
+    {
+        "id": "api.meeting.timezone.Asia/Yekaterinburg",
+        "translation": "(UTC+06:00) エカテリンブルグ"
+    },
+    {
+        "id": "api.meeting.timezone.Asia/Yangon",
+        "translation": "(UTC+06:30) ヤンゴン"
+    },
+    {
+        "id": "api.meeting.timezone.Asia/Bangkok",
+        "translation": "(UTC+07:00) バンコク、ハノイ、ジャカルタ"
+    },
+    {
+        "id": "api.meeting.timezone.Asia/Novosibirsk",
+        "translation": "(UTC+07:00) ノヴォシビルスク"
+    },
+    {
+        "id": "api.meeting.timezone.Asia/Krasnoyarsk",
+        "translation": "(UTC+08:00) クラスノヤルスク"
+    },
+    {
+        "id": "api.meeting.timezone.Asia/Ulaanbaatar",
+        "translation": "(UTC+08:00) ウランバートル"
+    },
+    {
+        "id": "api.meeting.timezone.Asia/Shanghai",
+        "translation": "(UTC+08:00) 北京、重慶、香港、ウルムチ"
+    },
+    {
+        "id": "api.meeting.timezone.Australia/Perth",
+        "translation": "(UTC+08:00) パース"
+    },
+    {
+        "id": "api.meeting.timezone.Asia/Singapore",
+        "translation": "(UTC+08:00) クアラルンプール、シンガポール"
+    },
+    {
+        "id": "api.meeting.timezone.Asia/Taipei",
+        "translation": "(UTC+08:00) 台北"
+    },
+    {
+        "id": "api.meeting.timezone.Australia/Eucla",
+        "translation": "(UTC+08:45) オーストラリア西部(ユクラ)"
+    },
+    {
+        "id": "api.meeting.timezone.Asia/Irkutsk",
+        "translation": "(UTC+09:00) イルクーツク"
+    },
+    {
+        "id": "api.meeting.timezone.Asia/Seoul",
+        "translation": "(UTC+09:00) ソウル"
+    },
+    {
+        "id": "api.meeting.timezone.Asia/Tokyo",
+        "translation": "(UTC+09:00) 大阪、札幌、東京"
+    },
+    {
+        "id": "api.meeting.timezone.Australia/Darwin",
+        "translation": "(UTC+09:30) ダーウィン"
+    },
+    {
+        "id": "api.meeting.timezone.Australia/Adelaide",
+        "translation": "(UTC+09:30) アデレード"
+    },
+    {
+        "id": "api.meeting.timezone.Australia/Hobart",
+        "translation": "(UTC+10:00) ホバート"
+    },
+    {
+        "id": "api.meeting.timezone.Asia/Yakutsk",
+        "translation": "(UTC+10:00) ヤクーツク"
+    },
+    {
+        "id": "api.meeting.timezone.Australia/Brisbane",
+        "translation": "(UTC+10:00) ブリスベン"
+    },
+    {
+        "id": "api.meeting.timezone.Pacific/Port_Moresby",
+        "translation": "(UTC+10:00) グアム、ポートモレスビー"
+    },
+    {
+        "id": "api.meeting.timezone.Australia/Sydney",
+        "translation": "(UTC+10:00) キャンベラ、メルボルン、シドニー"
+    },
+    {
+        "id": "api.meeting.timezone.Australia/LHI",
+        "translation": "(UTC+10:30) ロード・ハウ島"
+    },
+    {
+        "id": "api.meeting.timezone.Asia/Vladivostok",
+        "translation": "(UTC+11:00) ウラジオストク"
+    },
+    {
+        "id": "api.meeting.timezone.Pacific/Guadalcanal",
+        "translation": "(UTC+11:00) ソロモン諸島、ニューカレドニア"
+    },
+    {
+        "id": "api.meeting.timezone.Etc/GMT-12",
+        "translation": "(UTC+12:00) 協定世界時+12"
+    },
+    {
+        "id": "api.meeting.timezone.Pacific/Fiji",
+        "translation": "(UTC+12:00) フィジー、マーシャル諸島"
+    },
+    {
+        "id": "api.meeting.timezone.Asia/Magadan",
+        "translation": "(UTC+12:00) マガダン"
+    },
+    {
+        "id": "api.meeting.timezone.Pacific/Auckland",
+        "translation": "(UTC+12:00) オークランド、ウェリントン"
+    },
+    {
+        "id": "api.meeting.timezone.Pacific/Chatham",
+        "translation": "(UTC+12:45) チャタム諸島"
+    },
+    {
+        "id": "api.meeting.timezone.Pacific/Tongatapu",
+        "translation": "(UTC+13:00) ヌクアロファ"
+    },
+    {
+        "id": "api.meeting.timezone.Pacific/Apia",
+        "translation": "(UTC+13:00) サモア"
+    },
+    {
+        "id": "api.meeting.timezone.Pacific/Kiritimati",
+        "translation": "(UTC+14:00) ライン諸島"
+    },
+    {
+        "id": "api.meeting.server_opt.app_error",
+        "translation": "サーバ内部エラー、管理者に連絡してください。"
+    },
+    {
+        "id": "api.meeting.meeting_not_exist.app_error",
+        "translation": "会議情報が存在しません。"
+    },
+    {
+        "id": "api.meeting.mail_send.app_error",
+        "translation": "下記のメールアドレスの送信に失敗しました。{{ .FailedMailAddrs }}。管理者に連絡してください。"
+    },
+    {
+        "id": "api.meeting.mail_format.app_error",
+        "translation": "招待者のメールアドレスを確認してください。メールアドレスの区切りとして「;」を使ってください。"
+    },
+    {
+      "id": "api.meeting.meeting_duplicated.app_error",
+      "translation": "会議名と参加者が同じ会議がありますので、予約ができません。確認してください。"
+    },
+    {
+        "id": "api.meeting.mail.terminate_template",
+        "translation": "{{ .UserName }}がこの会議の開催を中止しました。<br/><br/>{{ .RepeatMeetingInfo }}{{ .StartAtYear }}年{{ .StartAtMonth }}月{{ .StartAtDay }}日 {{ .StartAtHour }}:{{ .StartAtMinute }} - {{ .EndAtYear }}年{{ .EndAtMonth }}月{{ .EndAtDay }}日 {{ .EndAtHour }}:{{ .EndAtMinute }}<br/>{{ .TimeZone }}"
+    },
+    {
+        "id": "api.meeting.mail.change_template",
+        "translation": "{{ .UserName }}がスケジュールされた会議を変更しました。参加日時になったら、ここからミーティングに参加してください。<br/><br/>{{ .RepeatMeetingInfo }}{{ .StartAtYear }}年{{ .StartAtMonth }}月{{ .StartAtDay }}日 {{ .StartAtHour }}:{{ .StartAtMinute }} - {{ .EndAtYear }}年{{ .EndAtMonth }}月{{ .EndAtDay }}日 {{ .EndAtHour }}:{{ .EndAtMinute }}<br/>{{ .TimeZone }}<br/><br/>会議に参加する<br/>&lt;{{ .MeetingUrl }}&gt;<br/>添付ファイルをクリックして、会議をカレンダーに追加します"
+    },
+    {
+        "id": "api.meeting.mail.invite_template",
+        "translation": "{{ .UserName }}があなたをスケジュールされた会議に招待しています。<br/><br/>{{ .RepeatMeetingInfo }}{{ .StartAtYear }}年{{ .StartAtMonth }}月{{ .StartAtDay }}日 {{ .StartAtHour }}:{{ .StartAtMinute }} - {{ .EndAtYear }}年{{ .EndAtMonth }}月{{ .EndAtDay }}日 {{ .EndAtHour }}:{{ .EndAtMinute }}<br/>{{ .TimeZone }}<br/><br/>会議に参加する<br/>&lt;{{ .MeetingUrl }}&gt;<br/>添付ファイルをクリックして、会議をカレンダーに追加します"
+    },
+    {
+        "id": "api.meeting.mail.terminate_template_host",
+        "translation": "あなた（{{ .UserName }}）は、この会議の開催を中止しました。<br/><br/>{{ .RepeatMeetingInfo }}{{ .StartAtYear }}年{{ .StartAtMonth }}月{{ .StartAtDay }}日 {{ .StartAtHour }}:{{ .StartAtMinute }} - {{ .EndAtYear }}年{{ .EndAtMonth }}月{{ .EndAtDay }}日 {{ .EndAtHour }}:{{ .EndAtMinute }}<br/>{{ .TimeZone }}"
+    },
+    {
+        "id": "api.meeting.mail.change_template_host",
+        "translation": "あなた（{{ .UserName }}）は、この会議の情報を変更しました。開催日時になったら、ここからミーティングを開始してください。<br/><br/>{{ .RepeatMeetingInfo }}{{ .StartAtYear }}年{{ .StartAtMonth }}月{{ .StartAtDay }}日 {{ .StartAtHour }}:{{ .StartAtMinute }} - {{ .EndAtYear }}年{{ .EndAtMonth }}月{{ .EndAtDay }}日 {{ .EndAtHour }}:{{ .EndAtMinute }}<br/>{{ .TimeZone }}<br/><br/>会議を開始する<br/>&lt;{{ .MeetingUrl }}&gt;<br/>添付ファイルをクリックして、会議をカレンダーに追加します"
+    },
+    {
+        "id": "api.meeting.mail.invite_template_host",
+        "translation": "あなた（{{ .UserName }}）は、この会議の主催者です。<br/>開催日時になったら、ここからミーティングを開始してください。<br/><br/>{{ .RepeatMeetingInfo }}{{ .StartAtYear }}年{{ .StartAtMonth }}月{{ .StartAtDay }}日 {{ .StartAtHour }}:{{ .StartAtMinute }} - {{ .EndAtYear }}年{{ .EndAtMonth }}月{{ .EndAtDay }}日 {{ .EndAtHour }}:{{ .EndAtMinute }}<br/>{{ .TimeZone }}<br/><br/>会議を開始する<br/>&lt;{{ .MeetingUrl }}&gt;<br/>添付ファイルをクリックして、会議をカレンダーに追加します"
+    },
+    {
+        "id": "api.meeting.mail.ics.filename",
+        "translation": "Meeting_info"
+    },
+    {
+        "id": "api.meeting.mail.terminate_title_prefix",
+        "translation": "[RS-CloudOffice会議中止通知] "
+    },
+    {
+        "id": "api.meeting.mail.change_title_prefix",
+        "translation": "[RS-CloudOffice会議変更通知] "
+    },
+    {
+        "id": "api.meeting.mail.invite_title_prefix",
+        "translation": "[RS-CloudOffice会議招待通知] "
+    },
+    {
+        "id": "api.meeting.mail.invite_title_prefix_host",
+        "translation": "[RS-CloudOffice会議開催通知] "
+    },
+    {
+        "id": "api.meeting.Mon",
+        "translation": "月"
+    },
+    {
+        "id": "api.meeting.Tues",
+        "translation": "火"
+    },
+    {
+        "id": "api.meeting.Wed",
+        "translation": "水"
+    },
+    {
+        "id": "api.meeting.Thur",
+        "translation": "木"
+    },
+    {
+        "id": "api.meeting.Fri",
+        "translation": "金"
+    },
+    {
+        "id": "api.meeting.Sat",
+        "translation": "土"
+    },
+    {
+        "id": "api.meeting.Sun",
+        "translation": "日"
+    },
+    {
+        "id": "api.meeting.comma",
+        "translation": "、"
+    },
+    {
+        "id": "api.meeting.day",
+        "translation": "{{ .Day }}日"
+    },
+    {
+        "id": "api.meeting.first",
+        "translation": "第1"
+    },
+    {
+        "id": "api.meeting.second",
+        "translation": "第2"
+    },
+    {
+        "id": "api.meeting.third",
+        "translation": "第3"
+    },
+    {
+        "id": "api.meeting.fourth",
+        "translation": "第4"
+    },
+    {
+        "id": "api.meeting.last",
+        "translation": "最後の"
+    },
+    {
+        "id": "api.meeting.mail.repeat_end_type.none",
+        "translation": "有効開始日: {{ .RepeatStartAtYear }}年{{ .RepeatStartAtMonth }}月{{ .RepeatStartAtDay }}日"
+    },
+    {
+        "id": "api.meeting.mail.repeat_end_type.date",
+        "translation": "期間: {{ .RepeatStartAtYear }}年{{ .RepeatStartAtMonth }}月{{ .RepeatStartAtDay }}日-{{ .RepeatEndAtYear }}年{{ .RepeatEndAtMonth }}月{{ .RepeatEndAtDay }}日"
+    },
+    {
+        "id": "api.meeting.mail.repeat_end_type.times",
+        "translation": "有効開始日: {{ .RepeatStartAtYear }}年{{ .RepeatStartAtMonth }}月{{ .RepeatStartAtDay }}日 繰り返し回数:{{ .RepeatTimes }}回"
+    },
+    {
+        "id": "api.meeting.mail.repeat_type.everyday",
+        "translation": "繰り返し: 平日毎日 "
+    },
+    {
+        "id": "api.meeting.mail.repeat_type.day",
+        "translation": "繰り返し: {{ .RepeatDay }}日毎 "
+    },
+    {
+        "id": "api.meeting.mail.repeat_type.week",
+        "translation": "繰り返し: {{ .RepeatWeek }}週ごとの{{ .RepeatWeekDays }} "
+    },
+    {
+        "id": "api.meeting.mail.repeat_type.month_day",
+        "translation": "繰り返し: {{ .RepeatMonth }}ヵ月毎の{{ .RepeatDays }} "
+    },
+    {
+        "id": "api.meeting.mail.repeat_type.month_week",
+        "translation": "繰り返し: {{ .RepeatMonth }}ヵ月毎の{{ .RepeatWeekDay }} "
+    },
+    {
+        "id": "api.meeting.mail.repeat_type.year_day",
+        "translation": "繰り返し: {{ .RepeatYear }}毎の、{{ .RepeatDays }} "
+    },
+    {
+        "id": "api.meeting.mail.repeat_type.year_week",
+        "translation": "繰り返し: {{ .RepeatYear }}毎の{{ .RepeatWeekDay }} "
+    },
+    {
+        "id": "api.enable_confirm_notifications_to_channel_user_count_error",
+        "translation": "正の整数を設定してください。"
+    },
+    {
+        "id": "app.meeting.repeat.begin",
+        "translation": "繰り返し: "
+    },
+    {
+        "id": "api.meeting.mail.repeat_day",
+        "translation": "日単位、"
+    },
+    {
+        "id": "api.meeting.mail.repeat_week",
+        "translation": "週単位、"
+    },
+    {
+        "id": "api.meeting.mail.repeat_month",
+        "translation": "月単位、"
+    },
+    {
+        "id": "api.meeting.mail.repeat_year",
+        "translation": "年単位、"
+    },
+    {
+      "id": "api.file.upload_file.not_upload_permission.app_error",
+      "translation": "ファイルをアップロードする権限がありません。"
+    },
+    {
+      "id": "api.file.upload_file.not_download_permission.app_error",
+      "translation": "ファイルをダウンロードする権限がありません。"
+    },
+    {
+        "id": "app.meeting.repeat_start",
+        "translation": "繰り返し"
+    },
+    {
+        "id": "app.meeting.repeat_end",
+        "translation": "終了条件"
+    },
+    {
+        "id": "app.meeting.repeat_title",
+        "translation": "「繰り返し」"
+    },
+    {
+        "id": "api.meeting.mail.delete_title_prefix",
+        "translation": "[RS-CloudOffice]予約会議が管理者によりキャンセルされました。"
+    },
+    {
+        "id": "api.meeting.mail.repeat_unit_day",
+        "translation": "繰り返しの単位：日単位"
+    },
+    {
+        "id": "api.meeting.mail.repeat_unit_week",
+        "translation": "繰り返しの単位：週単位"
+    },
+    {
+        "id": "api.meeting.mail.repeat_unit_month",
+        "translation": "繰り返しの単位：月単位"
+    },
+    {
+        "id": "api.meeting.mail.repeat_unit_year",
+        "translation": "繰り返しの単位：年単位"
+    },
+    {
+        "id": "api.meeting.mail.repeat_frequency_everyday",
+        "translation": "繰り返しの頻度：平日毎日"
+    },
+    {
+        "id": "api.meeting.mail.repeat_frequency_day",
+        "translation": "繰り返しの頻度：{{ .RepeatDay }}日毎"
+    },
+    {
+        "id": "api.meeting.mail.repeat_frequency_week",
+        "translation": "繰り返しの頻度: {{ .RepeatWeek }}週ごと"
+    },
+    {
+        "id": "api.meeting.mail.repeat_frequency_weekdays",
+        "translation": "{{ .RepeatWeekDays }}"
+    },
+    {
+        "id": "api.meeting.mail.repeat_frequency_month_day",
+        "translation": "繰り返しの頻度: {{ .RepeatMonth }}ヵ月毎の{{ .RepeatDays }} "
+    },
+    {
+        "id": "api.meeting.mail.repeat_frequency_month_week",
+        "translation": "繰り返しの頻度: {{ .RepeatMonth }}ヵ月毎の{{ .RepeatWeekDay }} "
+    },
+    {
+        "id": "api.meeting.mail.repeat_frequency_year_day",
+        "translation": "繰り返しの頻度: {{ .RepeatYear }}毎の{{ .RepeatDays }} "
+    },
+    {
+        "id": "api.meeting.mail.repeat_frequency_year_week",
+        "translation": "繰り返しの頻度: {{ .RepeatYear }}毎の{{ .RepeatWeekDay }} "
+    },
+    {
+        "id": "api.meeting.mail.repeat_over_none",
+        "translation": "繰り返しの終了: {{ .RepeatStartAtYear }}年{{ .RepeatStartAtMonth }}月{{ .RepeatStartAtDay }}日"
+    },
+    {
+        "id": "api.meeting.mail.repeat_over_date",
+        "translation": "繰り返しの終了: {{ .RepeatStartAtYear }}年{{ .RepeatStartAtMonth }}月{{ .RepeatStartAtDay }}日-{{ .RepeatEndAtYear }}年{{ .RepeatEndAtMonth }}月{{ .RepeatEndAtDay }}日"
+    },
+    {
+        "id": "api.meeting.mail.repeat_over_times",
+        "translation": "繰り返しの終了: {{ .RepeatStartAtYear }}年{{ .RepeatStartAtMonth }}月{{ .RepeatStartAtDay }}日 繰り返し回数:{{ .RepeatTimes }}回"
+    },
+    {
+        "id": "api.meeting.mail.startat",
+        "translation": "開始予定: {{ .StartAtYear }}/{{ .StartAtMonth }}/{{ .StartAtDay }} {{ .StartAtHour }}:{{ .StartAtMinute }}"
+    },
+    {
+        "id": "api.meeting.mail.endat",
+        "translation": "終了予定: {{ .EndAtYear }}/{{ .EndAtMonth }}/{{ .EndAtDay }} {{ .EndAtHour }}:{{ .EndAtMinute }}"
+    },
+    {
+        "id": "api.meeting.mail.nousers",
+        "translation": "招待者無し"
+    },
+    {
+        "id": "api.meeting.mail.delete_template",
+        "translation": "予約会議が、管理者によりキャンセルされました。<br/><br/>キャンセルされた予約会議情報<br/>会議名：{{ .MeetingName }}<br/>会議オーナー：{{ .HostName }}<br/>{{ .MeetingInfo }}<br/><br/>参加予定者：{{ .Users }}"
+    },
+    {
+        "id": "api.meeting.monday",
+        "translation": "月曜日"
+    },
+    {
+        "id": "api.meeting.tuesday",
+        "translation": "火曜日"
+    },
+    {
+        "id": "api.meeting.wednesday",
+        "translation": "水曜日"
+    },
+    {
+        "id": "api.meeting.thursday",
+        "translation": "木曜日"
+    },
+    {
+        "id": "api.meeting.friday",
+        "translation": "金曜日"
+    },
+    {
+        "id": "api.meeting.saturday",
+        "translation": "土曜日"
+    },
+    {
+        "id": "api.meeting.sunday",
+        "translation": "日曜日"
+    },
+    {
+        "id": "api.meeting.sikaku",
+        "translation": "■"
+    },
+    {
+        "id": "app.meeting.redis_connect_error",
+        "translation": "redis接続エラーが発生しました。"
+    },
+    {
+        "id": "app.meeting.redis_pass_error",
+        "translation": "redisパスワードエラーが発生しました。"
+    },
+    {
+        "id": "api.meeting.search.app_error",
+        "translation": "会議情報取得に失敗しました。"
+    },
+    {
+        "id": "api.meeting.server.app_error",
+        "translation": "システムエラーが発生しました、システム管理者に連絡してください。"
+    },
+    {
+        "id": "jp.co.ryobi.webconferencingsettingup_maxnumbermeeting_error",
+        "translation": "会議利用数制限設定の最大Web会議数が不正です。正の整数または0を指定してください。"
+    },
+    {
+        "id": "jp.co.ryobi.webconferencingsettingup_maxnumbermeetinguser_error",
+        "translation": "会議利用数制限設定のWeb会議毎最大参加者数が不正です。正の整数または0を指定してください。"
+    },
+    {
+        "id": "jp.co.ryobi.webconferencingsettingup_maxnumberallmeetinguser_error",
+        "translation": "会議利用数制限設定のWeb会議最大接続数が不正です。正の整数または0を指定してください。"
+    },
+    {
+        "id": "jp.co.ryobi.webconferencingsettingup_maxnumbermeetinguser_maxnumberallmeetinguser_error",
+        "translation": "web会議の最大参加者数はweb会議の最大接続数より小さくしてください。"
+    },
+    {
+        "id": "api.cron_chat.chat_delete_batch.startup",
+        "translation": "バッチ起動"
+    },
+    {
+        "id": "api.cron_chat.chat_delete_batch.start",
+        "translation": "チャット削除バッチ実行開始"
+    },
+    {
+        "id": "api.cron_chat.chat_delete_batch.end",
+        "translation": "チャット削除実行終了"
+    },
   {
     "id": "api.user.invalidate_verify_email_tokens.error",
     "translation": "電子メール確認トークンを無効にする際にタイプ別のトークンを取得できませんでした"
Index: mattermost-server-7.8.1/model/channel_member.go
===================================================================
--- mattermost-server-7.8.1/model/channel_member.go	(revision 4484)
+++ mattermost-server-7.8.1/model/channel_member.go	(revision 4485)
@@ -19,6 +19,14 @@
 	IgnoreChannelMentionsOff        = "off"
 	IgnoreChannelMentionsOn         = "on"
 	IgnoreChannelMentionsNotifyProp = "ignore_channel_mentions"
+	/* Ryobi Systems CloudOffice Channel Mod 20210802 start */
+	NOTIFICATIONS_TO_CHANNEL_DEFAULT     = "default"
+	NOTIFICATIONS_TO_CHANNEL_OFF         = "off"
+	NOTIFICATIONS_TO_CHANNEL_ON          = "on"
+	NOTIFICATIONS_TO_CHANNEL_NOTIFY_PROP = "notifications_to_channel"
+	NOTIFICATIONS_TO_CHANNEL_COUNT_DEFAULT  =  "default"
+	NOTIFICATIONS_TO_CHANNEL_COUNT_NOTIFY_PROP = "notifications_to_channel_count"
+	/* Ryobi Systems CloudOffice Channel Mod 20210816 end */
 )
 
 type ChannelUnread struct {
@@ -230,5 +238,9 @@
 		PushNotifyProp:                  ChannelNotifyDefault,
 		EmailNotifyProp:                 ChannelNotifyDefault,
 		IgnoreChannelMentionsNotifyProp: IgnoreChannelMentionsDefault,
+		/* Ryobi Systems CloudOffice Channel Mod 20210802 start */
+		NOTIFICATIONS_TO_CHANNEL_NOTIFY_PROP: NOTIFICATIONS_TO_CHANNEL_DEFAULT,
+		NOTIFICATIONS_TO_CHANNEL_COUNT_NOTIFY_PROP: NOTIFICATIONS_TO_CHANNEL_COUNT_DEFAULT,
+		/* Ryobi Systems CloudOffice Channel Mod 20210816 end */
 	}
 }
Index: mattermost-server-7.8.1/model/config.go
===================================================================
--- mattermost-server-7.8.1/model/config.go	(revision 4484)
+++ mattermost-server-7.8.1/model/config.go	(revision 4485)
@@ -1030,6 +1030,12 @@
 	DiscoveryEndpoint *string `access:"authentication_openid"` // telemetry: none
 	ButtonText        *string `access:"authentication_openid"` // telemetry: none
 	ButtonColor       *string `access:"authentication_openid"` // telemetry: none
+	/* Ryobi Systems MM_NC_連動SSOログアウト Mod 20201127 START */
+	UsersApiEndpoint    *string
+	ClientsApiEndpoint  *string
+	RealmEndpoint       *string
+	BackchannelEndpoint *string
+	/* Ryobi Systems MM_NC_連動SSOログアウト Mod 20201127 END */
 }
 
 func (s *SSOSettings) setDefaults(scope, authEndpoint, tokenEndpoint, userAPIEndpoint, buttonColor string) {
@@ -1072,6 +1078,22 @@
 	if s.ButtonColor == nil {
 		s.ButtonColor = NewString(buttonColor)
 	}
+	/* Ryobi Systems MM_NC_連動SSOログアウト Mod 20201202 START */
+	if s.UsersApiEndpoint == nil {
+		s.UsersApiEndpoint = NewString("")
+	}
+
+	if s.ClientsApiEndpoint == nil {
+		s.ClientsApiEndpoint = NewString("")
+	}
+
+	if s.RealmEndpoint == nil {
+		s.RealmEndpoint = NewString("")
+	}
+	if s.BackchannelEndpoint == nil {
+		s.BackchannelEndpoint = NewString("")
+	}
+	/* Ryobi Systems MM_NC_連動SSOログアウト Mod 20201202 END */
 }
 
 type Office365Settings struct {
@@ -1970,6 +1992,7 @@
 	EnableUserDeactivation    *bool   `access:"experimental_features"`
 	RestrictCreationToDomains *string `access:"authentication_signup"` // telemetry: none
 	EnableCustomUserStatuses  *bool   `access:"site_users_and_teams"`
+	EnableMultiTenancySupport *bool   `access:"site_users_and_teams"`
 	EnableCustomBrand         *bool   `access:"site_customization"`
 	CustomBrandText           *string `access:"site_customization"`
 	CustomDescriptionText     *string `access:"site_customization"`
@@ -1980,6 +2003,9 @@
 	MaxChannelsPerTeam                  *int64   `access:"site_users_and_teams"`
 	MaxNotificationsPerChannel          *int64   `access:"environment_push_notification_server"`
 	EnableConfirmNotificationsToChannel *bool    `access:"site_notifications"`
+	/* Ryobi Systems CloudOffice Channel Mod 20210802 start */
+	EnableConfirmNotificationsToChannelUserCount *int64 `access:"site_notifications"`
+	/* Ryobi Systems CloudOffice Channel Mod 20210816 end */
 	TeammateNameDisplay                 *string  `access:"site_users_and_teams"`
 	ExperimentalViewArchivedChannels    *bool    `access:"experimental_features,site_users_and_teams"`
 	ExperimentalEnableAutomaticReplies  *bool    `access:"experimental_features"`
@@ -2014,6 +2040,10 @@
 		s.EnableCustomUserStatuses = NewBool(true)
 	}
 
+	if s.EnableMultiTenancySupport == nil {
+		s.EnableMultiTenancySupport = NewBool(true)
+	}
+
 	if s.EnableLastActiveTime == nil {
 		s.EnableLastActiveTime = NewBool(true)
 	}
@@ -2054,6 +2084,12 @@
 		s.EnableConfirmNotificationsToChannel = NewBool(true)
 	}
 
+	/* Ryobi Systems CloudOffice Channel Mod 20210802 start */
+	if s.EnableConfirmNotificationsToChannelUserCount == nil {
+		s.EnableConfirmNotificationsToChannelUserCount = NewInt64(5)
+	}
+	/* Ryobi Systems CloudOffice Channel Mod 20210816 end */
+
 	if s.ExperimentalEnableAutomaticReplies == nil {
 		s.ExperimentalEnableAutomaticReplies = NewBool(false)
 	}
@@ -2909,7 +2945,32 @@
 		s.ChimeraOAuthProxyURL = NewString("")
 	}
 }
+func (s *PluginSettings) isValid() *AppError {
+	if _, ok := s.Plugins["jp.co.ryobi.webconferencingsettingup"]; !ok {
+		return nil
+	}
+	data := s.Plugins["jp.co.ryobi.webconferencingsettingup"]
+	maxnumbermeetingResult, _ := regexp.MatchString(`^\d+$`, data["maxnumbermeeting"].(string))
+	if !maxnumbermeetingResult {
+		return NewAppError("Config.IsValid", "jp.co.ryobi.webconferencingsettingup_maxnumbermeeting_error", nil, "", http.StatusBadRequest)
+	}
 
+	maxnumbermeetinguserResult, _ := regexp.MatchString(`^\d+$`, data["maxnumbermeetinguser"].(string))
+	if !maxnumbermeetinguserResult {
+		return NewAppError("Config.IsValid", "jp.co.ryobi.webconferencingsettingup_maxnumbermeetinguser_error", nil, "", http.StatusBadRequest)
+	}
+	maxnumberallmeetinguserResult, _ := regexp.MatchString(`^\d+$`, data["maxnumberallmeetinguser"].(string))
+	if !maxnumberallmeetinguserResult {
+		return NewAppError("Config.IsValid", "jp.co.ryobi.webconferencingsettingup_maxnumberallmeetinguser_error", nil, "", http.StatusBadRequest)
+	}
+	intMaxnumbermeetinguser, _ := strconv.Atoi(data["maxnumbermeetinguser"].(string))
+	intMaxnumberallmeetinguser, _ := strconv.Atoi(data["maxnumberallmeetinguser"].(string))
+	if intMaxnumberallmeetinguser != 0 && intMaxnumbermeetinguser > intMaxnumberallmeetinguser {
+		return NewAppError("Config.IsValid", "jp.co.ryobi.webconferencingsettingup_maxnumbermeetinguser_maxnumberallmeetinguser_error", nil, "", http.StatusBadRequest)
+	}
+
+	return nil
+}
 type GlobalRelayMessageExportSettings struct {
 	CustomerType      *string `access:"compliance_compliance_export"` // must be either A9 or A10, dictates SMTP server url
 	SMTPUsername      *string `access:"compliance_compliance_export"`
@@ -3044,7 +3105,56 @@
 		s.RemoteImageProxyOptions = NewString("")
 	}
 }
+type PostSaveSettings struct {
+	PostPermission       *bool
+	Postinput            *string
+	PostUtil             *string
+	FilePermission       *bool
+	Fileinput            *string
+	FileUtil             *string
+	DeleteTime           *int
+	ShowUserSettings     *bool
+	ShowUserFileSettings *bool
+}
 
+func (s *PostSaveSettings) SetDefaults() {
+	if s.PostPermission == nil {
+		s.PostPermission = NewBool(false)
+	}
+
+	if s.Postinput == nil || *s.Postinput == "" {
+		s.Postinput = NewString("3")
+	}
+
+	if s.PostUtil == nil || *s.PostUtil == "" {
+		s.PostUtil = NewString("year")
+	}
+
+	if s.FilePermission == nil {
+		s.FilePermission = NewBool(false)
+	}
+
+	if s.Fileinput == nil || *s.Fileinput == "" {
+		s.Fileinput = NewString("3")
+	}
+
+	if s.FileUtil == nil || *s.FileUtil == "" {
+		s.FileUtil = NewString("year")
+	}
+
+	if s.DeleteTime == nil {
+		s.DeleteTime = NewInt(13)
+	}
+
+	if s.ShowUserSettings == nil {
+		s.ShowUserSettings = NewBool(false)
+	}
+
+	if s.ShowUserFileSettings == nil {
+		s.ShowUserFileSettings = NewBool(false)
+	}
+}
+
 // ImportSettings defines configuration settings for file imports.
 type ImportSettings struct {
 	// The directory where to store the imported files.
@@ -3194,6 +3304,7 @@
 	FeatureFlags              *FeatureFlags  `access:"*_read" json:",omitempty"`
 	ImportSettings            ImportSettings // telemetry: none
 	ExportSettings            ExportSettings
+	PostSaveSettings          PostSaveSettings	
 }
 
 func (o *Config) Auditable() map[string]interface{} {
@@ -3309,6 +3420,7 @@
 	}
 	o.ImportSettings.SetDefaults()
 	o.ExportSettings.SetDefaults()
+	o.PostSaveSettings.SetDefaults()
 }
 
 func (o *Config) IsValid() *AppError {
@@ -3391,6 +3503,10 @@
 	if appErr := o.ImportSettings.isValid(); appErr != nil {
 		return appErr
 	}
+
+	if err := o.PluginSettings.isValid(); err != nil {
+		return err
+	}
 	return nil
 }
 
@@ -3419,6 +3535,12 @@
 		return NewAppError("Config.IsValid", "model.config.is_valid.sitename_length.app_error", map[string]any{"MaxLength": SitenameMaxLength}, "", http.StatusBadRequest)
 	}
 
+	/* Ryobi Systems CloudOffice Channel Mod 20210802 start */
+	if *s.EnableConfirmNotificationsToChannelUserCount <= 0 {
+		return NewAppError("Config.IsValid", "api.enable_confirm_notifications_to_channel_user_count_error", nil, "", http.StatusBadRequest)
+	}
+	/* Ryobi Systems CloudOffice Channel Mod 20210816 end */
+
 	return nil
 }
 
Index: mattermost-server-7.8.1/model/cron_chat.go
===================================================================
--- mattermost-server-7.8.1/model/cron_chat.go	(nonexistent)
+++ mattermost-server-7.8.1/model/cron_chat.go	(revision 4485)
@@ -0,0 +1,107 @@
+//Copyright 2021 Ryobi Systems Co., Ltd. All Rights Reserved.
+
+package model
+
+import (
+	"encoding/json"
+	"github.com/robfig/cron"
+	"io"
+)
+
+type CronSettings struct {
+	Id					int	`json:"id"`
+	CronId				cron.EntryID	`json:"cron_id"`
+	Spec				string	`json:"spec"`
+	CreateAt			int64	`json:"create_at"`
+	DeleteAt			int64	`json:"delete_at"`
+	UpdateAt			int64	`json:"update_at"`
+}
+
+type ChannelChatSaveSettings struct {
+	Id					int	`json:"id"`
+	CreatorId			string	`json:"creator_id"`
+	CreateAt			int64	`json:"create_at"`
+	UpdatorId			string	`json:"updator_id"`
+	UpdateAt			int64	`json:"update_at"`
+	ChannelId			string	`json:"channel_id"`
+	MessagePermission	bool	`json:"message_permission"`
+	MessageTime			int64	`json:"message_time"`
+	MessageUtil			string	`json:"message_util"`
+	FilePermission		bool	`json:"file_permission"`
+	FileTime			int64	`json:"file_time"`
+	FileUtil			string	`json:"file_util"`
+	ShowUserSettings     bool   `json:"show_user_settings"`
+	ShowUserFileSettings bool   `json:"show_user_file_settings"`
+}
+
+type CronSettingsFromJson struct {
+	CronTime			int	`json:"cron_time"`
+}
+
+type ChannelChatSaveSettingsFromJson struct {
+	ChannelId			string	`json:"channel_id"`
+	MessagePermission	bool	`json:"message_permission"`
+	MessageTime			int64	`json:"message_time"`
+	MessageUtil			string	`json:"message_util"`
+	FilePermission		bool	`json:"file_permission"`
+	FileTime			int64	`json:"file_time"`
+	FileUtil			string	`json:"file_util"`
+	CurrentType			string	`json:"current_type"`
+}
+type ChannelSettingsToJson struct {
+	MessagePermission				bool	`json:"message_permission"`
+	MessageTime						int64	`json:"message_time"`
+	MessageUtil						string	`json:"message_util"`
+	FilePermission					bool	`json:"file_permission"`
+	FileTime						int64	`json:"file_time"`
+	FileUtil						string	`json:"file_util"`
+	SystemMessagePermission			bool	`json:"system_message_permission"`
+	SystemMessageTime				int64	`json:"system_message_time"`
+	SystemMessageUtil				string	`json:"system_message_util"`
+	SystemFilePermission			bool	`json:"system_file_permission"`
+	SystemFileTime					int64	`json:"system_file_time"`
+	SystemFileUtil					string	`json:"system_file_util"`
+	ShowUserSettings				bool	`json:"show_user_settings"`
+	ShowUserFileSettings			bool	`json:"show_user_file_settings"`
+}
+
+type ResponseChannelSettingsDetail struct {
+	Status				string	`json:"status"`
+	Type				string	`json:"type"`
+	Message				string	`json:"message"`
+	ChannelData			*ChannelSettingsToJson	`json:"data"`
+}
+
+type ChatFiles struct {
+	Id					string	`json:"id"`
+	FileIds				StringArray	`json:"file_ids"`
+	UserId				string	`json:"user_id"`
+}
+
+type ChatFilesPath struct {
+	Path				string	`json:"path"`
+}
+
+func (o *CronSettings) ToJson() string {
+	b, _ := json.Marshal(o)
+	return string(b)
+}
+
+func ChannelSettingsDetailInfoToJson(t ResponseChannelSettingsDetail) string {
+	b, _ := json.Marshal(t)
+	return string(b)
+}
+
+func CronSettingsDataFromJson(data io.Reader) *CronSettingsFromJson {
+	var cronData *CronSettingsFromJson
+	json.NewDecoder(data).Decode(&cronData)
+	return cronData
+}
+
+func ChannelChatSaveSettingsDataFromJson(data io.Reader) *ChannelChatSaveSettingsFromJson {
+	var cronData *ChannelChatSaveSettingsFromJson
+	json.NewDecoder(data).Decode(&cronData)
+	return cronData
+}
+
+
Index: mattermost-server-7.8.1/model/file.go
===================================================================
--- mattermost-server-7.8.1/model/file.go	(revision 4484)
+++ mattermost-server-7.8.1/model/file.go	(revision 4485)
@@ -3,6 +3,8 @@
 
 package model
 
+import "encoding/json"
+
 const (
 	MaxImageSize = int64(6048 * 4032) // 24 megapixels, roughly 36MB as a raw image
 )
@@ -11,3 +13,43 @@
 	FileInfos []*FileInfo `json:"file_infos"`
 	ClientIds []string    `json:"client_ids"`
 }
+
+type FilePermission struct {
+	UserPermissionDownload string `json:"user_permission_download"`
+	UserPermissionUpload   bool   `json:"user_permission_upload"`
+}
+
+type ResponseFilePermission struct {
+	Status  string          `json:"status"`
+	Type    string          `json:"type"`
+	Message string          `json:"message"`
+	User    *FilePermission `json:"user"`
+}
+
+type ResponseFileTotalSize struct {
+	Status    string  `json:"status"`
+	Type      string  `json:"type"`
+	Message   string  `json:"message"`
+	TotalSize float64 `json:"total_size"`
+}
+
+type ResponseResultFile struct {
+	Status  string `json:"status"`
+	Type    string `json:"type"`
+	Message string `json:"message"`
+}
+
+func (o *ResponseFilePermission) ToJson() string {
+	b, _ := json.Marshal(o)
+	return string(b)
+}
+
+func (o *ResponseFileTotalSize) ToJson() string {
+	b, _ := json.Marshal(o)
+	return string(b)
+}
+
+func (o *ResponseResultFile) ToJson() string {
+	b, _ := json.Marshal(o)
+	return string(b)
+}
Index: mattermost-server-7.8.1/model/meeting.go
===================================================================
--- mattermost-server-7.8.1/model/meeting.go	(nonexistent)
+++ mattermost-server-7.8.1/model/meeting.go	(revision 4485)
@@ -0,0 +1,415 @@
+//Copyright 2021 Ryobi Systems Co., Ltd. All Rights Reserved.
+
+package model
+
+import (
+ 	"encoding/json"
+ 	"io"
+)
+
+type MeetingForCreateTable struct {
+	MeetingItemId		string	`json:"meeting_item_id"`
+	ItemValid			bool	`json:"item_valid"`
+	MeetingName			string	`json:"meeting_name"`
+	MeetingId			string	`json:"meeting_id"`
+	StartAt				int64	`json:"start_at"`
+	EndAt				int64	`json:"end_at"`
+	TimeZone			string	`json:"time_zone"`
+	HostId				string	`json:"host_id"`
+	HostName			string	`json:"host_name"`
+	CreateAt			int64	`json:"create_at"`
+}
+
+type Meeting struct {
+	MeetingItemId		string	`json:"meeting_item_id"`
+	ItemValid			bool	`json:"item_valid"`
+	MeetingName			string	`json:"meeting_name"`
+	MeetingId			string	`json:"meeting_id"`
+	StartAt				int64	`json:"start_at"`
+	EndAt				int64	`json:"end_at"`
+	TimeZone			string	`json:"time_zone"`
+	HostId				string	`json:"host_id"`
+	HostName			string	`json:"host_name"`
+	CreateAt			int64	`json:"create_at"`
+	IsRepeat			bool	`json:"is_repeat"`
+	RepeatConfig		string	`json:"repeat_config"`
+	RepeatEndDate		int64	`json:"repeat_end_date"`
+	ICalUID				string	`json:"ical_uid"`
+}
+
+type MeetingUser struct {
+	ItemId				string	`json:"item_id"`
+	ItemValid			bool	`json:"item_valid"`
+	MeetingItemId		string	`json:"meeting_item_id"`
+	UserId				string	`json:"user_id"`
+	UserMail			string	`json:"mail"`
+}
+
+type DeletedSingleRepeatMeeting struct {
+	ItemId				string	`json:"item_id"`
+	MeetingItemId		string	`json:"meeting_item_id"`
+	StartAt				int64	`json:"start_at"`
+	EndAt				int64	`json:"end_at"`
+}
+
+type MeetingFromJson struct {
+	MeetingId			string	`json:"meeting_id"`
+	MeetingName			string	`json:"meeting_name"`
+	StartAt				int64	`json:"start_at"`
+	EndAt				int64	`json:"end_at"`
+	TimeZone			string	`json:"time_zone"`
+	HostId				string	`json:"host_id"`
+	HostName			string	`json:"host_name"`
+	Users				[]*MeetingUserFromJson	`json:"users"`
+	IsRepeat			bool	`json:"is_repeat"`
+	RepeatConfig		*RepeatConfig			`json:"repeat_config"`
+	RepeatEndDate		int64	`json:"repeat_end_date"`
+	IsAddMeeting		bool	`json:"is_add_meeting"`
+}
+
+type RepeatConfig struct {
+	RepeatType					string	`json:"repeat_type"`
+	RepeatFrequencyTimes		int	`json:"repeat_frequency_times"`
+	RepeatFrequencyTimesType	string 	`json:"repeat_frequency_times_type"`
+	RepeatFrequencyWeekdays		[]int	`json:"repeat_frequency_weekdays"`
+	RepeatFrequencyDays			[]int	`json:"repeat_frequency_days"`
+	RepeatFrequencyWeekTimes	int	`json:"repeat_frequency_week_times"`
+	RepeatFrequencyWeekday		int	`json:"repeat_frequency_weekday"`
+	EndType						string	`json:"end_type"`
+	EndValue					int64	`json:"end_value"`
+}
+
+type DeleteParamsFromJson struct {
+	DeleteType			int		`json:"delete_type"`
+	StartAt				int64	`json:"start_at"`
+	EndAt				int64	`json:"end_at"`
+}
+
+type DeleteParamsToJson struct {
+	MeetingItemId		string	`json:"meeting_item_id"`
+	StartAt				int64	`json:"start_at"`
+	EndAt				int64	`json:"end_at"`
+}
+
+type AllMeetings struct {
+	SingleMeetings		[]*MeetingToJson		`json:"single_meetings"`
+	RepeatMeetings		[]*RepeatMeetingToJson	`json:"repeat_meetings"`
+	DeletedMeetingInfo	[]*DeleteParamsToJson	`json:"deleted_meetings"`
+}
+
+type MeetingUserFromJson struct {
+	UserId				string	`json:"user_id"`
+	UserMail			string	`json:"mail"`
+	SendMailMode		int		`json:"send_mail_mode"`
+	UserType			string	`json:"user_type"`
+}
+
+type MeetingToJson struct {
+	MeetingItemId		string	`json:"meeting_item_id"`
+	MeetingUrl			string	`json:"meeting_url"`
+	MeetingName			string	`json:"meeting_name"`
+	StartAt				int64	`json:"start_at"`
+	EndAt				int64	`json:"end_at"`
+	TimeZone			string	`json:"time_zone"`
+	HostId				string	`json:"host_id"`
+	HostName			string	`json:"host_name"`
+	Users				[]*MeetingUserToJson	`json:"users"`
+}
+
+type RepeatMeetingToJson struct {
+	MeetingItemId		string	`json:"meeting_item_id"`
+	MeetingUrl			string	`json:"meeting_url"`
+	MeetingName			string	`json:"meeting_name"`
+	StartAt				int64	`json:"start_at"`
+	EndAt				int64	`json:"end_at"`
+	TimeZone			string	`json:"time_zone"`
+	HostId				string	`json:"host_id"`
+	HostName			string	`json:"host_name"`
+	Users				[]*MeetingUserToJson	`json:"users"`
+	IsRepeat			bool	`json:"is_repeat"`
+	RepeatConfig		*RepeatConfig			`json:"repeat_config"`
+	RepeatEndDate		int64	`json:"repeat_end_date"`
+}
+
+type MeetingUserToJson struct {
+	UserId				string	`json:"user_id"`
+	UserMail			string	`json:"mail"`
+}
+
+type MeetingMailInfo struct {
+	UserName			string
+	MeetingName			string
+	MeetingUrl			string
+	StartAtYear			string
+	StartAtMonth		string
+	StartAtDay			string
+	StartAtHour			string
+	StartAtMinute		string
+	EndAtYear			string
+	EndAtMonth			string
+	EndAtDay			string
+	EndAtHour			string
+	EndAtMinute			string
+	TimeZone			string
+	AddRepeatInfo		bool
+	RepeatConfig		*RepeatConfig
+	EndValueAtYear		string
+	EndValueAtMonth		string
+	EndValueAtDay		string
+	ICalUID				string
+}
+
+type ResponseResult struct {
+	Status				string	`json:"status"`
+	Type				string	`json:"type"`
+	Message				string	`json:"message"`
+}
+
+var RSMeetingTimezonesI18n = map[string]string {
+	"Etc/GMT+12": 						"api.meeting.timezone.Etc/GMT+12",
+	"Etc/GMT+11": 						"api.meeting.timezone.Etc/GMT+11",
+	"Pacific/Honolulu": 				"api.meeting.timezone.Pacific/Honolulu",
+	"Pacific/Marquesas": 				"api.meeting.timezone.Pacific/Marquesas",
+	"America/Anchorage": 				"api.meeting.timezone.America/Anchorage",
+	"America/Santa_Isabel": 			"api.meeting.timezone.America/Santa_Isabel",
+	"America/Los_Angeles": 				"api.meeting.timezone.America/Los_Angeles",
+	"America/Chihuahua": 				"api.meeting.timezone.America/Chihuahua",
+	"America/Phoenix": 					"api.meeting.timezone.America/Phoenix",
+	"America/Denver": 					"api.meeting.timezone.America/Denver",
+	"America/Guatemala": 				"api.meeting.timezone.America/Guatemala",
+	"America/Chicago": 					"api.meeting.timezone.America/Chicago",
+	"America/Regina": 					"api.meeting.timezone.America/Regina",
+	"America/Mexico_City": 				"api.meeting.timezone.America/Mexico_City",
+	"America/Bogota": 					"api.meeting.timezone.America/Bogota",
+	"America/Indiana/Indianapolis": 	"api.meeting.timezone.America/Indiana/Indianapolis",
+	"America/New_York": 				"api.meeting.timezone.America/New_York",
+	"America/Halifax": 					"api.meeting.timezone.America/Halifax",
+	"America/Asuncion": 				"api.meeting.timezone.America/Asuncion",
+	"America/La_Paz": 					"api.meeting.timezone.America/La_Paz",
+	"America/Cuiaba": 					"api.meeting.timezone.America/Cuiaba",
+	"America/Santiago": 				"api.meeting.timezone.America/Santiago",
+	"America/St_Johns": 				"api.meeting.timezone.America/St_Johns",
+	"America/Sao_Paulo": 				"api.meeting.timezone.America/Sao_Paulo",
+	"America/Godthab": 					"api.meeting.timezone.America/Godthab",
+	"America/Cayenne": 					"api.meeting.timezone.America/Cayenne",
+	"America/Argentina/Buenos_Aires": 	"api.meeting.timezone.America/Argentina/Buenos_Aires",
+	"America/Montevideo": 				"api.meeting.timezone.America/Montevideo",
+	"Etc/GMT+2": 						"api.meeting.timezone.Etc/GMT+2",
+	"Atlantic/Cape_Verde": 				"api.meeting.timezone.Atlantic/Cape_Verde",
+	"Atlantic/Azores": 					"api.meeting.timezone.Atlantic/Azores",
+	"Africa/Casablanca": 				"api.meeting.timezone.Africa/Casablanca",
+	"Atlantic/Reykjavik": 				"api.meeting.timezone.Atlantic/Reykjavik",
+	"Europe/London": 					"api.meeting.timezone.Europe/London",
+	"Etc/GMT": 							"api.meeting.timezone.Etc/GMT",
+	"Europe/Berlin": 					"api.meeting.timezone.Europe/Berlin",
+	"Europe/Paris": 					"api.meeting.timezone.Europe/Paris",
+	"Africa/Lagos": 					"api.meeting.timezone.Africa/Lagos",
+	"Europe/Budapest": 					"api.meeting.timezone.Europe/Budapest",
+	"Europe/Warsaw": 					"api.meeting.timezone.Europe/Warsaw",
+	"Africa/Windhoek": 					"api.meeting.timezone.Africa/Windhoek",
+	"Europe/Istanbul": 					"api.meeting.timezone.Europe/Istanbul",
+	"Europe/Kiev": 						"api.meeting.timezone.Europe/Kiev",
+	"Africa/Cairo": 					"api.meeting.timezone.Africa/Cairo",
+	"Asia/Damascus": 					"api.meeting.timezone.Asia/Damascus",
+	"Asia/Amman": 						"api.meeting.timezone.Asia/Amman",
+	"Africa/Johannesburg": 				"api.meeting.timezone.Africa/Johannesburg",
+	"Asia/Jerusalem": 					"api.meeting.timezone.Asia/Jerusalem",
+	"Asia/Beirut": 						"api.meeting.timezone.Asia/Beirut",
+	"Asia/Baghdad": 					"api.meeting.timezone.Asia/Baghdad",
+	"Europe/Minsk": 					"api.meeting.timezone.Europe/Minsk",
+	"Asia/Riyadh": 						"api.meeting.timezone.Asia/Riyadh",
+	"Africa/Nairobi": 					"api.meeting.timezone.Africa/Nairobi",
+	"Asia/Tehran": 						"api.meeting.timezone.Asia/Tehran",
+	"Europe/Moscow": 					"api.meeting.timezone.Europe/Moscow",
+	"Asia/Tbilisi": 					"api.meeting.timezone.Asia/Tbilisi",
+	"Asia/Yerevan": 					"api.meeting.timezone.Asia/Yerevan",
+	"Asia/Dubai": 						"api.meeting.timezone.Asia/Dubai",
+	"Asia/Baku": 						"api.meeting.timezone.Asia/Baku",
+	"Indian/Mauritius": 				"api.meeting.timezone.Indian/Mauritius",
+	"Asia/Kabul": 						"api.meeting.timezone.Asia/Kabul",
+	"Asia/Tashkent": 					"api.meeting.timezone.Asia/Tashkent",
+	"Asia/Karachi": 					"api.meeting.timezone.Asia/Karachi",
+	"Asia/Colombo": 					"api.meeting.timezone.Asia/Colombo",
+	"Asia/Kolkata": 					"api.meeting.timezone.Asia/Kolkata",
+	"Asia/Kathmandu": 					"api.meeting.timezone.Asia/Kathmandu",
+	"Asia/Almaty": 						"api.meeting.timezone.Asia/Almaty",
+	"Asia/Dhaka": 						"api.meeting.timezone.Asia/Dhaka",
+	"Asia/Yekaterinburg": 				"api.meeting.timezone.Asia/Yekaterinburg",
+	"Asia/Yangon": 						"api.meeting.timezone.Asia/Yangon",
+	"Asia/Bangkok": 					"api.meeting.timezone.Asia/Bangkok",
+	"Asia/Novosibirsk": 				"api.meeting.timezone.Asia/Novosibirsk",
+	"Asia/Krasnoyarsk": 				"api.meeting.timezone.Asia/Krasnoyarsk",
+	"Asia/Ulaanbaatar": 				"api.meeting.timezone.Asia/Ulaanbaatar",
+	"Asia/Shanghai": 					"api.meeting.timezone.Asia/Shanghai",
+	"Australia/Perth": 					"api.meeting.timezone.Australia/Perth",
+	"Asia/Singapore": 					"api.meeting.timezone.Asia/Singapore",
+	"Asia/Taipei": 						"api.meeting.timezone.Asia/Taipei",
+	"Australia/Eucla": 					"api.meeting.timezone.Australia/Eucla",
+	"Asia/Irkutsk": 					"api.meeting.timezone.Asia/Irkutsk",
+	"Asia/Seoul": 						"api.meeting.timezone.Asia/Seoul",
+	"Asia/Tokyo": 						"api.meeting.timezone.Asia/Tokyo",
+	"Australia/Darwin": 				"api.meeting.timezone.Australia/Darwin",
+	"Australia/Adelaide": 				"api.meeting.timezone.Australia/Adelaide",
+	"Australia/Hobart": 				"api.meeting.timezone.Australia/Hobart",
+	"Asia/Yakutsk": 					"api.meeting.timezone.Asia/Yakutsk",
+	"Australia/Brisbane": 				"api.meeting.timezone.Australia/Brisbane",
+	"Pacific/Port_Moresby": 			"api.meeting.timezone.Pacific/Port_Moresby",
+	"Australia/Sydney": 				"api.meeting.timezone.Australia/Sydney",
+	"Australia/LHI": 					"api.meeting.timezone.Australia/LHI",
+	"Asia/Vladivostok": 				"api.meeting.timezone.Asia/Vladivostok",
+	"Pacific/Guadalcanal": 				"api.meeting.timezone.Pacific/Guadalcanal",
+	"Etc/GMT-12": 						"api.meeting.timezone.Etc/GMT-12",
+	"Pacific/Fiji": 					"api.meeting.timezone.Pacific/Fiji",
+	"Asia/Magadan": 					"api.meeting.timezone.Asia/Magadan",
+	"Pacific/Auckland": 				"api.meeting.timezone.Pacific/Auckland",
+	"Pacific/Chatham": 					"api.meeting.timezone.Pacific/Chatham",
+	"Pacific/Tongatapu": 				"api.meeting.timezone.Pacific/Tongatapu",
+	"Pacific/Apia": 					"api.meeting.timezone.Pacific/Apia",
+	"Pacific/Kiritimati": 				"api.meeting.timezone.Pacific/Kiritimati",
+}
+
+var RSMeetingTimezonesICSInfo = map[string]string {
+	"Europe/Budapest":					"\nBEGIN:VTIMEZONE\nTZID:Europe/Budapest\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Europe/Budapest\nX-LIC-LOCATION:Europe/Budapest\nBEGIN:DAYLIGHT\nTZNAME:CEST\nTZOFFSETFROM:+0100\nTZOFFSETTO:+0200\nDTSTART:19700329T020000\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\nEND:DAYLIGHT\nBEGIN:STANDARD\nTZNAME:CET\nTZOFFSETFROM:+0200\nTZOFFSETTO:+0100\nDTSTART:19701025T030000\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Atlantic/Cape_Verde":				"\nBEGIN:VTIMEZONE\nTZID:Atlantic/Cape_Verde\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Atlantic/Cape_Verde\nX-LIC-LOCATION:Atlantic/Cape_Verde\nBEGIN:STANDARD\nTZNAME:-01\nTZOFFSETFROM:-0100\nTZOFFSETTO:-0100\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Europe/Paris":						"\nBEGIN:VTIMEZONE\nTZID:Europe/Paris\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Europe/Paris\nX-LIC-LOCATION:Europe/Paris\nBEGIN:DAYLIGHT\nTZNAME:CEST\nTZOFFSETFROM:+0100\nTZOFFSETTO:+0200\nDTSTART:19700329T020000\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\nEND:DAYLIGHT\nBEGIN:STANDARD\nTZNAME:CET\nTZOFFSETFROM:+0200\nTZOFFSETTO:+0100\nDTSTART:19701025T030000\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Africa/Nairobi":					"\nBEGIN:VTIMEZONE\nTZID:Africa/Nairobi\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Africa/Nairobi\nX-LIC-LOCATION:Africa/Nairobi\nBEGIN:STANDARD\nTZNAME:EAT\nTZOFFSETFROM:+0300\nTZOFFSETTO:+0300\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Asia/Singapore":					"\nBEGIN:VTIMEZONE\nTZID:Asia/Singapore\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Asia/Singapore\nX-LIC-LOCATION:Asia/Singapore\nBEGIN:STANDARD\nTZNAME:+08\nTZOFFSETFROM:+0800\nTZOFFSETTO:+0800\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Asia/Taipei":						"\nBEGIN:VTIMEZONE\nTZID:Asia/Taipei\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Asia/Taipei\nX-LIC-LOCATION:Asia/Taipei\nBEGIN:STANDARD\nTZNAME:CST\nTZOFFSETFROM:+0800\nTZOFFSETTO:+0800\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Etc/GMT-12":						"\nBEGIN:VTIMEZONE\nTZID:Etc/GMT-12\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Etc/GMT-12\nX-LIC-LOCATION:Etc/GMT-12\nBEGIN:STANDARD\nTZNAME:+12\nTZOFFSETFROM:+1200\nTZOFFSETTO:+1200\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"America/New_York":					"\nBEGIN:VTIMEZONE\nTZID:America/New_York\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/America/New_York\nX-LIC-LOCATION:America/New_York\nBEGIN:DAYLIGHT\nTZNAME:EDT\nTZOFFSETFROM:-0500\nTZOFFSETTO:-0400\nDTSTART:19700308T020000\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\nEND:DAYLIGHT\nBEGIN:STANDARD\nTZNAME:EST\nTZOFFSETFROM:-0400\nTZOFFSETTO:-0500\nDTSTART:19701101T020000\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"America/Guatemala":				"\nBEGIN:VTIMEZONE\nTZID:America/Guatemala\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/America/Guatemala\nX-LIC-LOCATION:America/Guatemala\nBEGIN:STANDARD\nTZNAME:CST\nTZOFFSETFROM:-0600\nTZOFFSETTO:-0600\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"America/Indiana/Indianapolis":		"\nBEGIN:VTIMEZONE\nTZID:America/Indiana/Indianapolis\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/America/Indiana/Indianapolis\nX-LIC-LOCATION:America/Indiana/Indianapolis\nBEGIN:DAYLIGHT\nTZNAME:EDT\nTZOFFSETFROM:-0500\nTZOFFSETTO:-0400\nDTSTART:19700308T020000\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\nEND:DAYLIGHT\nBEGIN:STANDARD\nTZNAME:EST\nTZOFFSETFROM:-0400\nTZOFFSETTO:-0500\nDTSTART:19701101T020000\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Pacific/Guadalcanal":				"\nBEGIN:VTIMEZONE\nTZID:Pacific/Guadalcanal\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Pacific/Guadalcanal\nX-LIC-LOCATION:Pacific/Guadalcanal\nBEGIN:STANDARD\nTZNAME:+11\nTZOFFSETFROM:+1100\nTZOFFSETTO:+1100\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Etc/GMT+12":						"\nBEGIN:VTIMEZONE\nTZID:Etc/GMT+12\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Etc/GMT+12\nX-LIC-LOCATION:Etc/GMT+12\nBEGIN:STANDARD\nTZNAME:-12\nTZOFFSETFROM:-1200\nTZOFFSETTO:-1200\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"America/La_Paz":					"\nBEGIN:VTIMEZONE\nTZID:America/La_Paz\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/America/La_Paz\nX-LIC-LOCATION:America/La_Paz\nBEGIN:STANDARD\nTZNAME:-04\nTZOFFSETFROM:-0400\nTZOFFSETTO:-0400\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Africa/Lagos":						"\nBEGIN:VTIMEZONE\nTZID:Africa/Lagos\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Africa/Lagos\nX-LIC-LOCATION:Africa/Lagos\nBEGIN:STANDARD\nTZNAME:WAT\nTZOFFSETFROM:+0100\nTZOFFSETTO:+0100\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Europe/Kiev":						"\nBEGIN:VTIMEZONE\nTZID:Europe/Kiev\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Europe/Kiev\nX-LIC-LOCATION:Europe/Kiev\nBEGIN:DAYLIGHT\nTZNAME:EEST\nTZOFFSETFROM:+0200\nTZOFFSETTO:+0300\nDTSTART:19700329T030000\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\nEND:DAYLIGHT\nBEGIN:STANDARD\nTZNAME:EET\nTZOFFSETFROM:+0300\nTZOFFSETTO:+0200\nDTSTART:19701025T040000\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Asia/Baku":						"\nBEGIN:VTIMEZONE\nTZID:Asia/Baku\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Asia/Baku\nX-LIC-LOCATION:Asia/Baku\nBEGIN:STANDARD\nTZNAME:+04\nTZOFFSETFROM:+0400\nTZOFFSETTO:+0400\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"America/Halifax":					"\nBEGIN:VTIMEZONE\nTZID:America/Halifax\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/America/Halifax\nX-LIC-LOCATION:America/Halifax\nBEGIN:DAYLIGHT\nTZNAME:ADT\nTZOFFSETFROM:-0400\nTZOFFSETTO:-0300\nDTSTART:19700308T020000\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\nEND:DAYLIGHT\nBEGIN:STANDARD\nTZNAME:AST\nTZOFFSETFROM:-0300\nTZOFFSETTO:-0400\nDTSTART:19701101T020000\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"America/Phoenix":					"\nBEGIN:VTIMEZONE\nTZID:America/Phoenix\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/America/Phoenix\nX-LIC-LOCATION:America/Phoenix\nBEGIN:STANDARD\nTZNAME:MST\nTZOFFSETFROM:-0700\nTZOFFSETTO:-0700\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"America/Regina":					"\nBEGIN:VTIMEZONE\nTZID:America/Regina\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/America/Regina\nX-LIC-LOCATION:America/Regina\nBEGIN:STANDARD\nTZNAME:CST\nTZOFFSETFROM:-0600\nTZOFFSETTO:-0600\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"America/Cuiaba":					"\nBEGIN:VTIMEZONE\nTZID:America/Cuiaba\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/America/Cuiaba\nX-LIC-LOCATION:America/Cuiaba\nBEGIN:STANDARD\nTZNAME:-04\nTZOFFSETFROM:-0400\nTZOFFSETTO:-0400\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Europe/Istanbul":					"\nBEGIN:VTIMEZONE\nTZID:Europe/Istanbul\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Europe/Istanbul\nX-LIC-LOCATION:Europe/Istanbul\nBEGIN:STANDARD\nTZNAME:+03\nTZOFFSETFROM:+0300\nTZOFFSETTO:+0300\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Europe/Minsk":						"\nBEGIN:VTIMEZONE\nTZID:Europe/Minsk\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Europe/Minsk\nX-LIC-LOCATION:Europe/Minsk\nBEGIN:STANDARD\nTZNAME:+03\nTZOFFSETFROM:+0300\nTZOFFSETTO:+0300\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Asia/Dubai":						"\nBEGIN:VTIMEZONE\nTZID:Asia/Dubai\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Asia/Dubai\nX-LIC-LOCATION:Asia/Dubai\nBEGIN:STANDARD\nTZNAME:+04\nTZOFFSETFROM:+0400\nTZOFFSETTO:+0400\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"America/Los_Angeles":				"\nBEGIN:VTIMEZONE\nTZID:America/Los_Angeles\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/America/Los_Angeles\nX-LIC-LOCATION:America/Los_Angeles\nBEGIN:DAYLIGHT\nTZNAME:PDT\nTZOFFSETFROM:-0800\nTZOFFSETTO:-0700\nDTSTART:19700308T020000\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\nEND:DAYLIGHT\nBEGIN:STANDARD\nTZNAME:PST\nTZOFFSETFROM:-0700\nTZOFFSETTO:-0800\nDTSTART:19701101T020000\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Australia/Darwin":					"\nBEGIN:VTIMEZONE\nTZID:Australia/Darwin\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Australia/Darwin\nX-LIC-LOCATION:Australia/Darwin\nBEGIN:STANDARD\nTZNAME:ACST\nTZOFFSETFROM:+0930\nTZOFFSETTO:+0930\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Australia/Sydney":					"\nBEGIN:VTIMEZONE\nTZID:Australia/Sydney\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Australia/Sydney\nX-LIC-LOCATION:Australia/Sydney\nBEGIN:STANDARD\nTZNAME:AEST\nTZOFFSETFROM:+1100\nTZOFFSETTO:+1000\nDTSTART:19700405T030000\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\nEND:STANDARD\nBEGIN:DAYLIGHT\nTZNAME:AEDT\nTZOFFSETFROM:+1000\nTZOFFSETTO:+1100\nDTSTART:19701004T020000\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\nEND:DAYLIGHT\nEND:VTIMEZONE\n",
+	"Australia/LHI":					"\nBEGIN:VTIMEZONE\nTZID:Australia/LHI\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Australia/LHI\nX-LIC-LOCATION:Australia/LHI\nBEGIN:STANDARD\nDTSTART:16010401T020000\nRRULE:FREQ=YEARLY;BYDAY=1SU;BYMONTH=4\nTZOFFSETFROM:+1100\nTZOFFSETTO:+1030\nEND:STANDARD\nBEGIN:DAYLIGHT\nDTSTART:16011007T020000\nRRULE:FREQ=YEARLY;BYDAY=1SU;BYMONTH=10\nTZOFFSETFROM:+1030\nTZOFFSETTO:+1100\nEND:DAYLIGHT\nEND:VTIMEZONE\n",
+	"Australia/Eucla":					"\nBEGIN:VTIMEZONE\nTZID:Australia/Eucla\nLAST-MODIFIED:20211011T073223Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Australia/Eucla\nX-LIC-LOCATION:Australia/Eucla\nBEGIN:STANDARD\nTZNAME:ACST\nTZOFFSETFROM:+0845\nTZOFFSETTO:+0845\nDTSTART:16010101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Asia/Kathmandu":					"\nBEGIN:VTIMEZONE\nTZID:Asia/Kathmandu\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Asia/Kathmandu\nX-LIC-LOCATION:Asia/Kathmandu\nBEGIN:STANDARD\nTZNAME:+0545\nTZOFFSETFROM:+0545\nTZOFFSETTO:+0545\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Asia/Shanghai":					"\nBEGIN:VTIMEZONE\nTZID:Asia/Shanghai\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Asia/Shanghai\nX-LIC-LOCATION:Asia/Shanghai\nBEGIN:STANDARD\nTZNAME:CST\nTZOFFSETFROM:+0800\nTZOFFSETTO:+0800\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Asia/Magadan":						"\nBEGIN:VTIMEZONE\nTZID:Asia/Magadan\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Asia/Magadan\nX-LIC-LOCATION:Asia/Magadan\nBEGIN:STANDARD\nTZNAME:+11\nTZOFFSETFROM:+1100\nTZOFFSETTO:+1100\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"America/Denver":					"\nBEGIN:VTIMEZONE\nTZID:America/Denver\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/America/Denver\nX-LIC-LOCATION:America/Denver\nBEGIN:DAYLIGHT\nTZNAME:MDT\nTZOFFSETFROM:-0700\nTZOFFSETTO:-0600\nDTSTART:19700308T020000\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\nEND:DAYLIGHT\nBEGIN:STANDARD\nTZNAME:MST\nTZOFFSETFROM:-0600\nTZOFFSETTO:-0700\nDTSTART:19701101T020000\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Pacific/Honolulu":					"\nBEGIN:VTIMEZONE\nTZID:Pacific/Honolulu\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Pacific/Honolulu\nX-LIC-LOCATION:Pacific/Honolulu\nBEGIN:STANDARD\nTZNAME:HST\nTZOFFSETFROM:-1000\nTZOFFSETTO:-1000\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Pacific/Marquesas":				"\nBEGIN:VTIMEZONE\nTZID:Pacific/Marquesas\nLAST-MODIFIED:20211011T071216Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Pacific/Marquesas\nX-LIC-LOCATION:Pacific/Marquesas\nBEGIN:STANDARD\nTZNAME:MST\nTZOFFSETFROM:-0930\nTZOFFSETTO:-0930\nDTSTART:16010101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"America/Chihuahua":				"\nBEGIN:VTIMEZONE\nTZID:America/Chihuahua\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/America/Chihuahua\nX-LIC-LOCATION:America/Chihuahua\nBEGIN:DAYLIGHT\nTZNAME:MDT\nTZOFFSETFROM:-0700\nTZOFFSETTO:-0600\nDTSTART:19700405T020000\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\nEND:DAYLIGHT\nBEGIN:STANDARD\nTZNAME:MST\nTZOFFSETFROM:-0600\nTZOFFSETTO:-0700\nDTSTART:19701025T020000\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Atlantic/Azores":					"\nBEGIN:VTIMEZONE\nTZID:Atlantic/Azores\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Atlantic/Azores\nX-LIC-LOCATION:Atlantic/Azores\nBEGIN:DAYLIGHT\nTZNAME:+00\nTZOFFSETFROM:-0100\nTZOFFSETTO:+0000\nDTSTART:19700329T000000\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\nEND:DAYLIGHT\nBEGIN:STANDARD\nTZNAME:-01\nTZOFFSETFROM:+0000\nTZOFFSETTO:-0100\nDTSTART:19701025T010000\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Europe/London":					"\nBEGIN:VTIMEZONE\nTZID:Europe/London\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Europe/London\nX-LIC-LOCATION:Europe/London\nBEGIN:DAYLIGHT\nTZNAME:BST\nTZOFFSETFROM:+0000\nTZOFFSETTO:+0100\nDTSTART:19700329T010000\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\nEND:DAYLIGHT\nBEGIN:STANDARD\nTZNAME:GMT\nTZOFFSETFROM:+0100\nTZOFFSETTO:+0000\nDTSTART:19701025T020000\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Asia/Tbilisi":						"\nBEGIN:VTIMEZONE\nTZID:Asia/Tbilisi\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Asia/Tbilisi\nX-LIC-LOCATION:Asia/Tbilisi\nBEGIN:STANDARD\nTZNAME:+04\nTZOFFSETFROM:+0400\nTZOFFSETTO:+0400\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Indian/Mauritius":					"\nBEGIN:VTIMEZONE\nTZID:Indian/Mauritius\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Indian/Mauritius\nX-LIC-LOCATION:Indian/Mauritius\nBEGIN:STANDARD\nTZNAME:+04\nTZOFFSETFROM:+0400\nTZOFFSETTO:+0400\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Pacific/Port_Moresby":				"\nBEGIN:VTIMEZONE\nTZID:Pacific/Port_Moresby\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Pacific/Port_Moresby\nX-LIC-LOCATION:Pacific/Port_Moresby\nBEGIN:STANDARD\nTZNAME:+10\nTZOFFSETFROM:+1000\nTZOFFSETTO:+1000\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Etc/GMT+11":						"\nBEGIN:VTIMEZONE\nTZID:Etc/GMT+11\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Etc/GMT+11\nX-LIC-LOCATION:Etc/GMT+11\nBEGIN:STANDARD\nTZNAME:-11\nTZOFFSETFROM:-1100\nTZOFFSETTO:-1100\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"America/Argentina/Buenos_Aires":	"\nBEGIN:VTIMEZONE\nTZID:America/Argentina/Buenos_Aires\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/America/Argentina/Buenos_Aires\nX-LIC-LOCATION:America/Argentina/Buenos_Aires\nBEGIN:STANDARD\nTZNAME:-03\nTZOFFSETFROM:-0300\nTZOFFSETTO:-0300\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Europe/Berlin":					"\nBEGIN:VTIMEZONE\nTZID:Europe/Berlin\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Europe/Berlin\nX-LIC-LOCATION:Europe/Berlin\nBEGIN:DAYLIGHT\nTZNAME:CEST\nTZOFFSETFROM:+0100\nTZOFFSETTO:+0200\nDTSTART:19700329T020000\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\nEND:DAYLIGHT\nBEGIN:STANDARD\nTZNAME:CET\nTZOFFSETFROM:+0200\nTZOFFSETTO:+0100\nDTSTART:19701025T030000\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Africa/Windhoek":					"\nBEGIN:VTIMEZONE\nTZID:Africa/Windhoek\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Africa/Windhoek\nX-LIC-LOCATION:Africa/Windhoek\nBEGIN:STANDARD\nTZNAME:CAT\nTZOFFSETFROM:+0200\nTZOFFSETTO:+0200\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Africa/Cairo":						"\nBEGIN:VTIMEZONE\nTZID:Africa/Cairo\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Africa/Cairo\nX-LIC-LOCATION:Africa/Cairo\nBEGIN:STANDARD\nTZNAME:EET\nTZOFFSETFROM:+0200\nTZOFFSETTO:+0200\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Asia/Damascus":					"\nBEGIN:VTIMEZONE\nTZID:Asia/Damascus\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Asia/Damascus\nX-LIC-LOCATION:Asia/Damascus\nBEGIN:STANDARD\nTZNAME:EET\nTZOFFSETFROM:+0300\nTZOFFSETTO:+0200\nDTSTART:19701030T000000\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1FR\nEND:STANDARD\nBEGIN:DAYLIGHT\nTZNAME:EEST\nTZOFFSETFROM:+0200\nTZOFFSETTO:+0300\nDTSTART:19700327T000000\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1FR\nEND:DAYLIGHT\nEND:VTIMEZONE\n",
+	"Asia/Beirut":						"\nBEGIN:VTIMEZONE\nTZID:Asia/Beirut\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Asia/Beirut\nX-LIC-LOCATION:Asia/Beirut\nBEGIN:DAYLIGHT\nTZNAME:EEST\nTZOFFSETFROM:+0200\nTZOFFSETTO:+0300\nDTSTART:19700329T000000\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\nEND:DAYLIGHT\nBEGIN:STANDARD\nTZNAME:EET\nTZOFFSETFROM:+0300\nTZOFFSETTO:+0200\nDTSTART:19701025T000000\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Asia/Yangon":						"\nBEGIN:VTIMEZONE\nTZID:Asia/Yangon\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Asia/Yangon\nX-LIC-LOCATION:Asia/Yangon\nBEGIN:STANDARD\nTZNAME:+0630\nTZOFFSETFROM:+0630\nTZOFFSETTO:+0630\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"America/Santiago":					"\nBEGIN:VTIMEZONE\nTZID:America/Santiago\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/America/Santiago\nX-LIC-LOCATION:America/Santiago\nBEGIN:STANDARD\nTZNAME:-04\nTZOFFSETFROM:-0300\nTZOFFSETTO:-0400\nDTSTART:19700405T000000\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\nEND:STANDARD\nBEGIN:DAYLIGHT\nTZNAME:-03\nTZOFFSETFROM:-0400\nTZOFFSETTO:-0300\nDTSTART:19700906T000000\nRRULE:FREQ=YEARLY;BYMONTH=9;BYDAY=1SU\nEND:DAYLIGHT\nEND:VTIMEZONE\n",
+	"Asia/Irkutsk":						"\nBEGIN:VTIMEZONE\nTZID:Asia/Irkutsk\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Asia/Irkutsk\nX-LIC-LOCATION:Asia/Irkutsk\nBEGIN:STANDARD\nTZNAME:+08\nTZOFFSETFROM:+0800\nTZOFFSETTO:+0800\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"America/Chicago":					"\nBEGIN:VTIMEZONE\nTZID:America/Chicago\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/America/Chicago\nX-LIC-LOCATION:America/Chicago\nBEGIN:DAYLIGHT\nTZNAME:CDT\nTZOFFSETFROM:-0600\nTZOFFSETTO:-0500\nDTSTART:19700308T020000\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\nEND:DAYLIGHT\nBEGIN:STANDARD\nTZNAME:CST\nTZOFFSETFROM:-0500\nTZOFFSETTO:-0600\nDTSTART:19701101T020000\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"America/Sao_Paulo":				"\nBEGIN:VTIMEZONE\nTZID:America/Sao_Paulo\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/America/Sao_Paulo\nX-LIC-LOCATION:America/Sao_Paulo\nBEGIN:STANDARD\nTZNAME:-03\nTZOFFSETFROM:-0300\nTZOFFSETTO:-0300\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"America/Cayenne":					"\nBEGIN:VTIMEZONE\nTZID:America/Cayenne\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/America/Cayenne\nX-LIC-LOCATION:America/Cayenne\nBEGIN:STANDARD\nTZNAME:-03\nTZOFFSETFROM:-0300\nTZOFFSETTO:-0300\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"America/Montevideo":				"\nBEGIN:VTIMEZONE\nTZID:America/Montevideo\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/America/Montevideo\nX-LIC-LOCATION:America/Montevideo\nBEGIN:STANDARD\nTZNAME:-03\nTZOFFSETFROM:-0300\nTZOFFSETTO:-0300\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Etc/GMT+2":						"\nBEGIN:VTIMEZONE\nTZID:Etc/GMT+2\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Etc/GMT+2\nX-LIC-LOCATION:Etc/GMT+2\nBEGIN:STANDARD\nTZNAME:-02\nTZOFFSETFROM:-0200\nTZOFFSETTO:-0200\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Asia/Bangkok":						"\nBEGIN:VTIMEZONE\nTZID:Asia/Bangkok\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Asia/Bangkok\nX-LIC-LOCATION:Asia/Bangkok\nBEGIN:STANDARD\nTZNAME:+07\nTZOFFSETFROM:+0700\nTZOFFSETTO:+0700\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Asia/Krasnoyarsk":					"\nBEGIN:VTIMEZONE\nTZID:Asia/Krasnoyarsk\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Asia/Krasnoyarsk\nX-LIC-LOCATION:Asia/Krasnoyarsk\nBEGIN:STANDARD\nTZNAME:+07\nTZOFFSETFROM:+0700\nTZOFFSETTO:+0700\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"America/Anchorage":				"\nBEGIN:VTIMEZONE\nTZID:America/Anchorage\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/America/Anchorage\nX-LIC-LOCATION:America/Anchorage\nBEGIN:DAYLIGHT\nTZNAME:AKDT\nTZOFFSETFROM:-0900\nTZOFFSETTO:-0800\nDTSTART:19700308T020000\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\nEND:DAYLIGHT\nBEGIN:STANDARD\nTZNAME:AKST\nTZOFFSETFROM:-0800\nTZOFFSETTO:-0900\nDTSTART:19701101T020000\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Pacific/Apia":						"\nBEGIN:VTIMEZONE\nTZID:Pacific/Apia\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Pacific/Apia\nX-LIC-LOCATION:Pacific/Apia\nBEGIN:STANDARD\nTZNAME:+13\nTZOFFSETFROM:+1400\nTZOFFSETTO:+1300\nDTSTART:19700405T040000\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\nEND:STANDARD\nBEGIN:DAYLIGHT\nTZNAME:+14\nTZOFFSETFROM:+1300\nTZOFFSETTO:+1400\nDTSTART:19700927T030000\nRRULE:FREQ=YEARLY;BYMONTH=9;BYDAY=-1SU\nEND:DAYLIGHT\nEND:VTIMEZONE\n",
+	"Pacific/Kiritimati":				"\nBEGIN:VTIMEZONE\nTZID:Pacific/Kiritimati\nLAST-MODIFIED:20211011T081511Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Pacific/Kiritimati\nX-LIC-LOCATION:Pacific/Kiritimati\nBEGIN:STANDARD\nDTSTART:16010101T000000\nTZOFFSETFROM:+1400\nTZOFFSETTO:+1400\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Asia/Riyadh":						"\nBEGIN:VTIMEZONE\nTZID:Asia/Riyadh\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Asia/Riyadh\nX-LIC-LOCATION:Asia/Riyadh\nBEGIN:STANDARD\nTZNAME:+03\nTZOFFSETFROM:+0300\nTZOFFSETTO:+0300\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Europe/Moscow":					"\nBEGIN:VTIMEZONE\nTZID:Europe/Moscow\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Europe/Moscow\nX-LIC-LOCATION:Europe/Moscow\nBEGIN:STANDARD\nTZNAME:MSK\nTZOFFSETFROM:+0300\nTZOFFSETTO:+0300\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Asia/Almaty":						"\nBEGIN:VTIMEZONE\nTZID:Asia/Almaty\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Asia/Almaty\nX-LIC-LOCATION:Asia/Almaty\nBEGIN:STANDARD\nTZNAME:+06\nTZOFFSETFROM:+0600\nTZOFFSETTO:+0600\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Asia/Ulaanbaatar":					"\nBEGIN:VTIMEZONE\nTZID:Asia/Ulaanbaatar\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Asia/Ulaanbaatar\nX-LIC-LOCATION:Asia/Ulaanbaatar\nBEGIN:STANDARD\nTZNAME:+08\nTZOFFSETFROM:+0800\nTZOFFSETTO:+0800\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Australia/Perth":					"\nBEGIN:VTIMEZONE\nTZID:Australia/Perth\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Australia/Perth\nX-LIC-LOCATION:Australia/Perth\nBEGIN:STANDARD\nTZNAME:AWST\nTZOFFSETFROM:+0800\nTZOFFSETTO:+0800\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Asia/Seoul":						"\nBEGIN:VTIMEZONE\nTZID:Asia/Seoul\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Asia/Seoul\nX-LIC-LOCATION:Asia/Seoul\nBEGIN:STANDARD\nTZNAME:KST\nTZOFFSETFROM:+0900\nTZOFFSETTO:+0900\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Pacific/Tongatapu":				"\nBEGIN:VTIMEZONE\nTZID:Pacific/Tongatapu\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Pacific/Tongatapu\nX-LIC-LOCATION:Pacific/Tongatapu\nBEGIN:STANDARD\nTZNAME:+13\nTZOFFSETFROM:+1300\nTZOFFSETTO:+1300\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Asia/Jerusalem":					"\nBEGIN:VTIMEZONE\nTZID:Asia/Jerusalem\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Asia/Jerusalem\nX-LIC-LOCATION:Asia/Jerusalem\nBEGIN:DAYLIGHT\nTZNAME:IDT\nTZOFFSETFROM:+0200\nTZOFFSETTO:+0300\nDTSTART:19700327T020000\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1FR\nEND:DAYLIGHT\nBEGIN:STANDARD\nTZNAME:IST\nTZOFFSETFROM:+0300\nTZOFFSETTO:+0200\nDTSTART:19701025T020000\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Africa/Casablanca":				"\nBEGIN:VTIMEZONE\nTZID:Africa/Casablanca\nTZUNTIL:20870511T020001Z\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Africa/Casablanca\nX-LIC-LOCATION:Africa/Casablanca\nBEGIN:STANDARD\nTZNAME:+00\nTZOFFSETFROM:+0000\nTZOFFSETTO:+0000\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Asia/Dhaka":						"\nBEGIN:VTIMEZONE\nTZID:Asia/Dhaka\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Asia/Dhaka\nX-LIC-LOCATION:Asia/Dhaka\nBEGIN:STANDARD\nTZNAME:+06\nTZOFFSETFROM:+0600\nTZOFFSETTO:+0600\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"America/St_Johns":					"\nBEGIN:VTIMEZONE\nTZID:America/St_Johns\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/America/St_Johns\nX-LIC-LOCATION:America/St_Johns\nBEGIN:STANDARD\nTZNAME:NST\nTZOFFSETFROM:-0230\nTZOFFSETTO:-0330\nDTSTART:19701101T020000\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\nEND:STANDARD\nBEGIN:DAYLIGHT\nTZNAME:NDT\nTZOFFSETFROM:-0330\nTZOFFSETTO:-0230\nDTSTART:19700308T020000\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\nEND:DAYLIGHT\nEND:VTIMEZONE\n",
+	"Africa/Johannesburg":				"\nBEGIN:VTIMEZONE\nTZID:Africa/Johannesburg\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Africa/Johannesburg\nX-LIC-LOCATION:Africa/Johannesburg\nBEGIN:STANDARD\nTZNAME:SAST\nTZOFFSETFROM:+0200\nTZOFFSETTO:+0200\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Asia/Yerevan":						"\nBEGIN:VTIMEZONE\nTZID:Asia/Yerevan\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Asia/Yerevan\nX-LIC-LOCATION:Asia/Yerevan\nBEGIN:STANDARD\nTZNAME:+04\nTZOFFSETFROM:+0400\nTZOFFSETTO:+0400\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Asia/Colombo":						"\nBEGIN:VTIMEZONE\nTZID:Asia/Colombo\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Asia/Colombo\nX-LIC-LOCATION:Asia/Colombo\nBEGIN:STANDARD\nTZNAME:+0530\nTZOFFSETFROM:+0530\nTZOFFSETTO:+0530\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Asia/Tokyo":						"\nBEGIN:VTIMEZONE\nTZID:Asia/Tokyo\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Asia/Tokyo\nX-LIC-LOCATION:Asia/Tokyo\nBEGIN:STANDARD\nTZNAME:JST\nTZOFFSETFROM:+0900\nTZOFFSETTO:+0900\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Asia/Yakutsk":						"\nBEGIN:VTIMEZONE\nTZID:Asia/Yakutsk\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Asia/Yakutsk\nX-LIC-LOCATION:Asia/Yakutsk\nBEGIN:STANDARD\nTZNAME:+09\nTZOFFSETFROM:+0900\nTZOFFSETTO:+0900\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Asia/Vladivostok":					"\nBEGIN:VTIMEZONE\nTZID:Asia/Vladivostok\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Asia/Vladivostok\nX-LIC-LOCATION:Asia/Vladivostok\nBEGIN:STANDARD\nTZNAME:+10\nTZOFFSETFROM:+1000\nTZOFFSETTO:+1000\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"America/Asuncion":					"\nBEGIN:VTIMEZONE\nTZID:America/Asuncion\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/America/Asuncion\nX-LIC-LOCATION:America/Asuncion\nBEGIN:DAYLIGHT\nTZNAME:-03\nTZOFFSETFROM:-0400\nTZOFFSETTO:-0300\nDTSTART:19701004T000000\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\nEND:DAYLIGHT\nBEGIN:STANDARD\nTZNAME:-04\nTZOFFSETFROM:-0300\nTZOFFSETTO:-0400\nDTSTART:19700322T000000\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=4SU\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Asia/Karachi":						"\nBEGIN:VTIMEZONE\nTZID:Asia/Karachi\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Asia/Karachi\nX-LIC-LOCATION:Asia/Karachi\nBEGIN:STANDARD\nTZNAME:PKT\nTZOFFSETFROM:+0500\nTZOFFSETTO:+0500\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Australia/Adelaide":				"\nBEGIN:VTIMEZONE\nTZID:Australia/Adelaide\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Australia/Adelaide\nX-LIC-LOCATION:Australia/Adelaide\nBEGIN:STANDARD\nTZNAME:ACST\nTZOFFSETFROM:+1030\nTZOFFSETTO:+0930\nDTSTART:19700405T030000\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\nEND:STANDARD\nBEGIN:DAYLIGHT\nTZNAME:ACDT\nTZOFFSETFROM:+0930\nTZOFFSETTO:+1030\nDTSTART:19701004T020000\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\nEND:DAYLIGHT\nEND:VTIMEZONE\n",
+	"Pacific/Fiji":						"\nBEGIN:VTIMEZONE\nTZID:Pacific/Fiji\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Pacific/Fiji\nX-LIC-LOCATION:Pacific/Fiji\nBEGIN:STANDARD\nTZNAME:+12\nTZOFFSETFROM:+1300\nTZOFFSETTO:+1200\nDTSTART:19700118T030000\nRRULE:FREQ=YEARLY;BYMONTH=1;BYDAY=-2SU\nEND:STANDARD\nBEGIN:DAYLIGHT\nTZNAME:+13\nTZOFFSETFROM:+1200\nTZOFFSETTO:+1300\nDTSTART:19701108T020000\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=2SU\nEND:DAYLIGHT\nEND:VTIMEZONE\n",
+	"Pacific/Auckland":					"\nBEGIN:VTIMEZONE\nTZID:Pacific/Auckland\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Pacific/Auckland\nX-LIC-LOCATION:Pacific/Auckland\nBEGIN:DAYLIGHT\nTZNAME:NZDT\nTZOFFSETFROM:+1200\nTZOFFSETTO:+1300\nDTSTART:19700927T020000\nRRULE:FREQ=YEARLY;BYMONTH=9;BYDAY=-1SU\nEND:DAYLIGHT\nBEGIN:STANDARD\nTZNAME:NZST\nTZOFFSETFROM:+1300\nTZOFFSETTO:+1200\nDTSTART:19700405T030000\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Pacific/Chatham":					"\nBEGIN:VTIMEZONE\nTZID:Pacific/Chatham\nLAST-MODIFIED:20211011T080750Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Pacific/Chatham\nX-LIC-LOCATION:Pacific/Chatham\nBEGIN:STANDARD\nDTSTART:16010401T034500\nRRULE:FREQ=YEARLY;BYDAY=1SU;BYMONTH=4\nTZOFFSETFROM:+1345\nTZOFFSETTO:+1245\nEND:STANDARD\nBEGIN:DAYLIGHT\nDTSTART:16010930T024500\nRRULE:FREQ=YEARLY;BYDAY=-1SU;BYMONTH=9\nTZOFFSETFROM:+1245\nTZOFFSETTO:+1345\nEND:DAYLIGHT\nEND:VTIMEZONE\n",
+	"America/Mexico_City":				"\nBEGIN:VTIMEZONE\nTZID:America/Mexico_City\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/America/Mexico_City\nX-LIC-LOCATION:America/Mexico_City\nBEGIN:DAYLIGHT\nTZNAME:CDT\nTZOFFSETFROM:-0600\nTZOFFSETTO:-0500\nDTSTART:19700405T020000\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\nEND:DAYLIGHT\nBEGIN:STANDARD\nTZNAME:CST\nTZOFFSETFROM:-0500\nTZOFFSETTO:-0600\nDTSTART:19701025T020000\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Asia/Kolkata":						"\nBEGIN:VTIMEZONE\nTZID:Asia/Kolkata\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Asia/Kolkata\nX-LIC-LOCATION:Asia/Kolkata\nBEGIN:STANDARD\nTZNAME:IST\nTZOFFSETFROM:+0530\nTZOFFSETTO:+0530\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Asia/Tehran":						"\nBEGIN:VTIMEZONE\nTZID:Asia/Tehran\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Asia/Tehran\nX-LIC-LOCATION:Asia/Tehran\nBEGIN:DAYLIGHT\nTZNAME:+0430\nTZOFFSETFROM:+0330\nTZOFFSETTO:+0430\nDTSTART:19700321T000000\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=3SU\nEND:DAYLIGHT\nBEGIN:STANDARD\nTZNAME:+0330\nTZOFFSETFROM:+0430\nTZOFFSETTO:+0330\nDTSTART:19700921T000000\nRRULE:FREQ=YEARLY;BYMONTH=9;BYDAY=3SU\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Atlantic/Reykjavik":				"\nBEGIN:VTIMEZONE\nTZID:Atlantic/Reykjavik\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Atlantic/Reykjavik\nX-LIC-LOCATION:Atlantic/Reykjavik\nBEGIN:STANDARD\nTZNAME:GMT\nTZOFFSETFROM:+0000\nTZOFFSETTO:+0000\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Europe/Warsaw":					"\nBEGIN:VTIMEZONE\nTZID:Europe/Warsaw\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Europe/Warsaw\nX-LIC-LOCATION:Europe/Warsaw\nBEGIN:DAYLIGHT\nTZNAME:CEST\nTZOFFSETFROM:+0100\nTZOFFSETTO:+0200\nDTSTART:19700329T020000\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\nEND:DAYLIGHT\nBEGIN:STANDARD\nTZNAME:CET\nTZOFFSETFROM:+0200\nTZOFFSETTO:+0100\nDTSTART:19701025T030000\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Asia/Baghdad":						"\nBEGIN:VTIMEZONE\nTZID:Asia/Baghdad\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Asia/Baghdad\nX-LIC-LOCATION:Asia/Baghdad\nBEGIN:STANDARD\nTZNAME:+03\nTZOFFSETFROM:+0300\nTZOFFSETTO:+0300\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Asia/Tashkent":					"\nBEGIN:VTIMEZONE\nTZID:Asia/Tashkent\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Asia/Tashkent\nX-LIC-LOCATION:Asia/Tashkent\nBEGIN:STANDARD\nTZNAME:+05\nTZOFFSETFROM:+0500\nTZOFFSETTO:+0500\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Asia/Novosibirsk":					"\nBEGIN:VTIMEZONE\nTZID:Asia/Novosibirsk\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Asia/Novosibirsk\nX-LIC-LOCATION:Asia/Novosibirsk\nBEGIN:STANDARD\nTZNAME:+07\nTZOFFSETFROM:+0700\nTZOFFSETTO:+0700\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Australia/Brisbane":				"\nBEGIN:VTIMEZONE\nTZID:Australia/Brisbane\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Australia/Brisbane\nX-LIC-LOCATION:Australia/Brisbane\nBEGIN:STANDARD\nTZNAME:AEST\nTZOFFSETFROM:+1000\nTZOFFSETTO:+1000\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"America/Godthab":					"\nBEGIN:VTIMEZONE\nTZID:America/Nuuk\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/America/Nuuk\nX-LIC-LOCATION:America/Nuuk\nBEGIN:DAYLIGHT\nTZNAME:-02\nTZOFFSETFROM:-0300\nTZOFFSETTO:-0200\nDTSTART:19700328T220000\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SA\nEND:DAYLIGHT\nBEGIN:STANDARD\nTZNAME:-03\nTZOFFSETFROM:-0200\nTZOFFSETTO:-0300\nDTSTART:19701024T230000\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SA\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"America/Bogota":					"\nBEGIN:VTIMEZONE\nTZID:America/Bogota\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/America/Bogota\nX-LIC-LOCATION:America/Bogota\nBEGIN:STANDARD\nTZNAME:-05\nTZOFFSETFROM:-0500\nTZOFFSETTO:-0500\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Etc/GMT":							"\nBEGIN:VTIMEZONE\nTZID:Etc/GMT\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Etc/GMT\nX-LIC-LOCATION:Etc/GMT\nBEGIN:STANDARD\nTZNAME:GMT\nTZOFFSETFROM:+0000\nTZOFFSETTO:+0000\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Asia/Amman":						"\nBEGIN:VTIMEZONE\nTZID:Asia/Amman\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Asia/Amman\nX-LIC-LOCATION:Asia/Amman\nBEGIN:DAYLIGHT\nTZNAME:EEST\nTZOFFSETFROM:+0200\nTZOFFSETTO:+0300\nDTSTART:19700327T000000\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1FR\nEND:DAYLIGHT\nBEGIN:STANDARD\nTZNAME:EET\nTZOFFSETFROM:+0300\nTZOFFSETTO:+0200\nDTSTART:19701030T010000\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1FR\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Asia/Kabul":						"\nBEGIN:VTIMEZONE\nTZID:Asia/Kabul\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Asia/Kabul\nX-LIC-LOCATION:Asia/Kabul\nBEGIN:STANDARD\nTZNAME:+0430\nTZOFFSETFROM:+0430\nTZOFFSETTO:+0430\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Asia/Yekaterinburg":				"\nBEGIN:VTIMEZONE\nTZID:Asia/Yekaterinburg\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Asia/Yekaterinburg\nX-LIC-LOCATION:Asia/Yekaterinburg\nBEGIN:STANDARD\nTZNAME:+05\nTZOFFSETFROM:+0500\nTZOFFSETTO:+0500\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"Australia/Hobart":					"\nBEGIN:VTIMEZONE\nTZID:Australia/Hobart\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/Australia/Hobart\nX-LIC-LOCATION:Australia/Hobart\nBEGIN:DAYLIGHT\nTZNAME:AEDT\nTZOFFSETFROM:+1000\nTZOFFSETTO:+1100\nDTSTART:19701004T020000\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\nEND:DAYLIGHT\nBEGIN:STANDARD\nTZNAME:AEST\nTZOFFSETFROM:+1100\nTZOFFSETTO:+1000\nDTSTART:19700405T030000\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\nEND:STANDARD\nEND:VTIMEZONE\n",
+	"America/Santa_Isabel":				"\nBEGIN:VTIMEZONE\nTZID:America/Tijuana\nLAST-MODIFIED:20201011T015911Z\nTZURL:http://tzurl.org/zoneinfo-outlook/America/Tijuana\nX-LIC-LOCATION:America/Tijuana\nBEGIN:DAYLIGHT\nTZNAME:PDT\nTZOFFSETFROM:-0800\nTZOFFSETTO:-0700\nDTSTART:19700308T020000\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\nEND:DAYLIGHT\nBEGIN:STANDARD\nTZNAME:PST\nTZOFFSETFROM:-0700\nTZOFFSETTO:-0800\nDTSTART:19701101T020000\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\nEND:STANDARD\nEND:VTIMEZONE\n",
+}
+
+func (o *ResponseResult) ToJson() string {
+	b, _ := json.Marshal(o)
+	return string(b)
+}
+
+func MeetingsListToJson(t []*MeetingToJson) string {
+	b, _ := json.Marshal(t)
+	return string(b)
+}
+
+func MeetingInfoToJson(t *RepeatMeetingToJson) string {
+	b, _ := json.Marshal(t)
+	return string(b)
+}
+
+func MeetingDataFromJson(data io.Reader) *MeetingFromJson {
+	var meetingData *MeetingFromJson
+	json.NewDecoder(data).Decode(&meetingData)
+	return meetingData
+}
+
+func DelParamsFromJson(data io.Reader) *DeleteParamsFromJson {
+	var delParams *DeleteParamsFromJson
+	json.NewDecoder(data).Decode(&delParams)
+	return delParams
+}
+
+func RepeatConfigToJson(t *RepeatConfig) string {
+	b, _ := json.Marshal(t)
+	return string(b)
+}
+
+func RepeatConfigFromJson(jsonString string) *RepeatConfig {
+	var d *RepeatConfig
+	json.Unmarshal([]byte(jsonString), &d)
+	return d
+}
+
+func AllMeetingsToJson(t *AllMeetings) string {
+	b, _ := json.Marshal(t)
+	return string(b)
+}
Index: mattermost-server-7.8.1/model/meeting_mng.go
===================================================================
--- mattermost-server-7.8.1/model/meeting_mng.go	(nonexistent)
+++ mattermost-server-7.8.1/model/meeting_mng.go	(revision 4485)
@@ -0,0 +1,271 @@
+//Copyright 2021 Ryobi Systems Co., Ltd. All Rights Reserved.
+
+package model
+
+import (
+	"encoding/json"
+	"io"
+)
+
+type MeetUser struct {
+	Id					string	`json:"id"`
+	UserName			string	`json:"user_name"`
+	Email				string	`json:"email"`
+	NickName			string	`json:"nick_name"`
+	FirstName			string	`json:"first_name"`
+	LastName			string	`json:"last_name"`
+}
+type MeetingMng struct {
+	MeetingItemId		string	`json:"meeting_item_id"`
+	ItemValid			bool	`json:"item_valid"`
+	MeetingName			string	`json:"meeting_name"`
+	MeetingId			string	`json:"meeting_id"`
+	StartAt				int64	`json:"start_at"`
+	EndAt				int64	`json:"end_at"`
+	TimeZone			string	`json:"time_zone"`
+	HostId				string	`json:"host_id"`
+	HostName			string	`json:"host_name"`
+	CreateAt			int64	`json:"create_at"`
+	IsRepeat			bool	`json:"is_repeat"`
+	RepeatConfig		string	`json:"repeat_config"`
+	RepeatEndDate		int64	`json:"repeat_end_date"`
+	ICalUID				string	`json:"ical_uid"`
+}
+type MeetingMngUserCount struct {
+	MeetingItemId		string	`json:"meeting_item_id"`
+	ItemValid			bool	`json:"item_valid"`
+	MeetingName			string	`json:"meeting_name"`
+	MeetingId			string	`json:"meeting_id"`
+	StartAt				int64	`json:"start_at"`
+	EndAt				int64	`json:"end_at"`
+	TimeZone			string	`json:"time_zone"`
+	HostId				string	`json:"host_id"`
+	HostName			string	`json:"host_name"`
+	CreateAt			int64	`json:"create_at"`
+	IsRepeat			bool	`json:"is_repeat"`
+	RepeatConfig		string	`json:"repeat_config"`
+	RepeatEndDate		int64	`json:"repeat_end_date"`
+	UserName			string	`json:"user_name"`
+	FirstName			string	`json:"first_name"`
+	LastName			string	`json:"last_name"`
+	UserCount			string	`json:"user_count"`
+	MeetingStartTime	int64	`json:"meeting_start_time"`
+	SumMemberCount		int		`json:"sum_member_count"`
+	UserMail			string	`json:"user_mail"`
+	MeetingEndTime		int64	`json:"meeting_end_time"`
+}
+
+type MeetingMngUser struct {
+	ItemId				string	`json:"item_id"`
+	ItemValid			bool	`json:"item_valid"`
+	MeetingItemId		string	`json:"meeting_item_id"`
+	UserId				string	`json:"user_id"`
+	UserMail			string	`json:"user_mail"`
+	UserName			string	`json:"user_name"`
+	NickName			string	`json:"nick_name"`
+	FirstName			string	`json:"first_name"`
+	LastName			string	`json:"last_name"`
+	UserType			string	`json:"user_type"`
+}
+type MeetingsMeetingEnd struct {
+	MeetingItemId		string	`json:"meeting_item_id"`
+	ItemValid			bool	`json:"item_valid"`
+	MeetingName			string	`json:"meeting_name"`
+	MeetingId			string	`json:"meeting_id"`
+	StartAt				int64	`json:"start_at"`
+	EndAt				int64	`json:"end_at"`
+	TimeZone			string	`json:"time_zone"`
+	HostId				string	`json:"host_id"`
+	HostName			string	`json:"host_name"`
+	CreateAt			int64	`json:"create_at"`
+	IsRepeat			bool	`json:"is_repeat"`
+	RepeatConfig		string	`json:"repeat_config"`
+	RepeatEndDate		int64	`json:"repeat_end_date"`
+	ICalUID				string	`json:"ical_uid"`
+	MeetingStartTime	int64	`json:"meeting_start_time"`
+	SumMemberCount		int		`json:"sum_member_count"`
+	UserMail			string	`json:"user_mail"`
+	MeetingEndTime		int64	`json:"meeting_end_time"`
+}
+
+type MeetingsEnd struct {
+	Id                       int	`json:"id"`
+	MeetingItemId            string	`json:"meeting_item_id"`
+	MeetingStartTime         int64	`json:"meeting_start_time"`
+	SumMemberCount           int	`json:"sum_member_count"`
+	UserMail                 string	`json:"user_mail"`
+	MeetingEndTime           int64	`json:"meeting_end_time"`
+}
+
+type MeetingEndUsers struct {
+	Id                       int	`json:"id"`
+	MeetingItemId            string	`json:"meeting_item_id"`
+	MeetingStartTime         int64	`json:"meeting_start_time"`
+	UserMail                 string	`json:"user_mail"`
+	Owner                    bool   `json:"owner"`
+	RemoteIp                 string	`json:"Remote_ip"`
+	LocalIp                  string	`json:"local_ip"`
+	StartTime                int64	`json:"start_time"`
+	EndTime                  int64	`json:"end_time"`
+}
+
+type MeetingMngFromJson struct {
+	StartDate		string	`json:"start_date"`
+	EndDate			string	`json:"end_date"`
+	MeetingName		string	`json:"meeting_name"`
+	SortName		string	`json:"sort_name"`
+	// Users				[]*MeetingUserFromJson	`json:"users"`
+}
+
+type MeetingMngToJson struct {
+	MeetingItemId		string	`json:"meeting_item_id"`
+	MeetingName			string	`json:"meeting_name"`
+	Creater				string	`json:"creater"`
+	StartAt				string	`json:"start_at"`
+	EndAt				string	`json:"end_at"`
+	StartTime			string	`json:"start_time"`
+	EndTime				string	`json:"end_time"`
+	MeetingCount		string	`json:"meeting_count"`
+	MeetMeetingCount	string	`json:"meet_meeting_count"`
+	UserCount			string	`json:"user_count"`
+	MeetUserCount		string	`json:"meet_user_count"`
+	MeetingTimes		string	`json:"meeting_times"`
+	MeetMeetingTimes	string	`json:"meet_meeting_times"`
+	TimeZone			string	`json:"time_zone"`
+	IsRepeat			bool	`json:"is_repeat"`
+	RepeatType			string	`json:"repeat_type"`
+	RepeatTimes			int		`json:"repeat_times"`
+	RepeatTimesType		string	`json:"repeat_times_type"`
+	RepeatWeekdays		[]int	`json:"repeat_weekdays"`
+	RepeatDays			[]int	`json:"repeat_days"`
+	RepeatWeekTimes		int		`json:"repeat_week_times"`
+	RepeatWeekday		int		`json:"repeat_weekday"`
+	RepeatEndType		string	`json:"repeat_end_type"`
+	RepeatEndValue		string	`json:"repeat_end_value"`
+	RepeatEndDate		string	`json:"repeat_end_date"`
+	IsProgressMeeting   bool    `json:"is_progress_meeting"`
+}
+
+type MeetingMngDetailToJson struct {
+	MeetingItemId		string	`json:"meeting_item_id"`
+	MeetingName			string	`json:"meeting_name"`
+	Creater				string	`json:"creater"`
+	StartAt				string	`json:"start_at"`
+	EndAt				string	`json:"end_at"`
+	StartTime			string	`json:"start_time"`
+	EndTime				string	`json:"end_time"`
+	TimeZone			string	`json:"time_zone"`
+	Users				[]*MeetingMngUserToJson	`json:"users"`
+	UserList			[]string	`json:"user_list"`
+	IsRepeat			bool	`json:"is_repeat"`
+	RepeatType			string	`json:"repeat_type"`
+	RepeatTimes			int	`json:"repeat_times"`
+	RepeatTimesType		string	`json:"repeat_times_type"`
+	RepeatWeekdays		[]int	`json:"repeat_weekdays"`
+	RepeatDays			[]int	`json:"repeat_days"`
+	RepeatWeekTimes		int	`json:"repeat_week_times"`
+	RepeatWeekday		int	`json:"repeat_weekday"`
+	RepeatEndType		string	`json:"repeat_end_type"`
+	RepeatEndValue		string	`json:"repeat_end_value"`
+	RepeatEndDate		string	`json:"repeat_end_date"`
+}
+
+type MeetingMngUserToJson struct {
+	ItemId				string	`json:"item_id"`
+	ItemValid			bool	`json:"item_valid"`
+	MeetingItemId		string	`json:"meeting_item_id"`
+	MeetingStartTime int64 `json:"meeting_start_time"`
+	UserId				string	`json:"user_id"`
+	UserName			string	`json:"user_name"`
+	FirstName			string	`json:"first_name"`
+	LastName			string	`json:"last_name"`
+	UserMail			string	`json:"user_mail"`
+	Owner				string	`json:"owner"`
+	StartTime			string	`json:"start_time"`
+	EndTime				string	`json:"end_time"`
+	RemoteIp			string	`json:"remote_ip"`
+	LocalIp				string	`json:"local_ip"`
+}
+
+type MeetingMngRepeatConfig struct {
+	RepeatType						string	`json:"repeat_type"`
+	RepeatFrequencyTimes			int	`json:"repeat_frequency_times"`
+	RepeatFrequencyTimesType		string	`json:"repeat_frequency_times_type"`
+	RepeatFrequencyWeekdays			[]int	`json:"repeat_frequency_weekdays"`
+	RepeatFrequencyDays				[]int	`json:"repeat_frequency_days"`
+	RepeatFrequencyWeekTimes		int	`json:"repeat_frequency_week_times"`
+	RepeatFrequencyWeekday			int	`json:"repeat_frequency_weekday"`
+	EndType							string	`json:"end_type"`
+	EndValue						int64	`json:"end_value"`
+}
+
+type MeetingMngDeleteFromJson struct {
+	MeetingItemIds		[]string	`json:"meeting_item_ids"`
+	SendMailFlg			bool	`json:"send_mail_flg"`
+	// Users				[]*MeetingUserFromJson	`json:"users"`
+}
+
+type MeetingMngUserFromJson struct {
+	UserId				string	`json:"user_id"`
+	UserName			string	`json:"user_name"`
+	UserMail			string	`json:"mail"`
+	SendMailMode		int		`json:"send_mail_mode"`
+	UserType			string	`json:"user_type"`
+}
+
+type MeetingMngUserRedis struct {
+	MeetingStartTime	string	`json:"meeting_start_time"`
+	UserMail			string	`json:"user_mail"`
+	Owner				string	`json:"owner"`
+	RemoteIp			string	`json:"remote_ip"`
+	LocalIp				string	`json:"local_ip"`
+	StartTime			string	`json:"start_time"`
+	EndTime				string	`json:"end_time"`
+}
+
+type ResponseMeetingList struct {
+	Status				string	`json:"status"`
+	Type				string	`json:"type"`
+	Message				string	`json:"message"`
+	MeetingsData		[]*MeetingMngToJson	`json:"meetings_data"`
+}
+
+type ResponseMeetingDetail struct {
+	Status				string	`json:"status"`
+	Type				string	`json:"type"`
+	Message				string	`json:"message"`
+	MeetingData		*MeetingMngDetailToJson	`json:"meeting_data"`
+}
+
+func MeetingMngListToJson(t ResponseMeetingList) string {
+	b, _ := json.Marshal(t)
+	return string(b)
+}
+
+func MeetingMngInfoToJson(t *MeetingMngToJson) string {
+	b, _ := json.Marshal(t)
+	return string(b)
+}
+func MeetingMngDetailInfoToJson(t ResponseMeetingDetail) string {
+	b, _ := json.Marshal(t)
+	return string(b)
+}
+
+func MeetingMngDataFromJson(data io.Reader) *MeetingMngFromJson {
+	var meetingData *MeetingMngFromJson
+	json.NewDecoder(data).Decode(&meetingData)
+	return meetingData
+}
+
+func MeetingMngDeleteDataFromJson(data io.Reader) *MeetingMngDeleteFromJson {
+	var meetingData *MeetingMngDeleteFromJson
+	json.NewDecoder(data).Decode(&meetingData)
+	return meetingData
+}
+
+func MeetingMngRepeatFromString(jsonStr string) *MeetingMngRepeatConfig {
+	var meetingData *MeetingMngRepeatConfig
+	json.Unmarshal([]byte(jsonStr), &meetingData)
+	return meetingData
+}
+
Index: mattermost-server-7.8.1/model/meeting_status.go
===================================================================
--- mattermost-server-7.8.1/model/meeting_status.go	(nonexistent)
+++ mattermost-server-7.8.1/model/meeting_status.go	(revision 4485)
@@ -0,0 +1,166 @@
+//Copyright 2021 Ryobi Systems Co., Ltd. All Rights Reserved.
+
+package model
+
+import (
+	"encoding/json"
+	"io"
+)
+
+type MeetingStatusToJson struct {
+	MeetingId			string	`json:"meeting_id"`
+	MeetingName			string	`json:"meeting_name"`
+	Creater				string	`json:"creater"`
+	MeetUserCount		int	    `json:"meet_user_count"`
+}
+
+type MeetingEndToJson struct {
+	MeetingId			string	`json:"meeting_id"`
+	MeetingName			string	`json:"meeting_name"`
+	Creater				string	`json:"creater"`
+	StartTime			string	`json:"start_time"`
+	EndTime				string	`json:"end_time"`
+	MeetUserCount		int	    `json:"meet_user_count"`
+}
+
+type MeetingEndFromJson struct {
+	StartDate		string	`json:"start_date"`
+	EndDate			string	`json:"end_date"`
+}
+
+type MeetUsers struct {
+	Id					string	`json:"id"`
+	UserName			string	`json:"user_name"`
+	Email				string	`json:"email"`
+	NickName			string	`json:"nick_name"`
+	FirstName			string	`json:"first_name"`
+	LastName			string	`json:"last_name"`
+}
+type MeetingStatus struct {
+	MeetingItemId		string	`json:"meeting_item_id"`
+	ItemValid			bool	`json:"item_valid"`
+	MeetingName			string	`json:"meeting_name"`
+	MeetingId			string	`json:"meeting_id"`
+	StartAt				int64	`json:"start_at"`
+	EndAt				int64	`json:"end_at"`
+	TimeZone			string	`json:"time_zone"`
+	HostId				string	`json:"host_id"`
+	HostName			string	`json:"host_name"`
+	CreateAt			int64	`json:"create_at"`
+	IsRepeat			bool	`json:"is_repeat"`
+	RepeatConfig		string	`json:"repeat_config"`
+	RepeatEndDate		int64	`json:"repeat_end_date"`
+}
+type MeetingStatusUserCount struct {
+	MeetingItemId		string	`json:"meeting_item_id"`
+	ItemValid			bool	`json:"item_valid"`
+	MeetingName			string	`json:"meeting_name"`
+	MeetingId			string	`json:"meeting_id"`
+	StartAt				int64	`json:"start_at"`
+	EndAt				int64	`json:"end_at"`
+	TimeZone			string	`json:"time_zone"`
+	HostId				string	`json:"host_id"`
+	HostName			string	`json:"host_name"`
+	CreateAt			int64	`json:"create_at"`
+	IsRepeat			bool	`json:"is_repeat"`
+	RepeatConfig		string	`json:"repeat_config"`
+	RepeatEndDate		int64	`json:"repeat_end_date"`
+	Username			string	`json:"user_name"`
+	FirstName			string	`json:"first_name"`
+	LastName			string	`json:"last_name"`
+	UserCount			string	`json:"user_count"`
+}
+
+type MeetingStatusUser struct {
+	ItemId				string	`json:"item_id"`
+	ItemValid			bool	`json:"item_valid"`
+	MeetingItemId		string	`json:"meeting_item_id"`
+	UserId				string	`json:"user_id"`
+	UserMail			string	`json:"user_mail"`
+	UserName			string	`json:"user_name"`
+	NickName			string	`json:"nick_name"`
+	FirstName			string	`json:"first_name"`
+	LastName			string	`json:"last_name"`
+}
+
+type MeetingStatusFromJson struct {
+	StartDate		string	`json:"start_date"`
+	EndDate			string	`json:"end_date"`
+	MeetingName		string	`json:"meeting_name"`
+	SortName		string	`json:"sort_name"`
+	// Users				[]*MeetingUserFromJson	`json:"users"`
+}
+
+type MeetingStatusDetailToJson struct {
+	MeetingItemId		string	`json:"meeting_item_id"`
+	MeetingName			string	`json:"meeting_name"`
+	Creater				string	`json:"creater"`
+	StartAt				string	`json:"start_at"`
+	EndAt				string	`json:"end_at"`
+	StartTime			string	`json:"start_time"`
+	EndTime				string	`json:"end_time"`
+	TimeZone			string	`json:"time_zone"`
+	Users				[]*MeetingStatusUserToJson	`json:"users"`
+	UserList			[]string	`json:"user_list"`
+	IsRepeat			bool	`json:"is_repeat"`
+	RepeatType			string	`json:"repeat_type"`
+	RepeatTimes			int	`json:"repeat_times"`
+	RepeatTimesType		string	`json:"repeat_times_type"`
+	RepeatWeekdays		[]int	`json:"repeat_weekdays"`
+	RepeatDays			[]int	`json:"repeat_days"`
+	RepeatWeekTimes		int	`json:"repeat_week_times"`
+	RepeatWeekday		int	`json:"repeat_weekday"`
+	RepeatEndType		string	`json:"repeat_end_type"`
+	RepeatEndDate		string	`json:"repeat_end_date"`
+}
+
+type MeetingStatusUserToJson struct {
+	ItemId				string	`json:"item_id"`
+	ItemValid			bool	`json:"item_valid"`
+	MeetingItemId		string	`json:"meeting_item_id"`
+	UserId				string	`json:"user_id"`
+	UserName			string	`json:"user_name"`
+	UserMail			string	`json:"user_mail"`
+	Creater				string	`json:"creater"`
+	StartTime			string	`json:"start_time"`
+	EndTime				string	`json:"end_time"`
+	UserIp				string	`json:"ip"`
+	UserIp2				string	`json:"ip2"`
+}
+
+type MeetingStatusRepeatConfig struct {
+	RepeatType						string	`json:"repeat_type"`
+	RepeatFrequencyTimes			int	`json:"repeat_frequency_times"`
+	RepeatFrequencyTimesType		string	`json:"repeat_frequency_times_type"`
+	RepeatFrequencyWeekdays			[]int	`json:"repeat_frequency_weekdays"`
+	RepeatFrequencyDays				[]int	`json:"repeat_frequency_days"`
+	RepeatFrequencyWeekTimes		int	`json:"repeat_frequency_week_times"`
+	RepeatFrequencyWeekday			int	`json:"repeat_frequency_weekday"`
+	EndType							string	`json:"end_type"`
+	EndValue						int64	`json:"end_value"`
+}
+
+type statusMeetingsEnd struct {
+	Id                       int	`json:"id"`
+	MeetingItemId            string	`json:"meeting_item_id"`
+	MeetingStartTime         int64	`json:"meeting_start_time"`
+	SumMemberCount           int	`json:"sum_member_count"`
+	UserMail                 string	`json:"user_mail"`
+	MeetingEndTime           int64	`json:"meeting_end_time"`
+}
+
+func MeetingStatusListToJson(t []*MeetingStatusToJson) string {
+	b, _ := json.Marshal(t)
+	return string(b)
+}
+
+func MeetingEndListToJson(t []*MeetingEndToJson) string {
+	b, _ := json.Marshal(t)
+	return string(b)
+}
+
+func MeetingEndDataFromJson(data io.Reader) *MeetingEndFromJson {
+	var meetingData *MeetingEndFromJson
+	json.NewDecoder(data).Decode(&meetingData)
+	return meetingData
+}
\ No newline at end of file
Index: mattermost-server-7.8.1/model/oauthproviders/gitlab/gitlab.go
===================================================================
--- mattermost-server-7.8.1/model/oauthproviders/gitlab/gitlab.go	(revision 4484)
+++ mattermost-server-7.8.1/model/oauthproviders/gitlab/gitlab.go	(revision 4485)
@@ -7,7 +7,6 @@
 	"encoding/json"
 	"errors"
 	"io"
-	"strconv"
 	"strings"
 
 	"github.com/mattermost/mattermost-server/v6/einterfaces"
@@ -18,7 +17,7 @@
 }
 
 type GitLabUser struct {
-	Id       int64  `json:"id"`
+	Id       string `json:"id"`
 	Username string `json:"username"`
 	Login    string `json:"login"`
 	Email    string `json:"email"`
@@ -67,7 +66,7 @@
 }
 
 func (glu *GitLabUser) IsValid() error {
-	if glu.Id == 0 {
+	if len(glu.Id) == 0 || glu.Id == "0" {
 		return errors.New("user id can't be 0")
 	}
 
@@ -79,7 +78,7 @@
 }
 
 func (glu *GitLabUser) getAuthData() string {
-	return strconv.FormatInt(glu.Id, 10)
+	return glu.Id
 }
 
 func (m *GitLabProvider) GetUserFromJSON(data io.Reader, tokenUser *model.User) (*model.User, error) {
Index: mattermost-server-7.8.1/model/poll_fields.go
===================================================================
--- mattermost-server-7.8.1/model/poll_fields.go	(nonexistent)
+++ mattermost-server-7.8.1/model/poll_fields.go	(revision 4485)
@@ -0,0 +1,9 @@
+package model
+
+type PollFields struct {
+	Id     int    `json:"id"`
+	PostId string `json:"post_Id"`
+	Voter  string `json:"voter"`
+	Answer string `json:"answer"`
+	UserId string `json:"user_Id"`
+}
Index: mattermost-server-7.8.1/model/session.go
===================================================================
--- mattermost-server-7.8.1/model/session.go	(revision 4484)
+++ mattermost-server-7.8.1/model/session.go	(revision 4485)
@@ -32,6 +32,7 @@
 	SessionPropIsGuest                = "is_guest"
 	SessionActivityTimeout            = 1000 * 60 * 5  // 5 minutes
 	SessionUserAccessTokenExpiryHours = 100 * 365 * 24 // 100 years
+	SESSION_USER_STATE                = "sessionState"	
 )
 
 //msgp:tuple StringMap
Index: mattermost-server-7.8.1/model/slack_attachment.go
===================================================================
--- mattermost-server-7.8.1/model/slack_attachment.go	(revision 4484)
+++ mattermost-server-7.8.1/model/slack_attachment.go	(revision 4485)
@@ -118,6 +118,7 @@
 	Title string              `json:"title"`
 	Value any                 `json:"value"`
 	Short SlackCompatibleBool `json:"short"`
+	WebValue string           `json:"webValue"`
 }
 
 func (s *SlackAttachmentField) Equals(input *SlackAttachmentField) bool {
Index: mattermost-server-7.8.1/model/status.go
===================================================================
--- mattermost-server-7.8.1/model/status.go	(revision 4484)
+++ mattermost-server-7.8.1/model/status.go	(revision 4485)
@@ -5,6 +5,7 @@
 
 import (
 	"encoding/json"
+	"io"
 )
 
 const (
@@ -13,6 +14,7 @@
 	StatusAway           = "away"
 	StatusDnd            = "dnd"
 	StatusOnline         = "online"
+	STATUS_MEETING       = "meeting"
 	StatusCacheSize      = SessionCacheSize
 	StatusChannelTimeout = 20000  // 20 seconds
 	StatusMinUpdateTime  = 120000 // 2 minutes
@@ -28,6 +30,14 @@
 	PrevStatus     string `json:"-"`
 }
 
+type SpecifiedStatus struct {
+	UserId         string `json:"user_id"`
+	Status         string `json:"status"`
+	Manual         bool   `json:"manual"`
+	LastActivityAt int64  `json:"last_activity_at"`
+	DNDEndTime     int64  `json:"dnd_end_time"`
+}
+
 func (s *Status) ToJSON() ([]byte, error) {
 	sCopy := *s
 	sCopy.ActiveChannel = ""
@@ -66,3 +76,8 @@
 	}
 	return interfaceMap
 }
+func SpecifiedStatusFromJson(data io.Reader) *SpecifiedStatus {
+	var o *SpecifiedStatus
+	json.NewDecoder(data).Decode(&o)
+	return o
+}
Index: mattermost-server-7.8.1/model/team.go
===================================================================
--- mattermost-server-7.8.1/model/team.go	(revision 4484)
+++ mattermost-server-7.8.1/model/team.go	(revision 4485)
@@ -60,6 +60,14 @@
 	}
 }
 
+/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 START */
+type DefaultTeam struct {
+	Id                 string  `json:"id"`
+	CreateAt           int64   `json:"create_at"`
+	UpdateAt           int64   `json:"update_at"`
+}
+/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 END */
+
 type TeamPatch struct {
 	DisplayName         *string `json:"display_name"`
 	Description         *string `json:"description"`
Index: mattermost-server-7.8.1/model/user.go
===================================================================
--- mattermost-server-7.8.1/model/user.go	(revision 4484)
+++ mattermost-server-7.8.1/model/user.go	(revision 4485)
@@ -26,6 +26,7 @@
 	UserNotifyAll                  = "all"
 	UserNotifyHere                 = "here"
 	UserNotifyMention              = "mention"
+	CONTINUE_SHOW                  = "continue_show"
 	UserNotifyNone                 = "none"
 	DesktopNotifyProp              = "desktop"
 	DesktopSoundNotifyProp         = "desktop_sound"
@@ -214,6 +215,11 @@
 	Channels []string
 }
 
+// ToJson convert a User to a json string
+func (u *User) ToJson() string {
+	b, _ := json.Marshal(u)
+	return string(b)
+}
 func (r *ViewUsersRestrictions) Hash() string {
 	if r == nil {
 		return ""
@@ -549,6 +555,7 @@
 	u.NotifyProps[EmailNotifyProp] = "true"
 	u.NotifyProps[PushNotifyProp] = UserNotifyMention
 	u.NotifyProps[DesktopNotifyProp] = UserNotifyMention
+	u.NotifyProps[CONTINUE_SHOW] = "true"
 	u.NotifyProps[DesktopSoundNotifyProp] = "true"
 	u.NotifyProps[MentionKeysNotifyProp] = ""
 	u.NotifyProps[ChannelMentionsNotifyProp] = "true"
@@ -743,18 +750,25 @@
 	u.Props[UserPropsKeyCustomStatus] = ""
 }
 
+/* Ryobi Systems CloudOffice Meeting Mod メール本文にIDを姓名に変更 20210609 START */
 func (u *User) GetFullName() string {
 	if u.FirstName != "" && u.LastName != "" {
-		return u.FirstName + " " + u.LastName
+		if u.Locale == "ja" {
+			return u.LastName + " " + u.FirstName
+		} else {
+			return u.FirstName + " " + u.LastName
+		}
 	} else if u.FirstName != "" {
 		return u.FirstName
 	} else if u.LastName != "" {
 		return u.LastName
 	} else {
-		return ""
+		return u.Username
 	}
 }
 
+/* Ryobi Systems CloudOffice Meeting Mod メール本文にIDを姓名に変更 20210609 END */
+
 func (u *User) getDisplayName(baseName, nameFormat string) string {
 	displayName := baseName
 
Index: mattermost-server-7.8.1/model/user.go.bak
===================================================================
--- mattermost-server-7.8.1/model/user.go.bak	(nonexistent)
+++ mattermost-server-7.8.1/model/user.go.bak	(revision 4485)
@@ -0,0 +1,1011 @@
+// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
+// See LICENSE.txt for license information.
+
+package model
+
+import (
+	"crypto/sha256"
+	"encoding/json"
+	"fmt"
+	"io"
+	"io/ioutil"
+	"net/http"
+	"regexp"
+	"sort"
+	"strings"
+	"unicode/utf8"
+
+	"golang.org/x/crypto/bcrypt"
+	"golang.org/x/text/language"
+
+	"github.com/mattermost/mattermost-server/v6/services/timezones"
+	"github.com/mattermost/mattermost-server/v6/shared/mlog"
+)
+
+const (
+	ME                                 = "me"
+	USER_NOTIFY_ALL                    = "all"
+	USER_NOTIFY_HERE                   = "here"
+	USER_NOTIFY_MENTION                = "mention"
+	USER_NOTIFY_NONE                   = "none"
+	DESKTOP_NOTIFY_PROP                = "desktop"
+	CONTINUE_SHOW                      = "continue_show"
+	DESKTOP_SOUND_NOTIFY_PROP          = "desktop_sound"
+	MARK_UNREAD_NOTIFY_PROP            = "mark_unread"
+	PUSH_NOTIFY_PROP                   = "push"
+	PUSH_STATUS_NOTIFY_PROP            = "push_status"
+	EMAIL_NOTIFY_PROP                  = "email"
+	CHANNEL_MENTIONS_NOTIFY_PROP       = "channel"
+	COMMENTS_NOTIFY_PROP               = "comments"
+	MENTION_KEYS_NOTIFY_PROP           = "mention_keys"
+	COMMENTS_NOTIFY_NEVER              = "never"
+	COMMENTS_NOTIFY_ROOT               = "root"
+	COMMENTS_NOTIFY_ANY                = "any"
+	FIRST_NAME_NOTIFY_PROP             = "first_name"
+	AUTO_RESPONDER_ACTIVE_NOTIFY_PROP  = "auto_responder_active"
+	AUTO_RESPONDER_MESSAGE_NOTIFY_PROP = "auto_responder_message"
+	FIRST_LOGIN			   ="first_login"
+
+	DEFAULT_LOCALE          = "en"
+	USER_AUTH_SERVICE_EMAIL = "email"
+
+	USER_EMAIL_MAX_LENGTH     = 128
+	USER_NICKNAME_MAX_RUNES   = 64
+	USER_POSITION_MAX_RUNES   = 128
+	USER_FIRST_NAME_MAX_RUNES = 64
+	USER_LAST_NAME_MAX_RUNES  = 64
+	USER_AUTH_DATA_MAX_LENGTH = 128
+	USER_NAME_MAX_LENGTH      = 64
+	USER_NAME_MIN_LENGTH      = 1
+	USER_PASSWORD_MAX_LENGTH  = 72
+	USER_LOCALE_MAX_LENGTH    = 5
+	USER_TIMEZONE_MAX_RUNES   = 256
+)
+
+//msgp:tuple User
+
+// User contains the details about the user.
+// This struct's serializer methods are auto-generated. If a new field is added/removed,
+// please run make gen-serialized.
+type User struct {
+	Id                     string    `json:"id"`
+	CreateAt               int64     `json:"create_at,omitempty"`
+	UpdateAt               int64     `json:"update_at,omitempty"`
+	DeleteAt               int64     `json:"delete_at"`
+	Username               string    `json:"username"`
+	Password               string    `json:"password,omitempty"`
+	AuthData               *string   `json:"auth_data,omitempty"`
+	AuthService            string    `json:"auth_service"`
+	Email                  string    `json:"email"`
+	EmailVerified          bool      `json:"email_verified,omitempty"`
+	Nickname               string    `json:"nickname"`
+	FirstName              string    `json:"first_name"`
+	LastName               string    `json:"last_name"`
+	Position               string    `json:"position"`
+	Roles                  string    `json:"roles"`
+	AllowMarketing         bool      `json:"allow_marketing,omitempty"`
+	Props                  StringMap `json:"props,omitempty"`
+	NotifyProps            StringMap `json:"notify_props,omitempty"`
+	LastPasswordUpdate     int64     `json:"last_password_update,omitempty"`
+	LastPictureUpdate      int64     `json:"last_picture_update,omitempty"`
+	FailedAttempts         int       `json:"failed_attempts,omitempty"`
+	Locale                 string    `json:"locale"`
+	Timezone               StringMap `json:"timezone"`
+	MfaActive              bool      `json:"mfa_active,omitempty"`
+	MfaSecret              string    `json:"mfa_secret,omitempty"`
+	RemoteId               *string   `json:"remote_id,omitempty"`
+	LastActivityAt         int64     `db:"-" json:"last_activity_at,omitempty"`
+	IsBot                  bool      `db:"-" json:"is_bot,omitempty"`
+	BotDescription         string    `db:"-" json:"bot_description,omitempty"`
+	BotLastIconUpdate      int64     `db:"-" json:"bot_last_icon_update,omitempty"`
+	TermsOfServiceId       string    `db:"-" json:"terms_of_service_id,omitempty"`
+	TermsOfServiceCreateAt int64     `db:"-" json:"terms_of_service_create_at,omitempty"`
+	DisableWelcomeEmail    bool      `db:"-" json:"disable_welcome_email"`
+}
+
+//msgp UserMap
+
+// UserMap is a map from a userId to a user object.
+// It is used to generate methods which can be used for fast serialization/de-serialization.
+type UserMap map[string]*User
+
+//msgp:ignore UserUpdate
+type UserUpdate struct {
+	Old *User
+	New *User
+}
+
+//msgp:ignore UserPatch
+type UserPatch struct {
+	Username    *string   `json:"username"`
+	Password    *string   `json:"password,omitempty"`
+	Nickname    *string   `json:"nickname"`
+	FirstName   *string   `json:"first_name"`
+	LastName    *string   `json:"last_name"`
+	Position    *string   `json:"position"`
+	Email       *string   `json:"email"`
+	Props       StringMap `json:"props,omitempty"`
+	NotifyProps StringMap `json:"notify_props,omitempty"`
+	Locale      *string   `json:"locale"`
+	Timezone    StringMap `json:"timezone"`
+	RemoteId    *string   `json:"remote_id"`
+}
+
+//msgp:ignore UserAuth
+type UserAuth struct {
+	Password    string  `json:"password,omitempty"` // DEPRECATED: It is not used.
+	AuthData    *string `json:"auth_data,omitempty"`
+	AuthService string  `json:"auth_service,omitempty"`
+}
+
+//msgp:ignore UserForIndexing
+type UserForIndexing struct {
+	Id          string   `json:"id"`
+	Username    string   `json:"username"`
+	Nickname    string   `json:"nickname"`
+	FirstName   string   `json:"first_name"`
+	LastName    string   `json:"last_name"`
+	Roles       string   `json:"roles"`
+	CreateAt    int64    `json:"create_at"`
+	DeleteAt    int64    `json:"delete_at"`
+	TeamsIds    []string `json:"team_id"`
+	ChannelsIds []string `json:"channel_id"`
+}
+
+//msgp:ignore ViewUsersRestrictions
+type ViewUsersRestrictions struct {
+	Teams    []string
+	Channels []string
+}
+
+func (r *ViewUsersRestrictions) Hash() string {
+	if r == nil {
+		return ""
+	}
+	ids := append(r.Teams, r.Channels...)
+	sort.Strings(ids)
+	hash := sha256.New()
+	hash.Write([]byte(strings.Join(ids, "")))
+	return fmt.Sprintf("%x", hash.Sum(nil))
+}
+
+//msgp:ignore UserSlice
+type UserSlice []*User
+
+func (u UserSlice) Usernames() []string {
+	usernames := []string{}
+	for _, user := range u {
+		usernames = append(usernames, user.Username)
+	}
+	sort.Strings(usernames)
+	return usernames
+}
+
+func (u UserSlice) IDs() []string {
+	ids := []string{}
+	for _, user := range u {
+		ids = append(ids, user.Id)
+	}
+	return ids
+}
+
+func (u UserSlice) FilterWithoutBots() UserSlice {
+	var matches []*User
+
+	for _, user := range u {
+		if !user.IsBot {
+			matches = append(matches, user)
+		}
+	}
+	return UserSlice(matches)
+}
+
+func (u UserSlice) FilterByActive(active bool) UserSlice {
+	var matches []*User
+
+	for _, user := range u {
+		if user.DeleteAt == 0 && active {
+			matches = append(matches, user)
+		} else if user.DeleteAt != 0 && !active {
+			matches = append(matches, user)
+		}
+	}
+	return UserSlice(matches)
+}
+
+func (u UserSlice) FilterByID(ids []string) UserSlice {
+	var matches []*User
+	for _, user := range u {
+		for _, id := range ids {
+			if id == user.Id {
+				matches = append(matches, user)
+			}
+		}
+	}
+	return UserSlice(matches)
+}
+
+func (u UserSlice) FilterWithoutID(ids []string) UserSlice {
+	var keep []*User
+	for _, user := range u {
+		present := false
+		for _, id := range ids {
+			if id == user.Id {
+				present = true
+			}
+		}
+		if !present {
+			keep = append(keep, user)
+		}
+	}
+	return UserSlice(keep)
+}
+
+func (u *User) DeepCopy() *User {
+	copyUser := *u
+	if u.AuthData != nil {
+		copyUser.AuthData = NewString(*u.AuthData)
+	}
+	if u.Props != nil {
+		copyUser.Props = CopyStringMap(u.Props)
+	}
+	if u.NotifyProps != nil {
+		copyUser.NotifyProps = CopyStringMap(u.NotifyProps)
+	}
+	if u.Timezone != nil {
+		copyUser.Timezone = CopyStringMap(u.Timezone)
+	}
+	return &copyUser
+}
+
+// IsValid validates the user and returns an error if it isn't configured
+// correctly.
+func (u *User) IsValid() *AppError {
+
+	if !IsValidId(u.Id) {
+		return InvalidUserError("id", "")
+	}
+
+	if u.CreateAt == 0 {
+		return InvalidUserError("create_at", u.Id)
+	}
+
+	if u.UpdateAt == 0 {
+		return InvalidUserError("update_at", u.Id)
+	}
+
+	if u.IsRemote() {
+		if !IsValidUsernameAllowRemote(u.Username) {
+			return InvalidUserError("username", u.Id)
+		}
+	} else {
+		if !IsValidUsername(u.Username) {
+			return InvalidUserError("username", u.Id)
+		}
+	}
+
+	if len(u.Email) > USER_EMAIL_MAX_LENGTH || u.Email == "" || !IsValidEmail(u.Email) {
+		return InvalidUserError("email", u.Id)
+	}
+
+	if utf8.RuneCountInString(u.Nickname) > USER_NICKNAME_MAX_RUNES {
+		return InvalidUserError("nickname", u.Id)
+	}
+
+	if utf8.RuneCountInString(u.Position) > USER_POSITION_MAX_RUNES {
+		return InvalidUserError("position", u.Id)
+	}
+
+	if utf8.RuneCountInString(u.FirstName) > USER_FIRST_NAME_MAX_RUNES {
+		return InvalidUserError("first_name", u.Id)
+	}
+
+	if utf8.RuneCountInString(u.LastName) > USER_LAST_NAME_MAX_RUNES {
+		return InvalidUserError("last_name", u.Id)
+	}
+
+	if u.AuthData != nil && len(*u.AuthData) > USER_AUTH_DATA_MAX_LENGTH {
+		return InvalidUserError("auth_data", u.Id)
+	}
+
+	if u.AuthData != nil && *u.AuthData != "" && u.AuthService == "" {
+		return InvalidUserError("auth_data_type", u.Id)
+	}
+
+	if u.Password != "" && u.AuthData != nil && *u.AuthData != "" {
+		return InvalidUserError("auth_data_pwd", u.Id)
+	}
+
+	if len(u.Password) > USER_PASSWORD_MAX_LENGTH {
+		return InvalidUserError("password_limit", u.Id)
+	}
+
+	if !IsValidLocale(u.Locale) {
+		return InvalidUserError("locale", u.Id)
+	}
+
+	if len(u.Timezone) > 0 {
+		if tzJSON, err := json.Marshal(u.Timezone); err != nil {
+			return NewAppError("User.IsValid", "model.user.is_valid.marshal.app_error", nil, err.Error(), http.StatusInternalServerError)
+		} else if utf8.RuneCount(tzJSON) > USER_TIMEZONE_MAX_RUNES {
+			return InvalidUserError("timezone_limit", u.Id)
+		}
+	}
+
+	return nil
+}
+
+func InvalidUserError(fieldName string, userId string) *AppError {
+	id := fmt.Sprintf("model.user.is_valid.%s.app_error", fieldName)
+	details := ""
+	if userId != "" {
+		details = "user_id=" + userId
+	}
+	return NewAppError("User.IsValid", id, nil, details, http.StatusBadRequest)
+}
+
+func NormalizeUsername(username string) string {
+	return strings.ToLower(username)
+}
+
+func NormalizeEmail(email string) string {
+	return strings.ToLower(email)
+}
+
+// PreSave will set the Id and Username if missing.  It will also fill
+// in the CreateAt, UpdateAt times.  It will also hash the password.  It should
+// be run before saving the user to the db.
+func (u *User) PreSave() {
+	if u.Id == "" {
+		u.Id = NewId()
+	}
+
+	if u.Username == "" {
+		u.Username = NewId()
+	}
+
+	if u.AuthData != nil && *u.AuthData == "" {
+		u.AuthData = nil
+	}
+
+	u.Username = SanitizeUnicode(u.Username)
+	u.FirstName = SanitizeUnicode(u.FirstName)
+	u.LastName = SanitizeUnicode(u.LastName)
+	u.Nickname = SanitizeUnicode(u.Nickname)
+
+	u.Username = NormalizeUsername(u.Username)
+	u.Email = NormalizeEmail(u.Email)
+
+	u.CreateAt = GetMillis()
+	u.UpdateAt = u.CreateAt
+
+	u.LastPasswordUpdate = u.CreateAt
+
+	u.MfaActive = false
+
+	if u.Locale == "" {
+		u.Locale = DEFAULT_LOCALE
+	}
+
+	if u.Props == nil {
+		u.Props = make(map[string]string)
+	}
+
+	if u.NotifyProps == nil || len(u.NotifyProps) == 0 {
+		u.SetDefaultNotifications()
+	}
+
+	if u.Timezone == nil {
+		u.Timezone = timezones.DefaultUserTimezone()
+	}
+
+	if u.Password != "" {
+		u.Password = HashPassword(u.Password)
+	}
+}
+
+// PreUpdate should be run before updating the user in the db.
+func (u *User) PreUpdate() {
+	u.Username = SanitizeUnicode(u.Username)
+	u.FirstName = SanitizeUnicode(u.FirstName)
+	u.LastName = SanitizeUnicode(u.LastName)
+	u.Nickname = SanitizeUnicode(u.Nickname)
+	u.BotDescription = SanitizeUnicode(u.BotDescription)
+
+	u.Username = NormalizeUsername(u.Username)
+	u.Email = NormalizeEmail(u.Email)
+	u.UpdateAt = GetMillis()
+
+	u.FirstName = SanitizeUnicode(u.FirstName)
+	u.LastName = SanitizeUnicode(u.LastName)
+	u.Nickname = SanitizeUnicode(u.Nickname)
+	u.BotDescription = SanitizeUnicode(u.BotDescription)
+
+	if u.AuthData != nil && *u.AuthData == "" {
+		u.AuthData = nil
+	}
+
+	if u.NotifyProps == nil || len(u.NotifyProps) == 0 {
+		u.SetDefaultNotifications()
+	} else if _, ok := u.NotifyProps[MENTION_KEYS_NOTIFY_PROP]; ok {
+		// Remove any blank mention keys
+		splitKeys := strings.Split(u.NotifyProps[MENTION_KEYS_NOTIFY_PROP], ",")
+		goodKeys := []string{}
+		for _, key := range splitKeys {
+			if key != "" {
+				goodKeys = append(goodKeys, strings.ToLower(key))
+			}
+		}
+		u.NotifyProps[MENTION_KEYS_NOTIFY_PROP] = strings.Join(goodKeys, ",")
+	}
+}
+
+func (u *User) SetDefaultNotifications() {
+	u.NotifyProps = make(map[string]string)
+	u.NotifyProps[EMAIL_NOTIFY_PROP] = "true"
+	u.NotifyProps[PUSH_NOTIFY_PROP] = USER_NOTIFY_MENTION
+	u.NotifyProps[DESKTOP_NOTIFY_PROP] = USER_NOTIFY_MENTION
+	u.NotifyProps[DESKTOP_SOUND_NOTIFY_PROP] = "true"
+	u.NotifyProps[CONTINUE_SHOW] ="true"
+	u.NotifyProps[MENTION_KEYS_NOTIFY_PROP] = ""
+	u.NotifyProps[CHANNEL_MENTIONS_NOTIFY_PROP] = "true"
+	u.NotifyProps[PUSH_STATUS_NOTIFY_PROP] = STATUS_AWAY
+	u.NotifyProps[COMMENTS_NOTIFY_PROP] = COMMENTS_NOTIFY_NEVER
+	u.NotifyProps[FIRST_NAME_NOTIFY_PROP] = "false"
+	u.NotifyProps[FIRST_LOGIN] = "true"
+}
+
+func (u *User) UpdateMentionKeysFromUsername(oldUsername string) {
+	nonUsernameKeys := []string{}
+	for _, key := range u.GetMentionKeys() {
+		if key != oldUsername && key != "@"+oldUsername {
+			nonUsernameKeys = append(nonUsernameKeys, key)
+		}
+	}
+
+	u.NotifyProps[MENTION_KEYS_NOTIFY_PROP] = ""
+	if len(nonUsernameKeys) > 0 {
+		u.NotifyProps[MENTION_KEYS_NOTIFY_PROP] += "," + strings.Join(nonUsernameKeys, ",")
+	}
+}
+
+func (u *User) GetMentionKeys() []string {
+	var keys []string
+
+	for _, key := range strings.Split(u.NotifyProps[MENTION_KEYS_NOTIFY_PROP], ",") {
+		trimmedKey := strings.TrimSpace(key)
+
+		if trimmedKey == "" {
+			continue
+		}
+
+		keys = append(keys, trimmedKey)
+	}
+
+	return keys
+}
+
+func (u *User) Patch(patch *UserPatch) {
+	if patch.Username != nil {
+		u.Username = *patch.Username
+	}
+
+	if patch.Nickname != nil {
+		u.Nickname = *patch.Nickname
+	}
+
+	if patch.FirstName != nil {
+		u.FirstName = *patch.FirstName
+	}
+
+	if patch.LastName != nil {
+		u.LastName = *patch.LastName
+	}
+
+	if patch.Position != nil {
+		u.Position = *patch.Position
+	}
+
+	if patch.Email != nil {
+		u.Email = *patch.Email
+	}
+
+	if patch.Props != nil {
+		u.Props = patch.Props
+	}
+
+	if patch.NotifyProps != nil {
+		u.NotifyProps = patch.NotifyProps
+	}
+
+	if patch.Locale != nil {
+		u.Locale = *patch.Locale
+	}
+
+	if patch.Timezone != nil {
+		u.Timezone = patch.Timezone
+	}
+
+	if patch.RemoteId != nil {
+		u.RemoteId = patch.RemoteId
+	}
+}
+
+// ToJson convert a User to a json string
+func (u *User) ToJson() string {
+	b, _ := json.Marshal(u)
+	return string(b)
+}
+
+func (u *UserPatch) ToJson() string {
+	b, _ := json.Marshal(u)
+	return string(b)
+}
+
+func (u *UserAuth) ToJson() string {
+	b, _ := json.Marshal(u)
+	return string(b)
+}
+
+// Generate a valid strong etag so the browser can cache the results
+func (u *User) Etag(showFullName, showEmail bool) string {
+	return Etag(u.Id, u.UpdateAt, u.TermsOfServiceId, u.TermsOfServiceCreateAt, showFullName, showEmail, u.BotLastIconUpdate)
+}
+
+// Remove any private data from the user object
+func (u *User) Sanitize(options map[string]bool) {
+	u.Password = ""
+	u.AuthData = NewString("")
+	u.MfaSecret = ""
+
+	if len(options) != 0 && !options["email"] {
+		u.Email = ""
+	}
+	if len(options) != 0 && !options["fullname"] {
+		u.FirstName = ""
+		u.LastName = ""
+	}
+	if len(options) != 0 && !options["passwordupdate"] {
+		u.LastPasswordUpdate = 0
+	}
+	if len(options) != 0 && !options["authservice"] {
+		u.AuthService = ""
+	}
+}
+
+// Remove any input data from the user object that is not user controlled
+func (u *User) SanitizeInput(isAdmin bool) {
+	if !isAdmin {
+		u.AuthData = NewString("")
+		u.AuthService = ""
+		u.EmailVerified = false
+	}
+	u.LastPasswordUpdate = 0
+	u.LastPictureUpdate = 0
+	u.FailedAttempts = 0
+	u.MfaActive = false
+	u.MfaSecret = ""
+}
+
+func (u *User) ClearNonProfileFields() {
+	u.Password = ""
+	u.AuthData = NewString("")
+	u.MfaSecret = ""
+	u.EmailVerified = false
+	u.AllowMarketing = false
+	u.NotifyProps = StringMap{}
+	u.LastPasswordUpdate = 0
+	u.FailedAttempts = 0
+}
+
+func (u *User) SanitizeProfile(options map[string]bool) {
+	u.ClearNonProfileFields()
+
+	u.Sanitize(options)
+}
+
+func (u *User) MakeNonNil() {
+	if u.Props == nil {
+		u.Props = make(map[string]string)
+	}
+
+	if u.NotifyProps == nil {
+		u.NotifyProps = make(map[string]string)
+	}
+}
+
+func (u *User) AddNotifyProp(key string, value string) {
+	u.MakeNonNil()
+
+	u.NotifyProps[key] = value
+}
+
+func (u *User) SetCustomStatus(cs *CustomStatus) {
+	u.MakeNonNil()
+	u.Props[UserPropsKeyCustomStatus] = cs.ToJson()
+}
+
+func (u *User) ClearCustomStatus() {
+	u.MakeNonNil()
+	u.Props[UserPropsKeyCustomStatus] = ""
+}
+
+/* Ryobi Systems CloudOffice Meeting Mod メール本文にIDを姓名に変更 20210609 START */
+func (u *User) GetFullName() string {
+	if u.FirstName != "" && u.LastName != "" {
+		if u.Locale == "ja" {
+			return u.LastName + " " + u.FirstName
+		} else {
+			return u.FirstName + " " + u.LastName
+		}
+	} else if u.FirstName != "" {
+		return u.FirstName
+	} else if u.LastName != "" {
+		return u.LastName
+	} else {
+		return u.Username
+	}
+}
+/* Ryobi Systems CloudOffice Meeting Mod メール本文にIDを姓名に変更 20210609 END */
+
+func (u *User) getDisplayName(baseName, nameFormat string) string {
+	displayName := baseName
+
+	if nameFormat == SHOW_NICKNAME_FULLNAME {
+		if u.Nickname != "" {
+			displayName = u.Nickname
+		} else if fullName := u.GetFullName(); fullName != "" {
+			displayName = fullName
+		}
+	} else if nameFormat == SHOW_FULLNAME {
+		if fullName := u.GetFullName(); fullName != "" {
+			displayName = fullName
+		}
+	}
+
+	return displayName
+}
+
+func (u *User) GetDisplayName(nameFormat string) string {
+	displayName := u.Username
+
+	return u.getDisplayName(displayName, nameFormat)
+}
+
+func (u *User) GetDisplayNameWithPrefix(nameFormat, prefix string) string {
+	displayName := prefix + u.Username
+
+	return u.getDisplayName(displayName, nameFormat)
+}
+
+func (u *User) GetRoles() []string {
+	return strings.Fields(u.Roles)
+}
+
+func (u *User) GetRawRoles() string {
+	return u.Roles
+}
+
+func IsValidUserRoles(userRoles string) bool {
+
+	roles := strings.Fields(userRoles)
+
+	for _, r := range roles {
+		if !IsValidRoleName(r) {
+			return false
+		}
+	}
+
+	// Exclude just the system_admin role explicitly to prevent mistakes
+	if len(roles) == 1 && roles[0] == "system_admin" {
+		return false
+	}
+
+	return true
+}
+
+// Make sure you acually want to use this function. In context.go there are functions to check permissions
+// This function should not be used to check permissions.
+func (u *User) IsGuest() bool {
+	return IsInRole(u.Roles, SYSTEM_GUEST_ROLE_ID)
+}
+
+func (u *User) IsSystemAdmin() bool {
+	return IsInRole(u.Roles, SYSTEM_ADMIN_ROLE_ID)
+}
+
+// Make sure you acually want to use this function. In context.go there are functions to check permissions
+// This function should not be used to check permissions.
+func (u *User) IsInRole(inRole string) bool {
+	return IsInRole(u.Roles, inRole)
+}
+
+// Make sure you acually want to use this function. In context.go there are functions to check permissions
+// This function should not be used to check permissions.
+func IsInRole(userRoles string, inRole string) bool {
+	roles := strings.Split(userRoles, " ")
+
+	for _, r := range roles {
+		if r == inRole {
+			return true
+		}
+	}
+
+	return false
+}
+
+func (u *User) IsSSOUser() bool {
+	return u.AuthService != "" && u.AuthService != USER_AUTH_SERVICE_EMAIL
+}
+
+func (u *User) IsOAuthUser() bool {
+	return u.AuthService == SERVICE_GITLAB ||
+		u.AuthService == SERVICE_GOOGLE ||
+		u.AuthService == SERVICE_OFFICE365 ||
+		u.AuthService == SERVICE_OPENID
+}
+
+func (u *User) IsLDAPUser() bool {
+	return u.AuthService == USER_AUTH_SERVICE_LDAP
+}
+
+func (u *User) IsSAMLUser() bool {
+	return u.AuthService == USER_AUTH_SERVICE_SAML
+}
+
+func (u *User) GetPreferredTimezone() string {
+	return GetPreferredTimezone(u.Timezone)
+}
+
+// IsRemote returns true if the user belongs to a remote cluster (has RemoteId).
+func (u *User) IsRemote() bool {
+	return u.RemoteId != nil && *u.RemoteId != ""
+}
+
+// GetRemoteID returns the remote id for this user or "" if not a remote user.
+func (u *User) GetRemoteID() string {
+	if u.RemoteId != nil {
+		return *u.RemoteId
+	}
+	return ""
+}
+
+// GetProp fetches a prop value by name.
+func (u *User) GetProp(name string) (string, bool) {
+	val, ok := u.Props[name]
+	return val, ok
+}
+
+// SetProp sets a prop value by name, creating the map if nil.
+// Not thread safe.
+func (u *User) SetProp(name string, value string) {
+	if u.Props == nil {
+		u.Props = make(map[string]string)
+	}
+	u.Props[name] = value
+}
+
+func (u *User) ToPatch() *UserPatch {
+	return &UserPatch{
+		Username: &u.Username, Password: &u.Password,
+		Nickname: &u.Nickname, FirstName: &u.FirstName, LastName: &u.LastName,
+		Position: &u.Position, Email: &u.Email,
+		Props: u.Props, NotifyProps: u.NotifyProps,
+		Locale: &u.Locale, Timezone: u.Timezone,
+	}
+}
+
+func (u *UserPatch) SetField(fieldName string, fieldValue string) {
+	switch fieldName {
+	case "FirstName":
+		u.FirstName = &fieldValue
+	case "LastName":
+		u.LastName = &fieldValue
+	case "Nickname":
+		u.Nickname = &fieldValue
+	case "Email":
+		u.Email = &fieldValue
+	case "Position":
+		u.Position = &fieldValue
+	case "Username":
+		u.Username = &fieldValue
+	}
+}
+
+// UserFromJson will decode the input and return a User
+func UserFromJson(data io.Reader) *User {
+	var user *User
+	json.NewDecoder(data).Decode(&user)
+	return user
+}
+
+func UserPatchFromJson(data io.Reader) *UserPatch {
+	var user *UserPatch
+	json.NewDecoder(data).Decode(&user)
+	return user
+}
+
+func UserAuthFromJson(data io.Reader) *UserAuth {
+	var user *UserAuth
+	json.NewDecoder(data).Decode(&user)
+	return user
+}
+
+func UserMapToJson(u map[string]*User) string {
+	b, _ := json.Marshal(u)
+	return string(b)
+}
+
+func UserMapFromJson(data io.Reader) map[string]*User {
+	var users map[string]*User
+	json.NewDecoder(data).Decode(&users)
+	return users
+}
+
+func UserListToJson(u []*User) string {
+	b, _ := json.Marshal(u)
+	return string(b)
+}
+
+func UserListFromJson(data io.Reader) []*User {
+	var users []*User
+	json.NewDecoder(data).Decode(&users)
+	return users
+}
+
+// HashPassword generates a hash using the bcrypt.GenerateFromPassword
+func HashPassword(password string) string {
+	hash, err := bcrypt.GenerateFromPassword([]byte(password), 10)
+	if err != nil {
+		panic(err)
+	}
+
+	return string(hash)
+}
+
+// ComparePassword compares the hash
+// This function is deprecated and will be removed in a future release.
+func ComparePassword(hash string, password string) bool {
+
+	if password == "" || hash == "" {
+		return false
+	}
+
+	err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
+	return err == nil
+}
+
+var validUsernameChars = regexp.MustCompile(`^[a-z0-9\.\-_]+$`)
+var validUsernameCharsForRemote = regexp.MustCompile(`^[a-z0-9\.\-_:]+$`)
+
+var restrictedUsernames = map[string]struct{}{
+	"all":       {},
+	"channel":   {},
+	"matterbot": {},
+	"system":    {},
+}
+
+func IsValidUsername(s string) bool {
+	if len(s) < USER_NAME_MIN_LENGTH || len(s) > USER_NAME_MAX_LENGTH {
+		return false
+	}
+
+	if !validUsernameChars.MatchString(s) {
+		return false
+	}
+
+	_, found := restrictedUsernames[s]
+	return !found
+}
+
+func IsValidUsernameAllowRemote(s string) bool {
+	if len(s) < USER_NAME_MIN_LENGTH || len(s) > USER_NAME_MAX_LENGTH {
+		return false
+	}
+
+	if !validUsernameCharsForRemote.MatchString(s) {
+		return false
+	}
+
+	_, found := restrictedUsernames[s]
+	return !found
+}
+
+func CleanUsername(username string) string {
+	s := NormalizeUsername(strings.Replace(username, " ", "-", -1))
+
+	for _, value := range reservedName {
+		if s == value {
+			s = strings.Replace(s, value, "", -1)
+		}
+	}
+
+	s = strings.TrimSpace(s)
+
+	for _, c := range s {
+		char := fmt.Sprintf("%c", c)
+		if !validUsernameChars.MatchString(char) {
+			s = strings.Replace(s, char, "-", -1)
+		}
+	}
+
+	s = strings.Trim(s, "-")
+
+	if !IsValidUsername(s) {
+		s = "a" + NewId()
+		mlog.Warn("Generating new username since provided username was invalid",
+			mlog.String("provided_username", username), mlog.String("new_username", s))
+	}
+
+	return s
+}
+
+func IsValidUserNotifyLevel(notifyLevel string) bool {
+	return notifyLevel == CHANNEL_NOTIFY_ALL ||
+		notifyLevel == CHANNEL_NOTIFY_MENTION ||
+		notifyLevel == CHANNEL_NOTIFY_NONE
+}
+
+func IsValidPushStatusNotifyLevel(notifyLevel string) bool {
+	return notifyLevel == STATUS_ONLINE ||
+		notifyLevel == STATUS_AWAY ||
+		notifyLevel == STATUS_OFFLINE
+}
+
+func IsValidCommentsNotifyLevel(notifyLevel string) bool {
+	return notifyLevel == COMMENTS_NOTIFY_ANY ||
+		notifyLevel == COMMENTS_NOTIFY_ROOT ||
+		notifyLevel == COMMENTS_NOTIFY_NEVER
+}
+
+func IsValidEmailBatchingInterval(emailInterval string) bool {
+	return emailInterval == PREFERENCE_EMAIL_INTERVAL_IMMEDIATELY ||
+		emailInterval == PREFERENCE_EMAIL_INTERVAL_FIFTEEN ||
+		emailInterval == PREFERENCE_EMAIL_INTERVAL_HOUR
+}
+
+func IsValidLocale(locale string) bool {
+	if locale != "" {
+		if len(locale) > USER_LOCALE_MAX_LENGTH {
+			return false
+		} else if _, err := language.Parse(locale); err != nil {
+			return false
+		}
+	}
+
+	return true
+}
+
+//msgp:ignore UserWithGroups
+type UserWithGroups struct {
+	User
+	GroupIDs    *string  `json:"-"`
+	Groups      []*Group `json:"groups"`
+	SchemeGuest bool     `json:"scheme_guest"`
+	SchemeUser  bool     `json:"scheme_user"`
+	SchemeAdmin bool     `json:"scheme_admin"`
+}
+
+func (u *UserWithGroups) GetGroupIDs() []string {
+	if u.GroupIDs == nil {
+		return nil
+	}
+	trimmed := strings.TrimSpace(*u.GroupIDs)
+	if trimmed == "" {
+		return nil
+	}
+	return strings.Split(trimmed, ",")
+}
+
+//msgp:ignore UsersWithGroupsAndCount
+type UsersWithGroupsAndCount struct {
+	Users []*UserWithGroups `json:"users"`
+	Count int64             `json:"total_count"`
+}
+
+func UsersWithGroupsAndCountFromJson(data io.Reader) *UsersWithGroupsAndCount {
+	uwg := &UsersWithGroupsAndCount{}
+	bodyBytes, _ := ioutil.ReadAll(data)
+	json.Unmarshal(bodyBytes, uwg)
+	return uwg
+}
Index: mattermost-server-7.8.1/model/utils.go
===================================================================
--- mattermost-server-7.8.1/model/utils.go	(revision 4484)
+++ mattermost-server-7.8.1/model/utils.go	(revision 4485)
@@ -250,6 +250,10 @@
 	wrapped       error
 }
 
+type UserStatusId struct {
+	Id string `json:"user_id"`
+}
+
 func (er *AppError) Error() string {
 	var sb strings.Builder
 
@@ -531,6 +535,19 @@
 	return b
 }
 
+// UserFromJson will decode the input and return a User
+func UserFromJson(data io.Reader) *User {
+	var user *User
+	json.NewDecoder(data).Decode(&user)
+	return user
+}
+
+func UserIdFromJson(data io.Reader) *UserStatusId {
+	var user *UserStatusId
+	json.NewDecoder(data).Decode(&user)
+	return user
+}
+
 func GetServerIPAddress(iface string) string {
 	var addrs []net.Addr
 	if iface == "" {
Index: mattermost-server-7.8.1/plugin/api.go
===================================================================
--- mattermost-server-7.8.1/plugin/api.go	(revision 4484)
+++ mattermost-server-7.8.1/plugin/api.go	(revision 4485)
@@ -276,6 +276,15 @@
 	// Minimum server version: 5.8
 	UpdateUserActive(userID string, active bool) *model.AppError
 
+	/* Ryobi Systems MM_NC_連動SSOログアウト Mod 20201130 START */
+	// RevokeAllSessionsById will clear specific user's all sessions.
+	//
+	// @tag User
+	// Minimum server version: 5.8
+	RevokeAllSessionsById(userId string) *model.AppError
+	// delete session by userID sessionState
+	RevokeUserSessionById(userId string, sessionState string) *model.AppError
+	/* Ryobi Systems MM_NC_連動SSOログアウト Mod 20201130 END */
 	// UpdateUserCustomStatus will set a user's custom status until the user, or another integration/plugin, clear it or update the custom status.
 	// The custom status have two parameters: emoji icon and custom text.
 	//
@@ -284,6 +293,7 @@
 	UpdateUserCustomStatus(userID string, customStatus *model.CustomStatus) *model.AppError
 
 	// RemoveUserCustomStatus will remove a user's custom status.
+
 	//
 	// @tag User
 	// Minimum server version: 6.2
@@ -692,7 +702,20 @@
 	// @tag Post
 	// Minimum server version: 5.2
 	GetPost(postId string) (*model.Post, *model.AppError)
+	// GetPollFields gets the fields of a poll.
+	//
+	// @tag Post
+	GetPollFields(postId string) ([]*model.PollFields, *model.AppError)
 
+	// PollFieldsInsert Pollfields insert a field of a poll.
+	//
+	// @tag Post
+	PollFieldsInsert(field *model.PollFields) *model.AppError
+	// DeletePollFields   DELETE a field of a poll.
+	//
+	// @tag Post
+	DeletePollFields(userId string, postId string) *model.AppError
+
 	// GetPostsSince gets posts created after a specified time as Unix time in milliseconds.
 	//
 	// @tag Post
@@ -732,7 +755,11 @@
 	// @tag Post
 	// Minimum server version: 5.2
 	UpdatePost(post *model.Post) (*model.Post, *model.AppError)
+	// UpdatePostWithCachereRefresh @tag Post
+	// Minimum server version: 5.2
+	UpdatePostWithCachereRefresh(post *model.Post) (*model.Post, *model.AppError)
 
+	GetUsersInChannelPageByStatus(options *model.UserGetOptions, asAdmin bool) ([]*model.User, *model.AppError)
 	// GetProfileImage gets user's profile image.
 	//
 	// @tag User
@@ -1147,7 +1174,9 @@
 	//
 	// Minimum server version: 5.36
 	RequestTrialLicense(requesterID string, users int, termsAccepted bool, receiveEmailsAccepted bool) *model.AppError
-
+	/* Ryobi Systems CloudOffice Files Mod 20211103 START */
+	GetFilesTotalSize() (float64, *model.AppError)
+	/* Ryobi Systems CloudOffice Files Mod 20211103 END */
 	// GetCloudLimits gets limits associated with a cloud workspace, if any
 	//
 	// Minimum server version: 7.0
Index: mattermost-server-7.8.1/plugin/api_timer_layer_generated.go
===================================================================
--- mattermost-server-7.8.1/plugin/api_timer_layer_generated.go	(revision 4484)
+++ mattermost-server-7.8.1/plugin/api_timer_layer_generated.go	(revision 4485)
@@ -21,6 +21,13 @@
 	metrics  einterfaces.MetricsInterface
 }
 
+func (api *apiTimerLayer) RevokeUserSessionById(userId string, sessionState string) *model.AppError {
+	startTime := timePkg.Now()
+	_returnsA := api.apiImpl.RevokeUserSessionById(userId, sessionState)
+	api.recordTime(startTime, "RevokeUserSessionById", _returnsA == nil)
+	return _returnsA
+}
+
 func (api *apiTimerLayer) recordTime(startTime timePkg.Time, name string, success bool) {
 	if api.metrics != nil {
 		elapsedTime := float64(timePkg.Since(startTime)) / float64(timePkg.Second)
@@ -322,6 +329,15 @@
 	return _returnsA
 }
 
+/* Ryobi Systems MM_NC_連動SSOログアウト Mod 20201130 START */
+func (api *apiTimerLayer) RevokeAllSessionsById(userId string) *model.AppError {
+	startTime := timePkg.Now()
+	_returnsA := api.apiImpl.RevokeAllSessionsById(userId)
+	api.recordTime(startTime, "RevokeAllSessionsById", _returnsA == nil)
+	return _returnsA
+}
+
+/* Ryobi Systems MM_NC_連動SSOログアウト Mod 20201130 END */
 func (api *apiTimerLayer) UpdateUserCustomStatus(userID string, customStatus *model.CustomStatus) *model.AppError {
 	startTime := timePkg.Now()
 	_returnsA := api.apiImpl.UpdateUserCustomStatus(userID, customStatus)
@@ -761,7 +777,18 @@
 	api.recordTime(startTime, "GetPost", _returnsB == nil)
 	return _returnsA, _returnsB
 }
-
+func (api *apiTimerLayer) GetPollFields(postId string) ([]*model.PollFields, *model.AppError) {
+	_returnsA, _returnsB := api.apiImpl.GetPollFields(postId)
+	return _returnsA, _returnsB
+}
+func (api *apiTimerLayer) PollFieldsInsert(field *model.PollFields) *model.AppError {
+	_returnsA := api.apiImpl.PollFieldsInsert(field)
+	return _returnsA
+}
+func (api *apiTimerLayer) DeletePollFields(userId string, postId string) *model.AppError {
+	_returnsA := api.apiImpl.DeletePollFields(userId, postId)
+	return _returnsA
+}
 func (api *apiTimerLayer) GetPostsSince(channelId string, time int64) (*model.PostList, *model.AppError) {
 	startTime := timePkg.Now()
 	_returnsA, _returnsB := api.apiImpl.GetPostsSince(channelId, time)
@@ -803,6 +830,18 @@
 	api.recordTime(startTime, "UpdatePost", _returnsB == nil)
 	return _returnsA, _returnsB
 }
+func (api *apiTimerLayer) UpdatePostWithCachereRefresh(post *model.Post) (*model.Post, *model.AppError) {
+	startTime := timePkg.Now()
+	_returnsA, _returnsB := api.apiImpl.UpdatePostWithCachereRefresh(post)
+	api.recordTime(startTime, "UpdatePost", _returnsB == nil)
+	return _returnsA, _returnsB
+}
+func (api *apiTimerLayer) GetUsersInChannelPageByStatus(options *model.UserGetOptions, asAdmin bool) ([]*model.User, *model.AppError) {
+	startTime := timePkg.Now()
+	_returnsA, _returnsB := api.apiImpl.GetUsersInChannelPageByStatus(options, asAdmin)
+	api.recordTime(startTime, "asAdmin", _returnsB == nil)
+	return _returnsA, _returnsB
+}
 
 func (api *apiTimerLayer) GetProfileImage(userID string) ([]byte, *model.AppError) {
 	startTime := timePkg.Now()
@@ -1267,3 +1306,13 @@
 	api.recordTime(startTime, "GetUploadSession", _returnsB == nil)
 	return _returnsA, _returnsB
 }
+
+/* Ryobi Systems CloudOffice Files Mod 20211103 START */
+func (api *apiTimerLayer) GetFilesTotalSize() (float64, *model.AppError) {
+	startTime := timePkg.Now()
+	_returnsA, _returnsB := api.apiImpl.GetFilesTotalSize()
+	api.recordTime(startTime, "GetFilesTotalSize", true)
+	return _returnsA, _returnsB
+}
+
+/* Ryobi Systems CloudOffice Files Mod 20211103 END */
Index: mattermost-server-7.8.1/plugin/client_rpc.go
===================================================================
--- mattermost-server-7.8.1/plugin/client_rpc.go	(revision 4484)
+++ mattermost-server-7.8.1/plugin/client_rpc.go	(revision 4485)
@@ -72,6 +72,11 @@
 	muxBroker *plugin.MuxBroker
 }
 
+func (g *apiRPCClient) GetFilesTotalSize() (float64, *model.AppError) {
+	//TODO implement me
+	panic("implement me")
+}
+
 type apiRPCServer struct {
 	impl      API
 	muxBroker *plugin.MuxBroker
Index: mattermost-server-7.8.1/plugin/client_rpc_generated.go
===================================================================
--- mattermost-server-7.8.1/plugin/client_rpc_generated.go	(revision 4484)
+++ mattermost-server-7.8.1/plugin/client_rpc_generated.go	(revision 4485)
@@ -2209,6 +2209,67 @@
 	return nil
 }
 
+/* Ryobi Systems MM_NC_連動SSOログアウト Mod 20201130 START */
+type Z_RevokeAllSessionsByIdArgs struct {
+	A string
+}
+
+type Z_RevokeAllSessionsByIdReturns struct {
+	A *model.AppError
+}
+
+func (g *apiRPCClient) RevokeAllSessionsById(userId string) *model.AppError {
+	_args := &Z_RevokeAllSessionsByIdArgs{userId}
+	_returns := &Z_RevokeAllSessionsByIdReturns{}
+	if err := g.client.Call("Plugin.RevokeAllSessionsById", _args, _returns); err != nil {
+		log.Printf("RPC call to RevokeAllSessionsById API failed: %s", err.Error())
+	}
+	return _returns.A
+}
+
+func (s *apiRPCServer) RevokeAllSessionsById(args *Z_RevokeAllSessionsByIdArgs, returns *Z_RevokeAllSessionsByIdReturns) error {
+	if hook, ok := s.impl.(interface {
+		RevokeAllSessionsById(userId string) *model.AppError
+	}); ok {
+		returns.A = hook.RevokeAllSessionsById(args.A)
+	} else {
+		return encodableError(fmt.Errorf("API RevokeAllSessionsById called but not implemented."))
+	}
+	return nil
+}
+/* Ryobi Systems MM_NC_連動SSOログアウト Mod 20201130 END */
+
+
+/* Ryobi Systems MM_NC_連動SSOログアウト Mod 20211224 START */
+type Z_RevokeUserSessionByIdArgs struct {
+	A string
+	B string
+}
+
+type Z_RevokeUserSessionByIdReturns struct {
+	A *model.AppError
+}
+
+func (g *apiRPCClient) RevokeUserSessionById(userId string,sessionState string) *model.AppError {
+	_args := &Z_RevokeUserSessionByIdArgs{userId,sessionState}
+	_returns := &Z_RevokeUserSessionByIdReturns{}
+	if err := g.client.Call("Plugin.RevokeUserSessionById", _args, _returns); err != nil {
+		log.Printf("RPC call to RevokeUserSessionById API failed: %s", err.Error())
+	}
+	return _returns.A
+}
+
+func (s *apiRPCServer) RevokeUserSessionById(args *Z_RevokeUserSessionByIdArgs, returns *Z_RevokeUserSessionByIdReturns) error {
+	if hook, ok := s.impl.(interface {
+		RevokeUserSessionById(userId string,sessionState string) *model.AppError
+	}); ok {
+		returns.A = hook.RevokeUserSessionById(args.A,args.B)
+	} else {
+		return encodableError(fmt.Errorf("API RevokeUserSessionById called but not implemented."))
+	}
+	return nil
+}
+/* Ryobi Systems MM_NC_連動SSOログアウト Mod 20211224 END */
 type Z_UpdateUserCustomStatusArgs struct {
 	A string
 	B *model.CustomStatus
@@ -4060,6 +4121,35 @@
 	B *model.AppError
 }
 
+type Z_GetPollFieldsArgs struct {
+	A string
+}
+type Z_GetPostWithoutCacheArgsArgs struct {
+	A *model.Post
+}
+type Z_GetPostWithoutCacheArgsReturns struct {
+	A *model.Post
+	B *model.AppError
+}
+type Z_GetPollFieldArgs struct {
+	A *model.PollFields
+}
+type Z_GetPollFieldDeleteArgs struct {
+	A string
+	B string
+}
+
+type Z_GetPollFieldsReturns struct {
+	A []*model.PollFields
+	B *model.AppError
+}
+type Z_GetPollFieldReturns struct {
+	A *model.AppError
+}
+type Z_GetPollFieldDeleteReturns struct {
+	A *model.AppError
+}
+
 func (g *apiRPCClient) GetPost(postId string) (*model.Post, *model.AppError) {
 	_args := &Z_GetPostArgs{postId}
 	_returns := &Z_GetPostReturns{}
@@ -4080,6 +4170,63 @@
 	return nil
 }
 
+func (g *apiRPCClient) GetPollFields(postId string) ([]*model.PollFields, *model.AppError) {
+	_args := &Z_GetPollFieldsArgs{postId}
+	_returns := &Z_GetPollFieldsReturns{}
+	if err := g.client.Call("Plugin.GetPollFields", _args, _returns); err != nil {
+		log.Printf("RPC call to GetPollFields API failed: %s", err.Error())
+	}
+	return _returns.A, _returns.B
+}
+func (s *apiRPCServer) GetPollFields(args *Z_GetPollFieldsArgs, returns *Z_GetPollFieldsReturns) error {
+	if hook, ok := s.impl.(interface {
+		GetPollFields(postId string) ([]*model.PollFields, *model.AppError)
+	}); ok {
+		returns.A, returns.B = hook.GetPollFields(args.A)
+	} else {
+		return encodableError(fmt.Errorf("API GetPollFields called but not implemented."))
+	}
+	return nil
+}
+func (g *apiRPCClient) DeletePollFields(userId string, postId string) *model.AppError {
+	_args := &Z_GetPollFieldDeleteArgs{userId, postId}
+	_returns := &Z_GetPollFieldDeleteReturns{}
+	if err := g.client.Call("Plugin.DeletePollFields", _args, _returns); err != nil {
+		log.Printf("RPC call to DeletePollFields API failed: %s", err.Error())
+	}
+	return _returns.A
+}
+func (s *apiRPCServer) DeletePollFields(args *Z_GetPollFieldDeleteArgs, returns *Z_GetPollFieldDeleteReturns) error {
+	if hook, ok := s.impl.(interface {
+		DeletePollFields(userId string, postId string) *model.AppError
+	}); ok {
+		returns.A = hook.DeletePollFields(args.A, args.B)
+	} else {
+		return encodableError(fmt.Errorf("API DeletePollFields called but not implemented."))
+	}
+	return nil
+}
+
+func (g *apiRPCClient) PollFieldsInsert(field *model.PollFields) *model.AppError {
+	_args := &Z_GetPollFieldArgs{field}
+	_returns := &Z_GetPollFieldReturns{}
+	if err := g.client.Call("Plugin.PollFieldsInsert", _args, _returns); err != nil {
+		log.Printf("RPC call to PollFieldsInsert API failed: %s", err.Error())
+	}
+	return _returns.A
+}
+
+func (s *apiRPCServer) PollFieldsInsert(args *Z_GetPollFieldArgs, returns *Z_GetPollFieldReturns) error {
+	if hook, ok := s.impl.(interface {
+		PollFieldsInsert(field *model.PollFields) *model.AppError
+	}); ok {
+		returns.A = hook.PollFieldsInsert(args.A)
+	} else {
+		return encodableError(fmt.Errorf("API PollFieldsInsert called but not implemented."))
+	}
+	return nil
+}
+
 type Z_GetPostsSinceArgs struct {
 	A string
 	B int64
@@ -4262,7 +4409,55 @@
 	}
 	return nil
 }
+func (g *apiRPCClient) UpdatePostWithCachereRefresh(post *model.Post) (*model.Post, *model.AppError) {
+	_args := &Z_UpdatePostArgs{post}
+	_returns := &Z_UpdatePostReturns{}
+	if err := g.client.Call("Plugin.UpdatePostWithCachereRefresh", _args, _returns); err != nil {
+		log.Printf("RPC call to UpdatePostWithCachereRefresh API failed: %s", err.Error())
+	}
+	return _returns.A, _returns.B
+}
 
+func (s *apiRPCServer) UpdatePostWithCachereRefresh(args *Z_UpdatePostArgs, returns *Z_UpdatePostReturns) error {
+	if hook, ok := s.impl.(interface {
+		UpdatePostWithCachereRefresh(post *model.Post) (*model.Post, *model.AppError)
+	}); ok {
+		returns.A, returns.B = hook.UpdatePostWithCachereRefresh(args.A)
+	} else {
+		return encodableError(fmt.Errorf("API UpdatePostWithCachereRefresh called but not implemented."))
+	}
+	return nil
+}
+
+func (g *apiRPCClient) GetUsersInChannelPageByStatus(options *model.UserGetOptions, asAdmin bool) ([]*model.User, *model.AppError) {
+	_args := &Z_GetChannelUsersArgs{options, asAdmin}
+	_returns := &Z_GetChannelUsersReturns{}
+	if err := g.client.Call("Plugin.GetUsersInChannelPageByStatus", _args, _returns); err != nil {
+		log.Printf("RPC call to GetUsersInChannelPageByStatus API failed: %s", err.Error())
+	}
+	return _returns.A, _returns.B
+}
+
+func (s *apiRPCServer) GetUsersInChannelPageByStatus(args *Z_GetChannelUsersArgs, returns *Z_GetChannelUsersReturns) error {
+	if hook, ok := s.impl.(interface {
+		GetUsersInChannelPageByStatus(options *model.UserGetOptions, asAdmin bool) ([]*model.User, *model.AppError)
+	}); ok {
+		returns.A, returns.B = hook.GetUsersInChannelPageByStatus(args.A, args.B)
+	} else {
+		return encodableError(fmt.Errorf("API GetUsersInChannelPageByStatus called but not implemented."))
+	}
+	return nil
+}
+
+type Z_GetChannelUsersArgs struct {
+	A *model.UserGetOptions
+	B bool
+}
+
+type Z_GetChannelUsersReturns struct {
+	A []*model.User
+	B *model.AppError
+}
 type Z_GetProfileImageArgs struct {
 	A string
 }
Index: mattermost-server-7.8.1/plugin/plugintest/api.go
===================================================================
--- mattermost-server-7.8.1/plugin/plugintest/api.go	(revision 4484)
+++ mattermost-server-7.8.1/plugin/plugintest/api.go	(revision 4485)
@@ -3615,6 +3615,31 @@
 	return r0, r1
 }
 
+// UpdatePost provides a mock function with given fields: post
+func (_m *API) UpdatePostWithCachereRefresh(post *model.Post) (*model.Post, *model.AppError) {
+	ret := _m.Called(post)
+
+	var r0 *model.Post
+	if rf, ok := ret.Get(0).(func(*model.Post) *model.Post); ok {
+		r0 = rf(post)
+	} else {
+		if ret.Get(0) != nil {
+			r0 = ret.Get(0).(*model.Post)
+		}
+	}
+
+	var r1 *model.AppError
+	if rf, ok := ret.Get(1).(func(*model.Post) *model.AppError); ok {
+		r1 = rf(post)
+	} else {
+		if ret.Get(1) != nil {
+			r1 = ret.Get(1).(*model.AppError)
+		}
+	}
+
+	return r0, r1
+}
+
 // UpdatePreferencesForUser provides a mock function with given fields: userID, preferences
 func (_m *API) UpdatePreferencesForUser(userID string, preferences []model.Preference) *model.AppError {
 	ret := _m.Called(userID, preferences)
Index: mattermost-server-7.8.1/services/telemetry/telemetry.go
===================================================================
--- mattermost-server-7.8.1/services/telemetry/telemetry.go	(revision 4484)
+++ mattermost-server-7.8.1/services/telemetry/telemetry.go	(revision 4485)
@@ -472,6 +472,9 @@
 		"restrict_direct_message":                 *cfg.TeamSettings.RestrictDirectMessage,
 		"max_notifications_per_channel":           *cfg.TeamSettings.MaxNotificationsPerChannel,
 		"enable_confirm_notifications_to_channel": *cfg.TeamSettings.EnableConfirmNotificationsToChannel,
+		/* Ryobi Systems CloudOffice Channel Mod 20210802 start */
+		"enable_confirm_notifications_to_channel_user_count": *cfg.TeamSettings.EnableConfirmNotificationsToChannelUserCount,
+		/* Ryobi Systems CloudOffice Channel Mod 20210816 end */
 		"max_users_per_team":                      *cfg.TeamSettings.MaxUsersPerTeam,
 		"max_channels_per_team":                   *cfg.TeamSettings.MaxChannelsPerTeam,
 		"teammate_name_display":                   *cfg.TeamSettings.TeammateNameDisplay,
Index: mattermost-server-7.8.1/services/users/session.go
===================================================================
--- mattermost-server-7.8.1/services/users/session.go	(nonexistent)
+++ mattermost-server-7.8.1/services/users/session.go	(revision 4485)
@@ -0,0 +1,268 @@
+// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
+// See LICENSE.txt for license information.
+
+package users
+
+import (
+	"context"
+	"fmt"
+	"time"
+
+	"github.com/mattermost/mattermost-server/v6/model"
+	"github.com/mattermost/mattermost-server/v6/shared/mlog"
+	"github.com/mattermost/mattermost-server/v6/store/sqlstore"
+	"github.com/pkg/errors"
+)
+
+func (us *UserService) ReturnSessionToPool(session *model.Session) {
+	if session != nil {
+		session.Id = ""
+		us.sessionPool.Put(session)
+	}
+}
+
+func (us *UserService) CreateSession(session *model.Session) (*model.Session, error) {
+	session.Token = ""
+
+	session, err := us.sessionStore.Save(session)
+	if err != nil {
+		return nil, err
+	}
+
+	us.AddSessionToCache(session)
+
+	return session, nil
+}
+
+func (us *UserService) GetSession(token string) (*model.Session, error) {
+	var session = us.sessionPool.Get().(*model.Session)
+	if err := us.sessionCache.Get(token, session); err == nil {
+		if us.metrics != nil {
+			us.metrics.IncrementMemCacheHitCounterSession()
+		}
+	} else {
+		if us.metrics != nil {
+			us.metrics.IncrementMemCacheMissCounterSession()
+		}
+	}
+
+	if session.Id != "" {
+		return session, nil
+	}
+
+	return us.GetSessionContext(sqlstore.WithMaster(context.Background()), token)
+}
+
+func (us *UserService) GetSessionContext(ctx context.Context, token string) (*model.Session, error) {
+	return us.sessionStore.Get(ctx, token)
+}
+
+func (us *UserService) GetSessions(userID string) ([]*model.Session, error) {
+	return us.sessionStore.GetSessions(userID)
+}
+
+func (us *UserService) AddSessionToCache(session *model.Session) {
+	us.sessionCache.SetWithExpiry(session.Token, session, time.Duration(int64(*us.config().ServiceSettings.SessionCacheInMinutes))*time.Minute)
+}
+
+func (us *UserService) SessionCacheLength() int {
+	if l, err := us.sessionCache.Len(); err == nil {
+		return l
+	}
+	return 0
+}
+
+func (us *UserService) ClearUserSessionCacheLocal(userID string) {
+	if keys, err := us.sessionCache.Keys(); err == nil {
+		var session *model.Session
+		for _, key := range keys {
+			if err := us.sessionCache.Get(key, &session); err == nil {
+				if session.UserId == userID {
+					us.sessionCache.Remove(key)
+					if us.metrics != nil {
+						us.metrics.IncrementMemCacheInvalidationCounterSession()
+					}
+				}
+			}
+		}
+	}
+}
+
+func (us *UserService) ClearAllUsersSessionCacheLocal() {
+	us.sessionCache.Purge()
+}
+
+func (us *UserService) ClearUserSessionCache(userID string) {
+	us.ClearUserSessionCacheLocal(userID)
+
+	if us.cluster != nil {
+		msg := &model.ClusterMessage{
+			Event:    model.CLUSTER_EVENT_CLEAR_SESSION_CACHE_FOR_USER,
+			SendType: model.CLUSTER_SEND_RELIABLE,
+			Data:     userID,
+		}
+		us.cluster.SendClusterMessage(msg)
+	}
+}
+
+func (us *UserService) ClearAllUsersSessionCache() {
+	us.ClearAllUsersSessionCacheLocal()
+
+	if us.cluster != nil {
+		msg := &model.ClusterMessage{
+			Event:    model.CLUSTER_EVENT_CLEAR_SESSION_CACHE_FOR_ALL_USERS,
+			SendType: model.CLUSTER_SEND_RELIABLE,
+		}
+		us.cluster.SendClusterMessage(msg)
+	}
+}
+
+func (us *UserService) GetSessionByID(sessionID string) (*model.Session, error) {
+	return us.sessionStore.Get(context.Background(), sessionID)
+}
+
+func (us *UserService) RevokeSessionsFromAllUsers() error {
+	// revoke tokens before sessions so they can't be used to relogin
+	nErr := us.oAuthStore.RemoveAllAccessData()
+	if nErr != nil {
+		return errors.Wrap(DeleteAllAccessDataError, nErr.Error())
+	}
+	err := us.sessionStore.RemoveAllSessions()
+	if err != nil {
+		return err
+	}
+
+	us.ClearAllUsersSessionCache()
+	return nil
+}
+
+func (us *UserService) RevokeSessionsForDeviceId(userID string, deviceID string, currentSessionId string) error {
+	sessions, err := us.sessionStore.GetSessions(userID)
+	if err != nil {
+		return err
+	}
+	for _, session := range sessions {
+		if session.DeviceId == deviceID && session.Id != currentSessionId {
+			mlog.Debug("Revoking sessionId for userId. Re-login with the same device Id", mlog.String("session_id", session.Id), mlog.String("user_id", userID))
+			if err := us.RevokeSession(session); err != nil {
+				mlog.Warn("Could not revoke session for device", mlog.String("device_id", deviceID), mlog.Err(err))
+			}
+		}
+	}
+
+	return nil
+}
+
+func (us *UserService) RevokeSession(session *model.Session) error {
+	if session.IsOAuth {
+		if err := us.RevokeAccessToken(session.Token); err != nil {
+			return err
+		}
+	} else {
+		if err := us.sessionStore.Remove(session.Id); err != nil {
+			return errors.Wrap(DeleteSessionError, err.Error())
+		}
+	}
+
+	us.ClearUserSessionCache(session.UserId)
+
+	return nil
+}
+
+func (us *UserService) RevokeAccessToken(token string) error {
+	session, _ := us.GetSession(token)
+
+	defer us.ReturnSessionToPool(session)
+
+	schan := make(chan error, 1)
+	go func() {
+		schan <- us.sessionStore.Remove(token)
+		close(schan)
+	}()
+
+	if _, err := us.oAuthStore.GetAccessData(token); err != nil {
+		return errors.Wrap(GetTokenError, err.Error())
+	}
+
+	if err := us.oAuthStore.RemoveAccessData(token); err != nil {
+		return errors.Wrap(DeleteTokenError, err.Error())
+	}
+
+	if err := <-schan; err != nil {
+		return errors.Wrap(DeleteSessionError, err.Error())
+	}
+
+	if session != nil {
+		us.ClearUserSessionCache(session.UserId)
+	}
+
+	return nil
+}
+
+// SetSessionExpireInDays sets the session's expiry the specified number of days
+// relative to either the session creation date or the current time, depending
+// on the `ExtendSessionOnActivity` config setting.
+func (us *UserService) SetSessionExpireInDays(session *model.Session, days int) {
+	if session.CreateAt == 0 || *us.config().ServiceSettings.ExtendSessionLengthWithActivity {
+		session.ExpiresAt = model.GetMillis() + (1000 * 60 * 60 * int64(days))
+	} else {
+		session.ExpiresAt = session.CreateAt + (1000 * 60 * 60 * int64(days))
+	}
+}
+
+func (us *UserService) UpdateSessionsIsGuest(userID string, isGuest bool) error {
+	sessions, err := us.GetSessions(userID)
+	if err != nil {
+		return err
+	}
+
+	for _, session := range sessions {
+		session.AddProp(model.SESSION_PROP_IS_GUEST, fmt.Sprintf("%t", isGuest))
+		err := us.sessionStore.UpdateProps(session)
+		if err != nil {
+			mlog.Warn("Unable to update isGuest session", mlog.Err(err))
+			continue
+		}
+		us.AddSessionToCache(session)
+	}
+	return nil
+}
+
+func (us *UserService) RevokeAllSessions(userID string) error {
+	sessions, err := us.sessionStore.GetSessions(userID)
+	if err != nil {
+		return errors.Wrap(GetSessionError, err.Error())
+	}
+	for _, session := range sessions {
+		if session.IsOAuth {
+			us.RevokeAccessToken(session.Token)
+		} else {
+			if err := us.sessionStore.Remove(session.Id); err != nil {
+				return errors.Wrap(DeleteSessionError, err.Error())
+			}
+		}
+	}
+
+	us.ClearUserSessionCache(userID)
+
+	return nil
+}
+
+/*
+Delete user session by userID sessionState
+*/
+func (us *UserService) RevokeSessionsBySid(userID string, sessionState string) error {
+	sessions, err := us.sessionStore.GetSessions(userID)
+	if err != nil {
+		return errors.Wrap(GetSessionError, err.Error())
+	}
+	for _, session := range sessions {
+		if sessionState == session.Props[model.SESSION_USER_STATE] {
+			if err := us.sessionStore.Remove(session.Id); err != nil {
+				return errors.Wrap(DeleteSessionError, err.Error())
+			}
+		}
+	}
+	us.ClearUserSessionCache(userID)
+	return nil
+}
Index: mattermost-server-7.8.1/shared/mail/mail.go
===================================================================
--- mattermost-server-7.8.1/shared/mail/mail.go	(revision 4484)
+++ mattermost-server-7.8.1/shared/mail/mail.go	(revision 4485)
@@ -259,6 +259,26 @@
 	return SendMailWithEmbeddedFilesUsingConfig(to, subject, htmlBody, nil, config, enableComplianceFeatures, messageID, inReplyTo, references, ccMail)
 }
 
+/* Ryobi Systems CloudOffice Meeting Mod 20210506 START */
+func SendMeetingMail(to, subject, htmlBody string, embeddedFiles map[string]io.Reader, config *SMTPConfig, ccMail string, fromMail mail.Address) error {
+	replyTo := mail.Address{Name: config.FeedbackName, Address: config.ReplyToAddress}
+
+	mail := mailData{
+		mimeTo:        to,
+		smtpTo:        to,
+		from:          fromMail,
+		cc:            ccMail,
+		replyTo:       replyTo,
+		subject:       subject,
+		htmlBody:      htmlBody,
+		embeddedFiles: embeddedFiles,
+	}
+
+	return sendMailUsingConfigAdvanced(mail, config)
+}
+
+/* Ryobi Systems CloudOffice Meeting Mod 20210506 END */
+
 // allows for sending an email with differing MIME/SMTP recipients
 func sendMailUsingConfigAdvanced(mail mailData, config *SMTPConfig) error {
 	if config.Server == "" {
Index: mattermost-server-7.8.1/store/opentracinglayer/opentracinglayer.go
===================================================================
--- mattermost-server-7.8.1/store/opentracinglayer/opentracinglayer.go	(revision 4484)
+++ mattermost-server-7.8.1/store/opentracinglayer/opentracinglayer.go	(revision 4485)
@@ -6695,9 +6695,9 @@
 	return result, err
 }
 
-func (s *OpenTracingLayerPostAcknowledgementStore) Delete(acknowledgement *model.PostAcknowledgement) error {
+func (s *OpenTracingLayerPostStore) UpdatePostWithCachereRefresh(post *model.Post) (*model.Post, error) {
 	origCtx := s.Root.Store.Context()
-	span, newCtx := tracing.StartSpanWithParentByContext(s.Root.Store.Context(), "PostAcknowledgementStore.Delete")
+	span, newCtx := tracing.StartSpanWithParentByContext(s.Root.Store.Context(), "PostStore.Update")
 	s.Root.Store.SetContext(newCtx)
 	defer func() {
 		s.Root.Store.SetContext(origCtx)
@@ -6704,36 +6704,18 @@
 	}()
 
 	defer span.Finish()
-	err := s.PostAcknowledgementStore.Delete(acknowledgement)
+	result, err := s.PostStore.UpdatePostWithCachereRefresh(post)
 	if err != nil {
 		span.LogFields(spanlog.Error(err))
 		ext.Error.Set(span, true)
 	}
 
-	return err
-}
-
-func (s *OpenTracingLayerPostAcknowledgementStore) Get(postID string, userID string) (*model.PostAcknowledgement, error) {
-	origCtx := s.Root.Store.Context()
-	span, newCtx := tracing.StartSpanWithParentByContext(s.Root.Store.Context(), "PostAcknowledgementStore.Get")
-	s.Root.Store.SetContext(newCtx)
-	defer func() {
-		s.Root.Store.SetContext(origCtx)
-	}()
-
-	defer span.Finish()
-	result, err := s.PostAcknowledgementStore.Get(postID, userID)
-	if err != nil {
-		span.LogFields(spanlog.Error(err))
-		ext.Error.Set(span, true)
-	}
-
 	return result, err
 }
 
-func (s *OpenTracingLayerPostAcknowledgementStore) GetForPost(postID string) ([]*model.PostAcknowledgement, error) {
+func (s *OpenTracingLayerUserStore) GetUsersInChannelPageByStatus(options *model.UserGetOptions, asAdmin bool) ([]*model.User, error) {
 	origCtx := s.Root.Store.Context()
-	span, newCtx := tracing.StartSpanWithParentByContext(s.Root.Store.Context(), "PostAcknowledgementStore.GetForPost")
+	span, newCtx := tracing.StartSpanWithParentByContext(s.Root.Store.Context(), "PostStore.Update")
 	s.Root.Store.SetContext(newCtx)
 	defer func() {
 		s.Root.Store.SetContext(origCtx)
@@ -6740,7 +6722,7 @@
 	}()
 
 	defer span.Finish()
-	result, err := s.PostAcknowledgementStore.GetForPost(postID)
+	result, err := s.UserStore.GetProfilesInChannelByStatus(options)
 	if err != nil {
 		span.LogFields(spanlog.Error(err))
 		ext.Error.Set(span, true)
@@ -6749,78 +6731,6 @@
 	return result, err
 }
 
-func (s *OpenTracingLayerPostAcknowledgementStore) GetForPosts(postIds []string) ([]*model.PostAcknowledgement, error) {
-	origCtx := s.Root.Store.Context()
-	span, newCtx := tracing.StartSpanWithParentByContext(s.Root.Store.Context(), "PostAcknowledgementStore.GetForPosts")
-	s.Root.Store.SetContext(newCtx)
-	defer func() {
-		s.Root.Store.SetContext(origCtx)
-	}()
-
-	defer span.Finish()
-	result, err := s.PostAcknowledgementStore.GetForPosts(postIds)
-	if err != nil {
-		span.LogFields(spanlog.Error(err))
-		ext.Error.Set(span, true)
-	}
-
-	return result, err
-}
-
-func (s *OpenTracingLayerPostAcknowledgementStore) Save(postID string, userID string, acknowledgedAt int64) (*model.PostAcknowledgement, error) {
-	origCtx := s.Root.Store.Context()
-	span, newCtx := tracing.StartSpanWithParentByContext(s.Root.Store.Context(), "PostAcknowledgementStore.Save")
-	s.Root.Store.SetContext(newCtx)
-	defer func() {
-		s.Root.Store.SetContext(origCtx)
-	}()
-
-	defer span.Finish()
-	result, err := s.PostAcknowledgementStore.Save(postID, userID, acknowledgedAt)
-	if err != nil {
-		span.LogFields(spanlog.Error(err))
-		ext.Error.Set(span, true)
-	}
-
-	return result, err
-}
-
-func (s *OpenTracingLayerPostPriorityStore) GetForPost(postId string) (*model.PostPriority, error) {
-	origCtx := s.Root.Store.Context()
-	span, newCtx := tracing.StartSpanWithParentByContext(s.Root.Store.Context(), "PostPriorityStore.GetForPost")
-	s.Root.Store.SetContext(newCtx)
-	defer func() {
-		s.Root.Store.SetContext(origCtx)
-	}()
-
-	defer span.Finish()
-	result, err := s.PostPriorityStore.GetForPost(postId)
-	if err != nil {
-		span.LogFields(spanlog.Error(err))
-		ext.Error.Set(span, true)
-	}
-
-	return result, err
-}
-
-func (s *OpenTracingLayerPostPriorityStore) GetForPosts(ids []string) ([]*model.PostPriority, error) {
-	origCtx := s.Root.Store.Context()
-	span, newCtx := tracing.StartSpanWithParentByContext(s.Root.Store.Context(), "PostPriorityStore.GetForPosts")
-	s.Root.Store.SetContext(newCtx)
-	defer func() {
-		s.Root.Store.SetContext(origCtx)
-	}()
-
-	defer span.Finish()
-	result, err := s.PostPriorityStore.GetForPosts(ids)
-	if err != nil {
-		span.LogFields(spanlog.Error(err))
-		ext.Error.Set(span, true)
-	}
-
-	return result, err
-}
-
 func (s *OpenTracingLayerPreferenceStore) CleanupFlagsBatch(limit int64) (int64, error) {
 	origCtx := s.Root.Store.Context()
 	span, newCtx := tracing.StartSpanWithParentByContext(s.Root.Store.Context(), "PreferenceStore.CleanupFlagsBatch")
Index: mattermost-server-7.8.1/store/retrylayer/retrylayer.go
===================================================================
--- mattermost-server-7.8.1/store/retrylayer/retrylayer.go	(revision 4484)
+++ mattermost-server-7.8.1/store/retrylayer/retrylayer.go	(revision 4485)
@@ -64,6 +64,7 @@
 	UserAccessTokenStore      store.UserAccessTokenStore
 	UserTermsOfServiceStore   store.UserTermsOfServiceStore
 	WebhookStore              store.WebhookStore
+	PollFieldsStore           store.PollFieldsStore
 }
 
 func (s *RetryLayer) Audit() store.AuditStore {
@@ -238,7 +239,10 @@
 	store.AuditStore
 	Root *RetryLayer
 }
-
+type RetryLayerPollFieldsStore struct {
+	store.PollFieldsStore
+	Root *RetryLayer
+}
 type RetryLayerBotStore struct {
 	store.BotStore
 	Root *RetryLayer
@@ -7582,6 +7586,26 @@
 
 }
 
+func (s *RetryLayerPostStore) UpdatePostWithCachereRefresh(post *model.Post) (*model.Post, error) {
+
+	tries := 0
+	for {
+		result, err := s.PostStore.UpdatePostWithCachereRefresh(post)
+		if err == nil {
+			return result, nil
+		}
+		if !isRepeatableError(err) {
+			return result, err
+		}
+		tries++
+		if tries >= 3 {
+			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
+			return result, err
+		}
+	}
+
+}
+
 func (s *RetryLayerPostAcknowledgementStore) Delete(acknowledgement *model.PostAcknowledgement) error {
 
 	tries := 0
@@ -14666,7 +14690,7 @@
 	newStore := RetryLayer{
 		Store: childStore,
 	}
-
+	newStore.PollFieldsStore = &RetryLayerPollFieldsStore{PollFieldsStore: childStore.PollField(), Root: &newStore}
 	newStore.AuditStore = &RetryLayerAuditStore{AuditStore: childStore.Audit(), Root: &newStore}
 	newStore.BotStore = &RetryLayerBotStore{BotStore: childStore.Bot(), Root: &newStore}
 	newStore.ChannelStore = &RetryLayerChannelStore{ChannelStore: childStore.Channel(), Root: &newStore}
Index: mattermost-server-7.8.1/store/sqlstore/cron_chat_store.go
===================================================================
--- mattermost-server-7.8.1/store/sqlstore/cron_chat_store.go	(nonexistent)
+++ mattermost-server-7.8.1/store/sqlstore/cron_chat_store.go	(revision 4485)
@@ -0,0 +1,609 @@
+//Copyright 2021 Ryobi Systems Co., Ltd. All Rights Reserved.
+
+package sqlstore
+
+import (
+	"github.com/mattermost/mattermost-server/v6/einterfaces"
+	"github.com/mattermost/mattermost-server/v6/model"
+	"github.com/mattermost/mattermost-server/v6/shared/mlog"
+	"github.com/mattermost/mattermost-server/v6/store"
+	sq "github.com/mattermost/squirrel"
+	"github.com/robfig/cron"
+	"net/http"
+	"strconv"
+	"time"
+)
+
+type SqlCronChatStore struct {
+	*SqlStore
+	metrics          einterfaces.MetricsInterface
+	cron_settings    sq.SelectBuilder
+	channel_settings sq.SelectBuilder
+	post_fileids     sq.SelectBuilder
+	fileinfo_path    sq.SelectBuilder
+}
+
+func newSqlCronChatStore(sqlStore *SqlStore, metrics einterfaces.MetricsInterface) store.CronChatStore {
+	s := &SqlCronChatStore{
+		SqlStore: sqlStore,
+		metrics:  metrics,
+	}
+	s.cron_settings = s.getQueryBuilder().
+		Select("Id", "CronId", "Spec", "CreateAt", "DeleteAt", "UpdateAt").
+		From("CronSettings")
+	s.channel_settings = s.getQueryBuilder().
+		Select("Id", "CreatorId", "CreateAt", "UpdatorId", "UpdateAt", "ChannelId",
+			"MessagePermission", "MessageTime", "MessageUtil", "FilePermission", "FileTime", "FileUtil").
+		From("ChannelChatSaveSettings")
+	s.post_fileids = s.getQueryBuilder().
+		Select("Id", "FileIds", "UserId").
+		From("Posts")
+	s.fileinfo_path = s.getQueryBuilder().
+		Select("Path").
+		From("FileInfo")
+
+	return s
+}
+
+//func (s SqlCronChatStore) createIndexesIfNotExists() {
+//	s.CreateColumnIfNotExists("CronSettings", "DeleteAt", "bigint(20)", "bigint", "0")
+//
+//	s.CreateIndexIfNotExists("idx_cron_settings_cron_id", "CronSettings", "CronId")
+//	s.CreateIndexIfNotExists("idx_cron_settings_delete_at", "CronSettings", "DeleteAt")
+//	s.CreateIndexIfNotExists("idx_channel_chat_save_settings_cron_id", "ChannelChatSaveSettings", "ChannelId")
+//}
+
+//データ削除バッチのIDを取得
+func (s SqlCronChatStore) GetCronId() ([]*model.CronSettings, *model.AppError) {
+	var cronSetting []*model.CronSettings
+
+	params := map[string]interface{}{}
+	//params["Id"] = "1"
+	where := `DeleteAt = 0`
+	query := s.cron_settings.Where(where, params)
+	queryString, args, err := query.ToSql()
+	if err != nil {
+		return nil, model.NewAppError("SqlCronChatStore.GetCronId.tosql", "store.sql_cron_cron.GetCronId.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+
+	if err := s.GetReplicaX().Select(&cronSetting, queryString, args...); err != nil {
+		return nil, model.NewAppError("SqlCronChatStore.GetCronId", "store.sql_cron_cron.GetCronId.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+
+	return cronSetting, nil
+}
+
+//データ削除バッチの実行時間を追加する
+func (s SqlCronChatStore) SaveCronChatDelete(cronId cron.EntryID, spec string) *model.AppError {
+	//会議を保存
+	query := `
+			INSERT INTO
+				CronSettings
+					(CronId,
+					Spec,
+					CreateAt,
+					UpdateAt)
+			VALUES
+				(?,
+				?,
+				?,
+				?)`
+
+	tx, _ := s.GetMasterX().Begin()
+	if _, err := tx.Exec(query, cronId, spec, time.Now().Unix(), time.Now().Unix()); err != nil {
+		tx.Rollback()
+		mlog.Error(err.Error())
+		return model.NewAppError("SqlCronChatStore.SaveCronChatDelete", "store.sql_cron_chat.SaveCronChatDelete.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	tx.Commit()
+
+	return nil
+}
+
+//データ削除バッチの実行時間を削除する
+func (s SqlCronChatStore) UpdateCronChatDelete(Id int) *model.AppError {
+	query := `
+			UPDATE CronSettings
+			SET DeleteAt = ?
+			WHERE Id = ?
+			`
+
+	tx, _ := s.GetMasterX().Begin()
+	if _, err := tx.Exec(query, time.Now().Unix(), Id); err != nil {
+		tx.Rollback()
+		mlog.Error(err.Error())
+		return model.NewAppError("SqlCronChatStore.UpdateCronChatDelete", "store.sql_cron_chat.UpdateCronChatDelete.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	tx.Commit()
+
+	return nil
+}
+
+//チャンネル設定をchannelIdより取得
+func (s SqlCronChatStore) GetChannelSettingByChannelId(channelId string) ([]*model.ChannelChatSaveSettings, *model.AppError) {
+	var channelSetting []*model.ChannelChatSaveSettings
+
+	params := map[string]interface{}{}
+	params["ChannelId"] = channelId
+	where := `ChannelId = ?`
+	query := s.channel_settings.Where(where, params)
+	queryString, _, err := query.ToSql()
+	if err != nil {
+		return nil, model.NewAppError("SqlCronChatStore.GetChannelSettingByChannelId.tosql", "store.sql_cron_cron.GetChannelSettingByChannelId.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+
+	if err := s.GetReplicaX().Select(&channelSetting, queryString, channelId); err != nil {
+		return nil, model.NewAppError("SqlCronChatStore.GetChannelSettingByChannelId", "store.sql_cron_cron.GetChannelSettingByChannelId.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+
+	return channelSetting, nil
+}
+
+//チャンネル設定を取得
+func (s SqlCronChatStore) GetChannelSettings() ([]*model.ChannelChatSaveSettings, *model.AppError) {
+	var channelSetting []*model.ChannelChatSaveSettings
+	query := s.channel_settings
+	queryString, args, err := query.ToSql()
+	if err != nil {
+		return nil, model.NewAppError("SqlCronChatStore.GetChannelSettings.tosql", "store.sql_cron_cron.GetChannelSettings.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+
+	if err := s.GetReplicaX().Select(&channelSetting, queryString, args...); err != nil {
+		return nil, model.NewAppError("SqlCronChatStore.GetChannelSettings", "store.sql_cron_cron.GetChannelSettings.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+
+	return channelSetting, nil
+}
+
+//　チーム管理者よりチャンネル設定を格納
+func (s SqlCronChatStore) SaveChannelsSetting(channel *model.ChannelChatSaveSettingsFromJson, userId string) *model.AppError {
+	//会議を保存
+	query := `
+			INSERT INTO
+				ChannelChatSaveSettings
+					(CreatorId,
+					CreateAt,
+					UpdatorId,
+					UpdateAt,
+					ChannelId,
+					MessagePermission,
+					MessageTime,
+					MessageUtil,
+					FilePermission,
+					FileTime,
+					FileUtil)
+			VALUES
+				(?,
+				?,
+				?,
+				?,
+				?,
+				?,
+				?,
+				?,
+				?,
+				?,
+				?)`
+
+	tx, _ := s.GetMasterX().Begin()
+	if _, err := tx.Exec(query, userId, time.Now().Unix(), userId, time.Now().Unix(), channel.ChannelId, channel.MessagePermission, channel.MessageTime, channel.MessageUtil, channel.FilePermission, channel.FileTime, channel.FileUtil); err != nil {
+		tx.Rollback()
+		mlog.Error(err.Error())
+		return model.NewAppError("SqlCronChatStore.SaveChannelsSetting", "store.sql_cron_chat.SaveChannelsSetting.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	tx.Commit()
+
+	return nil
+}
+
+//　チーム管理者よりチャンネル設定を更新
+func (s SqlCronChatStore) UpdateChannelsSetting(channel *model.ChannelChatSaveSettingsFromJson, userId string) *model.AppError {
+	query := `
+			UPDATE ChannelChatSaveSettings
+			SET UpdatorId = ?,
+			    UpdateAt = ?,
+			    MessagePermission = ?,
+			    MessageTime = ?,
+			    MessageUtil = ?,
+			    FilePermission = ?,
+			    FileTime = ?,
+			    FileUtil = ?
+			WHERE ChannelId = ?
+			`
+
+	tx, _ := s.GetMasterX().Begin()
+	if _, err := tx.Exec(query, userId, time.Now().Unix(), channel.MessagePermission, channel.MessageTime, channel.MessageUtil, channel.FilePermission, channel.FileTime, channel.FileUtil, channel.ChannelId); err != nil {
+		tx.Rollback()
+		mlog.Error(err.Error())
+		return model.NewAppError("SqlCronChatStore.UpdateChannelsSetting", "store.sql_cron_chat.UpdateChannelsSetting.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	tx.Commit()
+
+	return nil
+}
+
+func (s *SqlCronChatStore) GetChatMessagesByChannelId(channelId string, deleteTime int64) (*model.PostList, *model.AppError) {
+	pl := model.NewPostList()
+
+	var posts []*model.Post
+	query := `
+		SELECT
+			*
+		FROM Posts p
+		WHERE
+			ChannelId = '` + channelId + `'
+			AND CreateAt < '` + strconv.FormatInt(deleteTime, 10) + `'
+			AND FileIds = '[]'
+			OR DeleteAt != 0`
+
+	if err := s.GetReplicaX().Select(&posts, query); err != nil {
+		return nil, model.NewAppError("SqlCronChatStore.DeleteChatMessagesByChannelId", "store.sql_cron_chat.DeleteChatMessagesByChannelId.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	for _, post := range posts {
+		pl.AddPost(post)
+		pl.AddOrder(post.Id)
+	}
+
+	return pl, nil
+}
+
+//channel設定したデータ　且　期間切れのメッセージデータを取得
+func (s SqlCronChatStore) DeleteChatMessagesByChannelId(channelId string, deleteTime int64) *model.AppError {
+	query := `
+			DELETE
+			FROM Posts
+			WHERE ChannelId = '` + channelId + `'
+				AND CreateAt < '` + strconv.FormatInt(deleteTime, 10) + `'
+				AND FileIds = '[]'
+				OR DeleteAt != 0
+			`
+
+	tx, _ := s.GetMasterX().Begin()
+	if _, err := tx.Exec(query); err != nil {
+		tx.Rollback()
+		mlog.Error(err.Error())
+		return model.NewAppError("SqlCronChatStore.DeleteChatMessagesByChannelId", "store.sql_cron_chat.DeleteChatMessagesByChannelId.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	tx.Commit()
+
+	return nil
+}
+
+func (s *SqlCronChatStore) GetChatMessagesOther(channelIds []string, deleteTime int64) (*model.PostList, *model.AppError) {
+	pl := model.NewPostList()
+
+	var posts []*model.Post
+	channelIdsToString := ""
+	for _, channelId := range channelIds {
+		if channelIdsToString == "" {
+			channelIdsToString = channelIdsToString + "'" + channelId + "'"
+		} else {
+			channelIdsToString = channelIdsToString + ",'" + channelId + "'"
+		}
+	}
+	query := `
+		SELECT
+			*
+		FROM Posts p
+		WHERE
+			CreateAt < '` + strconv.FormatInt(deleteTime, 10) + `'
+			AND FileIds = '[]'`
+
+	if len(channelIds) > 0 {
+		query += ` AND ChannelId NOT IN  (` + channelIdsToString + `)OR DeleteAt != 0`
+	} else {
+		query += `OR DeleteAt != 0`
+	}
+	if err := s.GetReplicaX().Select(&posts, query); err != nil {
+		return nil, model.NewAppError("SqlCronChatStore.DeleteChatMessagesOther", "store.sql_cron_chat.DeleteChatMessagesOther.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	for _, post := range posts {
+		pl.AddPost(post)
+		pl.AddOrder(post.Id)
+	}
+
+	return pl, nil
+}
+
+//channel設定以外のデータ　且　期間切れのメッセージデータを削除
+func (s SqlCronChatStore) DeleteChatMessagesOther(channelIds []string, deleteTime int64) *model.AppError {
+	channelIdsToString := ""
+	for _, channelId := range channelIds {
+		if channelIdsToString == "" {
+			channelIdsToString = channelIdsToString + "'" + channelId + "'"
+		} else {
+			channelIdsToString = channelIdsToString + ",'" + channelId + "'"
+		}
+	}
+	query := `
+			DELETE
+			FROM Posts
+			WHERE CreateAt <  '` + strconv.FormatInt(deleteTime, 10) + `'
+				AND FileIds = '[]'
+			`
+	if len(channelIds) > 0 {
+		query += ` AND ChannelId NOT IN (` + channelIdsToString + `) OR DeleteAt != 0`
+	} else {
+		query += `OR DeleteAt != 0`
+	}
+	tx, _ := s.GetMasterX().Begin()
+	if _, err := tx.Exec(query); err != nil {
+		tx.Rollback()
+		mlog.Error(err.Error())
+		return model.NewAppError("SqlCronChatStore.DeleteChatMessagesOther", "store.sql_cron_chat.DeleteChatMessagesOther.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	tx.Commit()
+
+	return nil
+}
+
+func (s *SqlCronChatStore) GetChatMessagesDeleted() (*model.PostList, *model.AppError) {
+	pl := model.NewPostList()
+
+	var posts []*model.Post
+	query := `
+		SELECT
+			*
+		FROM Posts p
+		WHERE
+			FileIds = '[]'
+			AND DeleteAt != 0`
+
+	if err := s.GetReplicaX().Select(&posts, query); err != nil {
+		return nil, model.NewAppError("SqlCronChatStore.DeleteChatMessagesDeleted", "store.sql_cron_chat.DeleteChatMessagesDeleted.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	for _, post := range posts {
+		pl.AddPost(post)
+		pl.AddOrder(post.Id)
+	}
+
+	return pl, nil
+}
+
+func (s *SqlCronChatStore) GetChatFilesDeleted() (*model.PostList, *model.AppError) {
+	pl := model.NewPostList()
+
+	var posts []*model.Post
+	query := `
+		SELECT
+			*
+		FROM Posts p
+		WHERE
+			FileIds != '[]'
+			AND DeleteAt != 0`
+
+	if err := s.GetReplicaX().Select(&posts, query); err != nil {
+		return nil, model.NewAppError("SqlCronChatStore.GetChatFilesDeleted", "store.sql_cron_chat.GetChatFilesDeleted.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	for _, post := range posts {
+		pl.AddPost(post)
+		pl.AddOrder(post.Id)
+	}
+
+	return pl, nil
+}
+
+//ユーザにより削除されたメッセージを削除
+func (s SqlCronChatStore) DeleteChatMessagesDeleted() *model.AppError {
+	query := `
+			DELETE
+			FROM Posts
+			WHERE FileIds = '[]'
+				AND DeleteAt != 0
+			`
+	tx, _ := s.GetMasterX().Begin()
+	if _, err := tx.Exec(query); err != nil {
+		tx.Rollback()
+		mlog.Error(err.Error())
+		return model.NewAppError("SqlCronChatStore.DeleteChatMessagesDeleted", "store.sql_cron_chat.DeleteChatMessagesDeleted.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	tx.Commit()
+
+	return nil
+}
+
+//channel設定したデータ　且　期間切れのファイルデータを取得
+func (s SqlCronChatStore) GetChatFilesByChannelId(channelId string, deleteTime int64) ([]*model.ChatFiles, *model.AppError) {
+	var chatFiles []*model.ChatFiles
+	params := map[string]interface{}{}
+	params["ChannelId"] = channelId
+	params["CreateAt"] = deleteTime
+	where := ` ChannelId = ?
+				AND CreateAt < ?
+				AND FileIds != '[]'
+			`
+	query := s.post_fileids.Where(where, params)
+	queryString, _, err := query.ToSql()
+	if err != nil {
+		return nil, model.NewAppError("SqlCronChatStore.GetChatFilesByChannelId.tosql", "store.sql_cron_cron.GetChatFilesByChannelId.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+
+	if err := s.GetReplicaX().Select(&chatFiles, queryString, channelId, deleteTime); err != nil {
+		return nil, model.NewAppError("SqlCronChatStore.GetChatFilesByChannelId", "store.sql_cron_cron.GetChatFilesByChannelId.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+
+	return chatFiles, nil
+}
+
+//channel設定したデータ　且　期間切れのファイルデータを削除
+func (s SqlCronChatStore) DeleteChatFilesByChannelId(channelId string, deleteTime int64, fileIds []string) *model.AppError {
+	queryPosts := `
+			DELETE
+			FROM Posts
+			WHERE ChannelId = '` + channelId + `'
+				AND CreateAt < '` + strconv.FormatInt(deleteTime, 10) + `'
+				AND FileIds != '[]'
+				OR DeleteAt != 0
+			`
+	tx, _ := s.GetMasterX().Begin()
+	if _, err := tx.Exec(queryPosts); err != nil {
+		tx.Rollback()
+		mlog.Error(err.Error())
+		return model.NewAppError("SqlCronChatStore.DeleteChatFilesByChannelId", "store.sql_cron_chat.queryPosts.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+
+	if len(fileIds) > 0 {
+		fileIdsToString := ""
+		for _, fileId := range fileIds {
+			if fileIdsToString == "" {
+				fileIdsToString = fileIdsToString + "'" + fileId + "'"
+			} else {
+				fileIdsToString = fileIdsToString + ",'" + fileId + "'"
+			}
+		}
+		queryFileInfo := `
+			UPDATE FileInfo
+				SET DeleteAt = ?
+			WHERE Id IN ` + "(" + fileIdsToString + ")"
+		if _, err := tx.Exec(queryFileInfo, time.Now().Unix()*1000); err != nil {
+			tx.Rollback()
+			mlog.Error(err.Error())
+			return model.NewAppError("SqlCronChatStore.DeleteChatFilesByChannelId", "store.sql_cron_chat.queryFileInfo.app_error", nil, err.Error(), http.StatusInternalServerError)
+		}
+	}
+
+	tx.Commit()
+
+	return nil
+}
+
+//channel設定以外のデータ　且　期間切れのファイルデータを取得
+func (s SqlCronChatStore) GetChatFilesOther(channelIds []string, deleteTime int64) ([]*model.ChatFiles, *model.AppError) {
+	var chatFiles []*model.ChatFiles
+	channelIdsToString := ""
+	for _, channelId := range channelIds {
+		if channelIdsToString == "" {
+			channelIdsToString = channelIdsToString + "'" + channelId + "'"
+		} else {
+			channelIdsToString = channelIdsToString + ",'" + channelId + "'"
+		}
+	}
+	where := ` CreateAt < '` + strconv.FormatInt(deleteTime, 10) + `'
+				AND FileIds != '[]'
+			`
+	if len(channelIds) > 0 {
+		where += ` AND ChannelId NOT IN (` + channelIdsToString + `) OR DeleteAt != 0`
+	} else {
+		where += `OR DeleteAt != 0`
+	}
+	query := s.post_fileids.Where(where)
+	queryString, args, err := query.ToSql()
+	if err != nil {
+		return nil, model.NewAppError("SqlCronChatStore.GetChatFilesOther.tosql", "store.sql_cron_cron.GetChatFilesOther.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+
+	if err := s.GetReplicaX().Select(&chatFiles, queryString, args...); err != nil {
+		return nil, model.NewAppError("SqlCronChatStore.GetChatFilesOther", "store.sql_cron_cron.GetChatFilesOther.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+
+	return chatFiles, nil
+}
+
+//channel設定以外のデータ　且　期間切れのファイルデータを削除
+func (s SqlCronChatStore) DeleteChatFilesOther(channelIds []string, deleteTime int64, fileIds []string) *model.AppError {
+	channelIdsToString := ""
+	for _, channelId := range channelIds {
+		if channelIdsToString == "" {
+			channelIdsToString = channelIdsToString + "'" + channelId + "'"
+		} else {
+			channelIdsToString = channelIdsToString + ",'" + channelId + "'"
+		}
+	}
+	queryPosts := `
+			DELETE
+			FROM Posts
+			WHERE CreateAt < '` + strconv.FormatInt(deleteTime, 10) + `'
+				AND FileIds != '[]'
+			`
+
+	if len(channelIds) > 0 {
+		queryPosts += ` AND ChannelId NOT IN (` + channelIdsToString + `) OR DeleteAt != 0`
+	} else {
+		queryPosts += `OR DeleteAt != 0`
+	}
+
+	tx, _ := s.GetMasterX().Begin()
+	if _, err := tx.Exec(queryPosts); err != nil {
+		tx.Rollback()
+		mlog.Error(err.Error())
+		return model.NewAppError("SqlCronChatStore.DeleteChatFilesOther", "store.sql_cron_chat.queryPosts.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+
+	if len(fileIds) > 0 {
+		fileIdsToString := ""
+		for _, fileId := range fileIds {
+			if fileIdsToString == "" {
+				fileIdsToString = fileIdsToString + "'" + fileId + "'"
+			} else {
+				fileIdsToString = fileIdsToString + ",'" + fileId + "'"
+			}
+		}
+		queryFileInfo := `
+			UPDATE FileInfo
+				SET DeleteAt = ?
+			WHERE Id IN ` + "(" + fileIdsToString + ")"
+
+		if _, err := tx.Exec(queryFileInfo, time.Now().Unix()*1000); err != nil {
+			tx.Rollback()
+			mlog.Error(err.Error())
+			return model.NewAppError("SqlCronChatStore.DeleteChatFilesOther", "store.sql_cron_chat.queryFileInfo.app_error", nil, err.Error(), http.StatusInternalServerError)
+		}
+	}
+	tx.Commit()
+
+	return nil
+}
+
+//ユーザにより削除されたファイルを削除
+func (s SqlCronChatStore) DeleteChatFilesDeleted() *model.AppError {
+	query := `
+			DELETE
+			FROM Posts
+			WHERE FileIds != '[]'
+				AND DeleteAt != 0
+			`
+	tx, _ := s.GetMasterX().Begin()
+	if _, err := tx.Exec(query); err != nil {
+		tx.Rollback()
+		mlog.Error(err.Error())
+		return model.NewAppError("SqlCronChatStore.DeleteChatFilesDeleted", "store.sql_cron_chat.DeleteChatFilesDeleted.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	tx.Commit()
+
+	return nil
+}
+
+//論理削除されたデータを取得する
+func (s SqlCronChatStore) GetChatFilesPath() ([]*model.ChatFilesPath, *model.AppError) {
+	var chatFilesPath []*model.ChatFilesPath
+	where := ` DeleteAt != 0 `
+	query := s.fileinfo_path.Where(where)
+	queryString, args, err := query.ToSql()
+	if err != nil {
+		return nil, model.NewAppError("SqlCronChatStore.GetChatFilesPath.tosql", "store.sql_cron_cron.GetChatFilesPath.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+
+	if err := s.GetReplicaX().Select(&chatFilesPath, queryString, args...); err != nil {
+		return nil, model.NewAppError("SqlCronChatStore.GetChatFilesPath", "store.sql_cron_cron.GetChatFilesPath.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+
+	return chatFilesPath, nil
+}
+
+//論理削除されたデータを削除する
+func (s SqlCronChatStore) DeleteFileInfos() *model.AppError {
+	query := `
+			DELETE
+			FROM FileInfo
+			WHERE DeleteAt != 0
+			`
+	tx, _ := s.GetMasterX().Begin()
+	if _, err := tx.Exec(query); err != nil {
+		tx.Rollback()
+		mlog.Error(err.Error())
+		return model.NewAppError("SqlCronChatStore.DeleteFileInfos", "store.sql_cron_chat.DeleteFileInfos.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	tx.Commit()
+
+	return nil
+}
Index: mattermost-server-7.8.1/store/sqlstore/file_info_store.go
===================================================================
--- mattermost-server-7.8.1/store/sqlstore/file_info_store.go	(revision 4484)
+++ mattermost-server-7.8.1/store/sqlstore/file_info_store.go	(revision 4485)
@@ -115,7 +115,11 @@
 	if err := info.IsValid(); err != nil {
 		return nil, err
 	}
-
+	/* Ryobi Systems CloudOffice Files Mod 20211103 START */
+	if info.IsImage() {
+		info.HasPreviewImage = false
+	}
+	/* Ryobi Systems CloudOffice Files Mod 20211103 END */
 	query := `
 		INSERT INTO FileInfo
 		(Id, CreatorId, PostId, CreateAt, UpdateAt, DeleteAt, Path, ThumbnailPath, PreviewPath,
@@ -799,3 +803,19 @@
 
 	return createAt, nil
 }
+
+func (fs SqlFileInfoStore) GetFileTotalSize() (int64, error) {
+	var size int64
+
+	query := fs.getQueryBuilder().
+		Select("SUM(Size)").
+		From("FileInfo").
+		Where("DeleteAt = 0")
+	
+	
+	err := fs.GetReplicaX().GetBuilder(&size, query)
+	if err != nil {
+		return int64(0), errors.Wrap(err, "failed to get storage usage")
+	}
+	return size, nil
+}
Index: mattermost-server-7.8.1/store/sqlstore/meeting_store.go
===================================================================
--- mattermost-server-7.8.1/store/sqlstore/meeting_store.go	(nonexistent)
+++ mattermost-server-7.8.1/store/sqlstore/meeting_store.go	(revision 4485)
@@ -0,0 +1,417 @@
+//Copyright 2021 Ryobi Systems Co., Ltd. All Rights Reserved.
+
+package sqlstore
+
+import (
+	"github.com/mattermost/mattermost-server/v6/einterfaces"
+	"net/http"
+	"strconv"
+	"strings"
+	"time"
+
+	"github.com/mattermost/mattermost-server/v6/model"
+	"github.com/mattermost/mattermost-server/v6/shared/mlog"
+	"github.com/mattermost/mattermost-server/v6/store"
+	"github.com/xtgo/uuid"
+)
+
+type SqlMeetingStore struct {
+	*SqlStore
+	metrics einterfaces.MetricsInterface
+}
+
+func newSqlMeetingStore(sqlStore *SqlStore, metrics einterfaces.MetricsInterface) store.MeetingStore {
+	s := &SqlMeetingStore{
+		SqlStore: sqlStore,
+		metrics:  metrics,
+	}
+
+	return s
+}
+
+//会議を保存
+func (s SqlMeetingStore) Save(meeting *model.Meeting, users []*model.MeetingUserFromJson, userValid string) ([]*model.MeetingUser, string, *model.AppError) {
+	var meetingUsers []*model.MeetingUser
+	meetingItemId := getUniqueId()
+	startAt := strconv.FormatInt(meeting.StartAt, 10)
+	endAt := strconv.FormatInt(meeting.EndAt, 10)
+	createAt := strconv.FormatInt(time.Now().UTC().Unix(), 10)
+
+	//会議を保存
+	query := `
+			INSERT INTO
+				Meetings
+			(meetingItemId,itemValid,meetingName,meetingId,startAt,endAt,timeZone,hostId,hostName,createAt,isRepeat,repeatConfig,repeatEndDate,iCalUID)
+			VALUES
+			(?,?,?,?,?,?,?,?,?,?,?,?,?,?)`
+
+	tx, _ := s.GetMasterX().Begin()
+	if _, err := tx.Exec(query, meetingItemId, "1", meeting.MeetingName, meeting.MeetingId, startAt, endAt, meeting.TimeZone, meeting.HostId, meeting.HostName, createAt, meeting.IsRepeat, meeting.RepeatConfig, meeting.RepeatEndDate, meeting.ICalUID); err != nil {
+		tx.Rollback()
+		mlog.Error(err.Error())
+		return nil, meetingItemId, model.NewAppError("SqlMeetingStore.Save", "store.sql_meeting.save_meeting.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	tx.Commit()
+
+	//招待者を保存
+	if len(users) != 0 {
+		var ItemId string
+		queryU := "INSERT INTO MeetingUsers VALUES "
+
+		for _, user := range users {
+			ItemId = getUniqueId()
+			queryU += "('" + ItemId + "', " + userValid + ", '" + meetingItemId + "', '" + user.UserId + "', '" + replaceSpecialChar(user.UserMail) + "'),"
+
+			var meetingUser model.MeetingUser
+			meetingUser.ItemId = ItemId
+			meetingUser.MeetingItemId = meetingItemId
+			meetingUser.UserId = user.UserId
+			meetingUser.UserMail = user.UserMail
+			meetingUsers = append(meetingUsers, &meetingUser)
+		}
+
+		queryU = strings.TrimRight(queryU, ",")
+		txU, _ := s.GetMasterX().Begin()
+		if _, err := txU.Exec(queryU); err != nil {
+			txU.Rollback()
+			mlog.Error(err.Error())
+			return nil, meetingItemId, model.NewAppError("SqlMeetingStore.Save", "store.sql_meeting.save_users.app_error", nil, err.Error(), http.StatusInternalServerError)
+		}
+		txU.Commit()
+	}
+
+	return meetingUsers, meetingItemId, nil
+}
+
+//会議を更新
+func (s SqlMeetingStore) Update(meeting *model.Meeting, users []*model.MeetingUserFromJson) *model.AppError {
+	meetingItemId := meeting.MeetingItemId
+	startAt := strconv.FormatInt(meeting.StartAt, 10)
+	endAt := strconv.FormatInt(meeting.EndAt, 10)
+
+	//会議を更新
+	query := `
+			UPDATE
+				Meetings
+			SET
+				MeetingName = ?,
+				MeetingId = ?,
+				StartAt = ?,
+				EndAt = ?,
+				TimeZone = ?,
+				HostId = ?,
+				HostName = ?,
+				IsRepeat = ?,
+				RepeatConfig = ?,
+				RepeatEndDate = ?
+			WHERE
+				MeetingItemId = ?
+			AND
+				ItemValid = 1`
+
+	tx, _ := s.GetMasterX().Begin()
+	if _, err := tx.Exec(query, meeting.MeetingName, meeting.MeetingId, startAt, endAt, meeting.TimeZone, meeting.HostId, meeting.HostName, meeting.IsRepeat, meeting.RepeatConfig, meeting.RepeatEndDate, meetingItemId); err != nil {
+		tx.Rollback()
+		mlog.Error(err.Error())
+		return model.NewAppError("SqlMeetingStore.Update", "store.sql_meeting.update_meeting.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	tx.Commit()
+
+	//招待者を削除
+	queryD := `
+			DELETE MeetingUsers
+			FROM MeetingUsers
+			WHERE MeetingItemId = ?`
+	txD, _ := s.GetMasterX().Begin()
+
+	if _, err := txD.Exec(queryD, meetingItemId); err != nil {
+		txD.Rollback()
+		mlog.Error(err.Error())
+		return model.NewAppError("SqlMeetingStore.Update", "store.sql_meeting.update_users.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	txD.Commit()
+
+	//招待者を保存
+	if len(users) != 0 {
+		var ItemId string
+		queryU := "INSERT INTO MeetingUsers VALUES "
+		insertCount := 0
+
+		for _, user := range users {
+			ItemId = getUniqueId()
+			queryU += "('" + ItemId + "', 1, '" + meetingItemId + "', '" + user.UserId + "', '" + replaceSpecialChar(user.UserMail) + "'),"
+			insertCount++
+		}
+
+		if insertCount != 0 {
+			queryU = strings.TrimRight(queryU, ",")
+			txU, _ := s.GetMasterX().Begin()
+
+			if _, err := txU.Exec(queryU); err != nil {
+				txU.Rollback()
+				mlog.Error(err.Error())
+				return model.NewAppError("SqlMeetingStore.Update", "store.sql_meeting.update_users.app_error", nil, err.Error(), http.StatusInternalServerError)
+			}
+			txU.Commit()
+		}
+	}
+
+	return nil
+}
+
+//招待者の有効に更新
+func (s SqlMeetingStore) UpdateValidMeetingUsers(meetingItemId string, mailAddrs []string, itemValid int) *model.AppError {
+	var mailAddrsString string
+	itemValidString := strconv.Itoa(itemValid)
+
+	if len(mailAddrs) != 0 {
+		for _, mailAddr := range mailAddrs {
+			mailAddrsString += ("'" + replaceSpecialChar(mailAddr) + "'" + ",")
+		}
+		mailAddrsString = strings.TrimRight(mailAddrsString, ",")
+		query := `
+				UPDATE MeetingUsers SET ItemValid = ` + itemValidString + `
+				WHERE UserMail IN (` + mailAddrsString + `)
+				AND MeetingItemId = '` + meetingItemId + `'`
+		tx, _ := s.GetMasterX().Begin()
+		if _, err := tx.Exec(query); err != nil {
+			tx.Rollback()
+			mlog.Error(err.Error())
+			return model.NewAppError("SqlMeetingStore.UpdateValidMeetingUsers", "store.sql_meeting.update_valid_meeting_users.app_error", nil, err.Error(), http.StatusInternalServerError)
+		}
+		tx.Commit()
+	}
+	return nil
+}
+
+//sql文で使用する場合、サポートされていないメールの特殊文字を置換
+func replaceSpecialChar(mailAddr string) string {
+	return strings.Replace(mailAddr, "'", "''", -1)
+}
+
+//主キー
+func getUniqueId() string {
+	return strings.Replace(uuid.NewRandom().String(), "-", "", -1) + strconv.FormatInt(time.Now().UTC().UnixNano(), 10)
+}
+
+//会議項目IDを使って、会議情報を取得
+func (s SqlMeetingStore) GetMeetingByMeetingItemId(meetingItemId string) (*model.Meeting, *model.AppError) {
+	var meeting []*model.Meeting
+
+	query := `
+			SELECT *
+			FROM Meetings
+			WHERE MeetingItemId = '` + meetingItemId + `'
+			AND ItemValid = 1`
+
+	err := s.GetReplicaX().Select(&meeting, query)
+	if err != nil {
+		mlog.Error(err.Error())
+		return nil, model.NewAppError("SqlMeetingStore.GetMeetingByMeetingItemId", "store.sql_meeting.get_meeting_by_meetingItemId.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+
+	if len(meeting) == 0 {
+		return nil, nil
+	} else {
+		return meeting[0], nil
+	}
+}
+
+/* Ryobi Systems CloudOffice Meeting Mod 予約一覧表示改善 20210506 START */
+//ユーザーIDを使って、会議情報を取得
+func (s SqlMeetingStore) GetMeetingsByUserId(userId string, meetingAfter string, meetingBefore string) ([]*model.Meeting, *model.AppError) {
+	var meetings []*model.Meeting
+	query := `
+			SELECT *
+			FROM Meetings
+			WHERE
+				(
+					MeetingItemId IN (SELECT MeetingItemId FROM MeetingUsers WHERE UserId = '` + userId + `' AND ItemValid = 1)
+					OR HostId = '` + userId + `'
+				)
+			AND ItemValid = 1
+			AND (
+					(
+						EndAt > ` + meetingAfter + `
+						AND StartAt < ` + meetingBefore + `
+						AND IsRepeat = 0
+					)
+					OR
+					(
+						IsRepeat = 1
+						AND StartAt < ` + meetingBefore + `
+						AND (
+								RepeatEndDate > ` + meetingAfter + `
+								OR RepeatEndDate = 0
+							)
+					)
+				)
+			ORDER BY StartAt`
+
+	err := s.GetReplicaX().Select(&meetings, query)
+	if err != nil {
+		mlog.Error(err.Error())
+		return nil, model.NewAppError("SqlMeetingStore.GetMeetingsByUserId", "store.sql_meeting.get_meetings_by_userId.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	return meetings, nil
+}
+
+/* Ryobi Systems CloudOffice Meeting Mod 予約一覧表示改善 20210506 START */
+
+//除外された単条重複会議情報を取得
+func (s SqlMeetingStore) GetDeletedMeetingInfoByMeetingItemIds(meetingItemIds []string) ([]*model.DeleteParamsToJson, *model.AppError) {
+	var meetingInfos []*model.DeleteParamsToJson
+	var meetingItemIdsString string
+
+	if len(meetingItemIds) != 0 {
+		for _, meetingItemId := range meetingItemIds {
+			meetingItemIdsString += ("'" + meetingItemId + "'" + ",")
+		}
+		meetingItemIdsString = strings.TrimRight(meetingItemIdsString, ",")
+
+		query := `
+			SELECT MeetingItemId, StartAt, EndAt
+			FROM DeletedSingleRepeatMeetings
+			WHERE MeetingItemId IN (` + meetingItemIdsString + `)`
+
+		err := s.GetReplicaX().Select(&meetingInfos, query)
+		if err != nil {
+			mlog.Error(err.Error())
+			return nil, model.NewAppError("SqlMeetingStore.GetDeletedMeetingInfoByMeetingItemIds", "store.sql_meeting.get_deleted_meetingInfo_by_meetingItemId.app_error", nil, err.Error(), http.StatusInternalServerError)
+		}
+	}
+	return meetingInfos, nil
+}
+
+//会議項目IDを使って、会議ユーザー情報を取得
+func (s SqlMeetingStore) GetMeetingUsersByMeetingItemIds(meetingItemIds []string) ([]*model.MeetingUser, *model.AppError) {
+	var meetingUsers []*model.MeetingUser
+	var meetingItemIdsString string
+
+	if len(meetingItemIds) != 0 {
+		for _, meetingItemId := range meetingItemIds {
+			meetingItemIdsString += ("'" + meetingItemId + "'" + ",")
+		}
+		meetingItemIdsString = strings.TrimRight(meetingItemIdsString, ",")
+		query := `
+				SELECT *
+				FROM MeetingUsers
+				WHERE MeetingItemId IN (` + meetingItemIdsString + `)
+				AND ItemValid = 1`
+		err := s.GetReplicaX().Select(&meetingUsers, query)
+		if err != nil {
+			mlog.Error(err.Error())
+			return nil, model.NewAppError("SqlMeetingStore.GetMeetingUsersByMeetingItemIds", "store.sql_meeting.get_meeting_users_by_meetingItemIds.app_error", nil, err.Error(), http.StatusInternalServerError)
+		}
+	}
+	return meetingUsers, nil
+}
+
+//会議情報を削除
+func (s SqlMeetingStore) PermanentDelete(meetingItemId string) *model.AppError {
+	query := `
+			DELETE
+			FROM Meetings
+			WHERE MeetingItemId = '` + meetingItemId + `'`
+
+	tx, _ := s.GetMasterX().Begin()
+	if _, err := tx.Exec(query); err != nil {
+		tx.Rollback()
+		mlog.Error(err.Error())
+		return model.NewAppError("SqlMeetingStore.PermanentDelete", "store.sql_meeting.permanent_delete_meeting.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	tx.Commit()
+
+	queryD := `
+			DELETE
+			FROM MeetingUsers
+			WHERE MeetingItemId = '` + meetingItemId + `'`
+
+	txD, _ := s.GetMasterX().Begin()
+	if _, err := txD.Exec(queryD); err != nil {
+		txD.Rollback()
+		mlog.Error(err.Error())
+		return model.NewAppError("SqlMeetingStore.PermanentDelete", "store.sql_meeting.permanent_delete_user.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	txD.Commit()
+
+	queryR := `
+			DELETE
+			FROM DeletedSingleRepeatMeetings
+			WHERE MeetingItemId = '` + meetingItemId + `'`
+
+	txR, _ := s.GetMasterX().Begin()
+	if _, err := txR.Exec(queryR); err != nil {
+		txR.Rollback()
+		mlog.Error(err.Error())
+		return model.NewAppError("SqlMeetingStore.PermanentDelete", "store.sql_meeting.permanent_delete_deleted_single_repeat_meeting.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	txR.Commit()
+
+	return nil
+}
+
+//会議重複情報を更新
+func (s SqlMeetingStore) UpdateMeetingRepeatEndDate(meeting *model.Meeting) *model.AppError {
+	query := `
+			UPDATE
+				Meetings
+			SET
+				RepeatEndDate=?
+			WHERE
+				MeetingItemId=?
+			AND
+				ItemValid = 1`
+
+	tx, _ := s.GetMasterX().Begin()
+
+	if _, err := tx.Exec(query, meeting.RepeatEndDate, meeting.MeetingItemId); err != nil {
+		tx.Rollback()
+		mlog.Error(err.Error())
+		return model.NewAppError("SqlMeetingStore.UpdateMeetingRepeatEndDate", "store.sql_meeting.update_meeting_repeat_end_date.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	tx.Commit()
+
+	return nil
+}
+
+//除外された単条重複会議情報を保存
+func (s SqlMeetingStore) SaveDelRepeatMeeting(meeting *model.Meeting, delParams *model.DeleteParamsFromJson) *model.AppError {
+	//会議を保存
+	query := `
+			INSERT INTO
+				DeletedSingleRepeatMeetings
+			(itemId,meetingItemId,startAt,endAt)
+			VALUES
+			(?,?,?,?)`
+
+	tx, _ := s.GetMasterX().Begin()
+	if _, err := tx.Exec(query, getUniqueId(), meeting.MeetingItemId, delParams.StartAt, delParams.EndAt); err != nil {
+		tx.Rollback()
+		mlog.Error(err.Error())
+		return model.NewAppError("SqlMeetingStore.SaveDelRepeatMeeting", "store.sql_meeting.save_del_repeat_meeting.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	tx.Commit()
+
+	return nil
+}
+
+//除外された単条重複会議情報を削除
+func (s SqlMeetingStore) RemoveDelRepeatMeetingAfterNow(meetingItemId string, timeStamp int64) *model.AppError {
+	query := `
+			DELETE
+			FROM DeletedSingleRepeatMeetings
+			WHERE MeetingItemId = '` + meetingItemId + `'
+			AND StartAt > ` + strconv.FormatInt(timeStamp, 10) + `
+			`
+
+	tx, _ := s.GetMasterX().Begin()
+	if _, err := tx.Exec(query); err != nil {
+		tx.Rollback()
+		mlog.Error(err.Error())
+		return model.NewAppError("SqlMeetingStore.RemoveDelRepeatMeetingAfterNow", "store.sql_meeting.remove_del_repeat_meeting_after_now.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	tx.Commit()
+
+	return nil
+}
Index: mattermost-server-7.8.1/store/sqlstore/meetingmng_store.go
===================================================================
--- mattermost-server-7.8.1/store/sqlstore/meetingmng_store.go	(nonexistent)
+++ mattermost-server-7.8.1/store/sqlstore/meetingmng_store.go	(revision 4485)
@@ -0,0 +1,375 @@
+//Copyright 2021 Ryobi Systems Co., Ltd. All Rights Reserved.
+
+package sqlstore
+
+import (
+	"encoding/json"
+	"github.com/mattermost/mattermost-server/v6/einterfaces"
+	"github.com/mattermost/mattermost-server/v6/model"
+	"github.com/mattermost/mattermost-server/v6/shared/mlog"
+	"github.com/mattermost/mattermost-server/v6/store"
+	sq "github.com/mattermost/squirrel"
+	"net/http"
+	"time"
+)
+
+type SqlMeetingMngStore struct {
+	*SqlStore
+	metrics                     einterfaces.MetricsInterface
+	meetings                    sq.SelectBuilder
+	meetingUsers_Users          sq.SelectBuilder
+	meetings_Users_MeetingUsers sq.SelectBuilder
+	users                       sq.SelectBuilder
+	meetings_MeetingEnd         sq.SelectBuilder
+	meetingEndUsers_users       sq.SelectBuilder
+}
+
+func newSqlMeetingMngStore(sqlStore *SqlStore, metrics einterfaces.MetricsInterface) store.MeetingMngStore {
+	s := &SqlMeetingMngStore{
+		SqlStore: sqlStore,
+		metrics:  metrics,
+	}
+	s.meetings = s.getQueryBuilder().
+		Select("MeetingItemId", "ItemValid", "MeetingName", "lower(MeetingId) AS MeetingId", "StartAt", "EndAt", "TimeZone",
+			"HostId", "HostName", "CreateAt", "IFNULL(IsRepeat, false) as IsRepeat", "IFNULL(RepeatConfig, '') as RepeatConfig", "IFNULL(RepeatEndDate, 0) as RepeatEndDate").
+		From("Meetings")
+	s.meetingUsers_Users = s.getQueryBuilder().
+		Select("mu.ItemId", "mu.ItemValid", "mu.MeetingItemId", "mu.UserId", "mu.UserMail",
+			"IFNULL(uu.Username, '') as UserName", "IFNULL(uu.Nickname, '') as NickName", "IFNULL(uu.FirstName, '') as FirstName", "IFNULL(uu.LastName, '') as LastName", "'user' as UserType").
+		From("MeetingUsers mu").
+		LeftJoin("Users uu ON ( uu.Id = mu.UserId )")
+	s.meetings_Users_MeetingUsers = s.getQueryBuilder().
+		Select("m.MeetingItemId", "m.ItemValid", "m.MeetingName", "lower(m.MeetingId) AS MeetingId", "m.StartAt", "m.EndAt", "m.TimeZone",
+			"m.HostId", "m.HostName", "m.CreateAt", "IFNULL(m.IsRepeat, false) as IsRepeat", "IFNULL(m.RepeatConfig, '') as RepeatConfig", "IFNULL(m.RepeatEndDate, 0) as RepeatEndDate",
+			"IFNULL(us.Username, '') as UserName", "IFNULL(us.FirstName, '') as FirstName", "IFNULL(us.LastName, '') as LastName", "COUNT(CASE WHEN u.UserId IS NOT NULL THEN m.MeetingItemId END)+1  AS UserCount",
+			"IFNULL(MAX(me.MeetingStartTime), 0) as MeetingStartTime", "IFNULL(MAX(me.SumMemberCount), 0) as SumMemberCount", "IFNULL(MAX(me.UserMail), '') as UserMail", "IFNULL(MAX(me.MeetingEndTime), 0) as MeetingEndTime").
+		From("Meetings m").
+		LeftJoin("Users us ON ( us.Id = m.HostId )").
+		LeftJoin("MeetingUsers u ON ( u.MeetingItemId = m.MeetingItemId AND u.ItemValid = 1 )").
+		LeftJoin("(SELECT MeetingItemId, MAX(MeetingStartTime) as maxTime FROM MeetingsEnd GROUP BY MeetingItemId ) mx ON ( mx.MeetingItemId = m.MeetingId )").
+		LeftJoin("MeetingsEnd me ON ( me.MeetingItemId = m.MeetingId AND me.MeetingStartTime = mx.maxTime )")
+	s.users = s.getQueryBuilder().
+		Select("Id", "IFNULL(Username, '') as UserName", "Email",
+			"IFNULL(Nickname, '') as NickName", "IFNULL(FirstName, '') as FirstName", "IFNULL(LastName, '') as LastName").
+		From("Users")
+	s.meetings_MeetingEnd = s.getQueryBuilder().
+		Select("m.MeetingItemId", "m.ItemValid", "m.MeetingName", "lower(m.MeetingId) AS MeetingId", "m.StartAt", "m.EndAt", "m.TimeZone",
+			"m.HostId", "m.HostName", "m.CreateAt", "IFNULL(m.IsRepeat, false) as IsRepeat", "IFNULL(m.RepeatConfig, '') as RepeatConfig", "IFNULL(m.RepeatEndDate, 0) as RepeatEndDate",
+			"IFNULL(me.MeetingStartTime, 0) as MeetingStartTime", "IFNULL(me.SumMemberCount, 0) as SumMemberCount", "IFNULL(me.UserMail, '') as UserMail", "IFNULL(me.MeetingEndTime, 0) as MeetingEndTime").
+		From("Meetings m").
+		LeftJoin("(SELECT MeetingItemId, MAX(MeetingStartTime) as maxTime FROM MeetingsEnd GROUP BY MeetingItemId ) mx ON ( mx.MeetingItemId = m.MeetingId )").
+		LeftJoin("MeetingsEnd me ON ( me.MeetingItemId = m.MeetingId AND me.MeetingStartTime = mx.maxTime )")
+	s.meetingEndUsers_users = s.getQueryBuilder().
+		Select("mu.MeetingItemId", "mu.MeetingStartTime", "mu.UserMail", "mu.Owner", "mu.RemoteIp", "mu.LocalIp", "mu.StartTime", "mu.EndTime",
+			"IFNULL(Username, '') as UserName", "IFNULL(FirstName, '') as FirstName", "IFNULL(LastName, '') as LastName").
+		From("MeetingEndUsers mu").
+		LeftJoin("Users us ON ( us.Email = mu.UserMail )")
+
+	return s
+}
+
+//func (s SqlMeetingMngStore) createIndexesIfNotExists() {
+//	s.CreateIndexIfNotExists("idx_meeting_end_meetingitem_id", "MeetingsEnd", "MeetingItemId")
+//	s.CreateIndexIfNotExists("idx_meeting_end_meetingitem_starttime", "MeetingsEnd", "MeetingStartTime")
+//	s.CreateIndexIfNotExists("idx_meeting_end_user_meetingitem_id", "MeetingEndUsers", "MeetingItemId")
+//	s.CreateIndexIfNotExists("idx_meeting_end_user_meetingitem_starttime", "MeetingEndUsers", "MeetingStartTime")
+//	s.CreateIndexIfNotExists("idx_meeting_end_user_user_mail", "MeetingEndUsers", "UserMail")
+//}
+
+//会議項目IDを使って、会議情報を取得
+func (s SqlMeetingMngStore) GetMeetingMngList(meeting *model.MeetingMngFromJson) ([]*model.MeetingMngUserCount, *model.AppError) {
+	var meetingMng []*model.MeetingMngUserCount
+
+	timeLayout := "2006-01-02 15:04:05"  //テンプレート
+	loc, _ := time.LoadLocation("Local") //タイムゾン取得
+	startTmp, _ := time.ParseInLocation(timeLayout, meeting.StartDate+" 00:00:00", loc)
+	startTime := startTmp.Unix() * 1000
+	endTmp, _ := time.ParseInLocation(timeLayout, meeting.EndDate+" 23:59:59", loc)
+	endTime := endTmp.Unix() * 1000
+	params := map[string]interface{}{}
+	params["StartDate"] = startTime
+	params["EndDate"] = endTime
+	params["MeetingName"] = "%" + meeting.MeetingName + "%"
+	params["ItemValid"] = 1
+	where := `
+		((m.StartAt >= ? AND m.StartAt <= ?)
+			OR (m.RepeatEndDate >= ? AND m.RepeatEndDate <= ?)
+			OR (m.StartAt <= ? AND m.RepeatEndDate >= ?)
+			OR (m.StartAt <= ? AND m.RepeatEndDate = 0 AND IsRepeat = 1))
+		AND m.MeetingName like ?
+		AND m.ItemValid = ?`
+	query := s.meetings_Users_MeetingUsers.Where(where, params).GroupBy("m.MeetingItemId")
+	queryString, _, err := query.ToSql()
+	if err != nil {
+		return nil, model.NewAppError("SqlMeetingMngStore.meetings.tosql", "store.sql_meeting_mng_list.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+
+	if err := s.GetReplicaX().Select(&meetingMng, queryString, startTime, endTime, startTime, endTime, startTime, endTime, startTime, "%"+meeting.MeetingName+"%", 1); err != nil {
+		return nil, model.NewAppError("SqlMeetingMngStore.meetings", "store.sql_meeting_mng_list.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	return meetingMng, nil
+}
+
+//会議項目IDを使って、会議情報を取得
+func (s SqlMeetingMngStore) GetMeetingMngEndByMeetingItemId(MeetingItemId string) (*model.MeetingsMeetingEnd, *model.AppError) {
+	var meetingall []*model.MeetingsMeetingEnd
+	query := s.meetings_MeetingEnd.Where("m.MeetingItemId = ? AND m.ItemValid = ?  ", MeetingItemId, 1)
+	queryString, args, err := query.ToSql()
+	if err != nil {
+		return nil, model.NewAppError("SqlMeetingMngStore.meetings_MeetingEnd", "store.sql_meeting_mng.get.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	if err := s.GetReplicaX().Select(&meetingall, queryString, args...); err != nil {
+		return nil, model.NewAppError("SqlMeetingMngStore.meetings_MeetingEnd", "store.sql_meeting_mng.get.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	return meetingall[0], nil
+}
+
+//会議項目IDを使って、会議参加ユーザを取得
+func (s SqlMeetingMngStore) GetMeetingMngUsersByMeetingItemId(MeetingItemId string) ([]*model.MeetingMngUser, *model.AppError) {
+	var meetingUsers []*model.MeetingMngUser
+
+	query := s.meetingUsers_Users.Where("mu.MeetingItemId = ? AND mu.ItemValid = ? ", MeetingItemId, 1)
+	queryString, args, err := query.ToSql()
+	if err != nil {
+		return nil, model.NewAppError("SqlMeetingMngStore.meetingUsers_Users", "store.sql_meeting_mng.get.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	if err := s.GetReplicaX().Select(&meetingUsers, queryString, args...); err != nil {
+		return nil, model.NewAppError("SqlMeetingMngStore.meetingUsers_Users", "store.sql_meeting_mng.get.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	return meetingUsers, nil
+}
+
+//会議項目IDを使って、会議参加ユーザを取得
+func (s SqlMeetingMngStore) GetUsersByUserMails(UserList []string) ([]*model.MeetUser, *model.AppError) {
+	var meetUsers []*model.MeetUser
+	usersString := ""
+	for _, userMail := range UserList {
+		if usersString == "" {
+			usersString = usersString + "'" + userMail + "'"
+		} else {
+			usersString = usersString + ",'" + userMail + "'"
+		}
+	}
+
+	query := s.users.Where("Email in (" + usersString + ")")
+	queryString, args, err := query.ToSql()
+	if err != nil {
+		return nil, model.NewAppError("SqlMeetingMngStore.users", "store.sql_meeting_mng.get.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	if err := s.GetReplicaX().Select(&meetUsers, queryString, args...); err != nil {
+		return nil, model.NewAppError("SqlMeetingMngStore.users", "store.sql_meeting_mng.get.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	return meetUsers, nil
+}
+
+//会議項目IDを使って、会議参加ユーザを取得
+func (s SqlMeetingMngStore) GetMeetingMngsByMeetingItemId(meetingItemId string) (*model.MeetingMng, *model.AppError) {
+	var meetingMng []*model.MeetingMng
+	query := s.meetings.Where("MeetingItemId = '" + meetingItemId + "'")
+	queryString, args, err := query.ToSql()
+	if err != nil {
+		return nil, model.NewAppError("SqlMeetingMngStore.meetings", "store.sql_meeting_mng.get.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	if err := s.GetReplicaX().Select(&meetingMng, queryString, args...); err != nil {
+		return nil, model.NewAppError("SqlMeetingMngStore.meetings", "store.sql_meeting_mng.get.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	if len(meetingMng) == 0 {
+		return nil, nil
+	}
+	return meetingMng[0], nil
+}
+
+//会議項目IDを使って、会議参加ユーザを取得
+func (s SqlMeetingMngStore) GetMeetingEndUsers(meetingId string, meetingStartTime int64) ([]*model.MeetingMngUserToJson, *model.AppError) {
+	var meetingMng []*model.MeetingMngUserToJson
+
+	params := map[string]interface{}{}
+	params["MeetingItemId"] = meetingId
+	params["MeetingStartTime"] = meetingStartTime
+	where := `
+		mu.MeetingItemId = ?
+		AND mu.MeetingStartTime = ?`
+	query := s.meetingEndUsers_users.Where(where, params)
+
+	queryString, _, err := query.ToSql()
+	if err != nil {
+		return nil, model.NewAppError("SqlMeetingMngStore.meetings", "store.sql_meeting_mng.get.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	if err := s.GetReplicaX().Select(&meetingMng, queryString, meetingId, meetingStartTime); err != nil {
+		return nil, model.NewAppError("SqlMeetingMngStore.meetings", "store.sql_meeting_mng.get.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	return meetingMng, nil
+}
+func (s SqlMeetingMngStore) DeleteMeetingMngByMeetingItemId(meetingItemId string) *model.AppError {
+	query := `
+			DELETE
+			FROM Meetings
+			WHERE MeetingItemId = '` + meetingItemId + `'
+			`
+
+	tx, _ := s.GetMasterX().Begin()
+	if _, err := tx.Exec(query); err != nil {
+		tx.Rollback()
+		mlog.Error(err.Error())
+		return model.NewAppError("SqlMeetingMngStore.DeleteMeetingMngByMeetingItemIds", "store.sql_meeting.DeleteMeetingMngByMeetingItemIds.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	tx.Commit()
+
+	return nil
+}
+func (s SqlMeetingMngStore) UpdateMeetingMngByMeetingItemId(meetingItemId string, endTime string) *model.AppError {
+	query := `
+			UPDATE Meetings
+			SET RepeatEndDate = '` + endTime + `'
+			WHERE MeetingItemId = '` + meetingItemId + `'
+			`
+
+	tx, _ := s.GetMasterX().Begin()
+	if _, err := tx.Exec(query); err != nil {
+		tx.Rollback()
+		mlog.Error(err.Error())
+		return model.NewAppError("SqlMeetingMngStore.UpdateMeetingMngByMeetingItemId", "store.sql_meeting.UpdateMeetingMngByMeetingItemId.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	tx.Commit()
+
+	return nil
+}
+
+//会議項目IDを使って、会議ユーザー情報を取得
+func (s SqlMeetingMngStore) GetMeetingMngUsersByMeetingItemIdFormail(meetingItemId string) ([]*model.MeetingMngUser, *model.AppError) {
+	var meetingMngUser []*model.MeetingMngUser
+
+	query := `
+				SELECT mu.*,
+						IFNULL(uu.Username, '') as Username,
+						IFNULL(uu.Nickname, '') as Nickname,
+						IFNULL(uu.FirstName, '') as FirstName,
+						IFNULL(uu.LastName, '') as LastName,
+						'user' as UserType
+				FROM MeetingUsers mu
+				LEFT JOIN Users uu ON mu.UserId = uu.Id
+				WHERE MeetingItemId = '` + meetingItemId + `'
+				AND ItemValid = 1
+				UNION ALL
+				SELECT '0' as ItemId,'0' as ItemValid, m.MeetingItemId, m.HostId as UserId, u.Email as UserMail,
+						IFNULL(u.Username, '') as Username,
+						IFNULL(u.Nickname, '') as Nickname,
+						IFNULL(u.FirstName, '') as FirstName,
+						IFNULL(u.LastName, '') as LastName,
+						'host' as UserType
+				FROM Meetings m
+				LEFT JOIN Users u ON m.HostId = u.Id
+				WHERE MeetingItemId = '` + meetingItemId + `'
+				AND ItemValid = 1`
+	err := s.GetReplicaX().Select(&meetingMngUser, query)
+	if err != nil {
+		mlog.Error(err.Error())
+		return nil, model.NewAppError("SqlMeetingStore.GetMeetingUsersByMeetingItemIds", "store.sql_meeting.get_meeting_users_by_meetingItemIds.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	return meetingMngUser, nil
+}
+
+//REDISの開催済みのデータを格納する
+func (s SqlMeetingMngStore) SaveRedisMeeting(meetingId string, meetingList []string) *model.AppError {
+	//会議を保存
+	query := `
+			INSERT INTO
+				MeetingsEnd
+					(MeetingItemId,
+					MeetingStartTime,
+					SumMemberCount,
+					UserMail,
+					MeetingEndTime)
+			VALUES `
+
+	values := ``
+	for _, meeting := range meetingList {
+		var mapdata map[string]interface{}
+		json.Unmarshal([]byte(meeting), &mapdata)
+
+		if values == "" {
+			values += `('` + meetingId + `',
+				` + mapdata["meetingStartTime"].(string) + `,
+				` + mapdata["sumMemberCount"].(string) + `,
+				'` + mapdata["userEmail"].(string) + `',
+				` + mapdata["meetingEndTime"].(string) + `)`
+		} else {
+			values += `,('` + meetingId + `',
+				` + mapdata["meetingStartTime"].(string) + `,
+				` + mapdata["sumMemberCount"].(string) + `,
+				'` + mapdata["userEmail"].(string) + `',
+				` + mapdata["meetingEndTime"].(string) + `)`
+		}
+	}
+	query += values
+
+	tx, _ := s.GetMasterX().Begin()
+	if _, err := tx.Exec(query); err != nil {
+		tx.Rollback()
+		mlog.Error(err.Error())
+		return model.NewAppError("SqlMeetingMngStore.SaveRedisMeeting", "store.sql_meeting_mng.save_redis_meeting.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	tx.Commit()
+
+	return nil
+}
+
+//会議項目IDを使って、会議参加ユーザを取得
+func (s SqlMeetingMngStore) SaveRedisMeetingUser(meetingId string, meetingUserList []*model.MeetingMngUserRedis) *model.AppError {
+	query := `
+			INSERT INTO
+				MeetingEndUsers
+					(MeetingItemId,
+					MeetingStartTime,
+					UserMail,
+					Owner,
+					RemoteIp,
+					LocalIp,
+					StartTime,
+					EndTime)
+			VALUES `
+	values := ``
+	for _, meetingUser := range meetingUserList {
+		Owner := "0"
+		// オーナーの場合
+		if meetingUser.Owner == "true" {
+			Owner = "1"
+		}
+		//終了時間ない場合
+		if meetingUser.EndTime == "" {
+			meetingUser.EndTime = "0"
+		}
+		if values == "" {
+			values += `('` + meetingId + `',
+				` + meetingUser.MeetingStartTime + `,
+				'` + meetingUser.UserMail + `',
+				'` + Owner + `',
+				'` + meetingUser.RemoteIp + `',
+				'` + meetingUser.LocalIp + `',
+				` + meetingUser.StartTime + `,
+				` + meetingUser.EndTime + `)`
+		} else {
+			values += `,('` + meetingId + `',
+				` + meetingUser.MeetingStartTime + `,
+				'` + meetingUser.UserMail + `',
+				'` + Owner + `',
+				'` + meetingUser.RemoteIp + `',
+				'` + meetingUser.LocalIp + `',
+				` + meetingUser.StartTime + `,
+				` + meetingUser.EndTime + `)`
+		}
+	}
+
+	query += values
+
+	tx, _ := s.GetMasterX().Begin()
+	if _, err := tx.Exec(query); err != nil {
+		tx.Rollback()
+		mlog.Error(err.Error())
+		mlog.Error(query)
+		return model.NewAppError("SqlMeetingMngStore.SaveRedisMeetingUser", "store.sql_meeting_mng.save_redis_meeting_user.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	tx.Commit()
+
+	return nil
+}
Index: mattermost-server-7.8.1/store/sqlstore/meetingstatus_store.go
===================================================================
--- mattermost-server-7.8.1/store/sqlstore/meetingstatus_store.go	(nonexistent)
+++ mattermost-server-7.8.1/store/sqlstore/meetingstatus_store.go	(revision 4485)
@@ -0,0 +1,113 @@
+//Copyright 2021 Ryobi Systems Co., Ltd. All Rights Reserved.
+
+package sqlstore
+
+import (
+	"github.com/mattermost/mattermost-server/v6/einterfaces"
+	"github.com/mattermost/mattermost-server/v6/model"
+	"github.com/mattermost/mattermost-server/v6/store"
+	sq "github.com/mattermost/squirrel"
+	"net/http"
+	"time"
+)
+
+type SqlMeetingStatusStore struct {
+	*SqlStore
+	metrics     einterfaces.MetricsInterface
+	meetings    sq.SelectBuilder
+	users       sq.SelectBuilder
+	meetingsEnd sq.SelectBuilder
+}
+
+func newSqlMeetingStatusStore(sqlStore *SqlStore, metrics einterfaces.MetricsInterface) store.MeetingStatusStore {
+	s := &SqlMeetingStatusStore{
+		SqlStore: sqlStore,
+		metrics:  metrics,
+	}
+	s.users = s.getQueryBuilder().
+		Select("Id", "IFNULL(Username, '') as UserName", "Email",
+			"IFNULL(Nickname, '') as NickName", "IFNULL(FirstName, '') as FirstName", "IFNULL(LastName, '') as LastName").
+		From("Users")
+	s.meetings = s.getQueryBuilder().
+		Select("MeetingItemId", "ItemValid", "MeetingName", "lower(MeetingId) AS MeetingId", "StartAt", "EndAt", "TimeZone",
+			"HostId", "HostName", "CreateAt", "IFNULL(IsRepeat, false) as IsRepeat", "IFNULL(RepeatConfig, '') as RepeatConfig", "IFNULL(RepeatEndDate, 0) as RepeatEndDate").
+		From("Meetings")
+	s.meetingsEnd = s.getQueryBuilder().
+		Select("Id", "MeetingItemId", "MeetingStartTime", "SumMemberCount", "UserMail", "MeetingEndTime").
+		From("MeetingsEnd")
+
+	return s
+}
+
+//func (s SqlMeetingStatusStore) createIndexesIfNotExists() {}
+
+func (s SqlMeetingStatusStore) GetMeetingEndData(meeting *model.MeetingEndFromJson) ([]*model.MeetingsEnd, *model.AppError) {
+	var meetingall []*model.MeetingsEnd
+
+	timeLayout := "2006-01-02 15:04:05"
+	loc, _ := time.LoadLocation("Local")
+	startTmp, _ := time.ParseInLocation(timeLayout, meeting.StartDate+" 00:00:00", loc)
+	startTime := startTmp.Unix() * 1000
+	endTmp, _ := time.ParseInLocation(timeLayout, meeting.EndDate+" 23:59:59", loc)
+	endTime := endTmp.Unix() * 1000
+	params := map[string]interface{}{}
+	params["StartDate"] = startTime
+	params["EndDate"] = endTime
+	where := `
+			MeetingStartTime >= ?
+		AND MeetingStartTime <= ?`
+	query := s.meetingsEnd.Where(where, params)
+	queryString, _, err := query.ToSql()
+	if err != nil {
+		return nil, model.NewAppError("SqlMeetingStatusStore.meetingsEnd", "store.sql_meeting_status.get.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	if err := s.GetReplicaX().Select(&meetingall, queryString, startTime, endTime); err != nil {
+		return nil, model.NewAppError("SqlMeetingStatusStore.meetingsEnd", "store.sql_meeting_status.get.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	return meetingall, nil
+}
+
+func (s SqlMeetingStatusStore) GetMeetingNames(meetingIdList []string) ([]*model.MeetingStatus, *model.AppError) {
+	var meetingall []*model.MeetingStatus
+	//文字列を連結する(会議ID)
+	meetingIdsString := ""
+	for _, meetingId := range meetingIdList {
+		if meetingIdsString == "" {
+			meetingIdsString = meetingIdsString + "'" + meetingId + "'"
+		} else {
+			meetingIdsString = meetingIdsString + ",'" + meetingId + "'"
+		}
+	}
+
+	query := s.meetings.Where("MeetingId in (" + meetingIdsString + ") AND ItemValid = 1")
+	queryString, args, err := query.ToSql()
+	if err != nil {
+		return nil, model.NewAppError("SqlMeetingStatusStore.meetings", "store.sql_meeting_status.get.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	if err := s.GetReplicaX().Select(&meetingall, queryString, args...); err != nil {
+		return nil, model.NewAppError("SqlMeetingStatusStore.meetings", "store.sql_meeting_status.get.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	return meetingall, nil
+}
+
+func (s SqlMeetingStatusStore) GetUsersName(userEmailList []string) ([]*model.MeetUsers, *model.AppError) {
+	var meetUsers []*model.MeetUsers
+	//文字列を連結する(userEmail)
+	usersString := ""
+	for _, userMail := range userEmailList {
+		if usersString == "" {
+			usersString = usersString + "'" + userMail + "'"
+		} else {
+			usersString = usersString + ",'" + userMail + "'"
+		}
+	}
+	query := s.users.Where("Email in (" + usersString + ")")
+	queryString, args, err := query.ToSql()
+	if err != nil {
+		return nil, model.NewAppError("SqlMeetingStatusStore.users", "store.sql_meeting_status.get.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	if err := s.GetReplicaX().Select(&meetUsers, queryString, args...); err != nil {
+		return nil, model.NewAppError("SqlMeetingStatusStore.users", "store.sql_meeting_status.get.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	return meetUsers, nil
+}
Index: mattermost-server-7.8.1/store/sqlstore/poll_field.go
===================================================================
--- mattermost-server-7.8.1/store/sqlstore/poll_field.go	(nonexistent)
+++ mattermost-server-7.8.1/store/sqlstore/poll_field.go	(revision 4485)
@@ -0,0 +1,131 @@
+package sqlstore
+
+import (
+	"fmt"
+	"github.com/mattermost/mattermost-server/v6/einterfaces"
+	"github.com/mattermost/mattermost-server/v6/model"
+	"github.com/mattermost/mattermost-server/v6/shared/mlog"
+	"github.com/mattermost/mattermost-server/v6/store"
+	sq "github.com/mattermost/squirrel"
+	"net/http"
+	"unicode"
+)
+
+type SqlPollFields struct {
+	*SqlStore
+	metrics    einterfaces.MetricsInterface
+	pollFields sq.SelectBuilder
+}
+
+func newSqlPollFields(sqlStore *SqlStore, metrics einterfaces.MetricsInterface) store.PollFieldsStore {
+	s := &SqlPollFields{
+		SqlStore: sqlStore,
+		metrics:  metrics,
+	}
+
+	s.pollFields = s.getQueryBuilder().
+		Select("Id", "PostId", "Voter", "Answer", "UserId").
+		From("Poll_Fields pf")
+
+	return s
+}
+
+//func (s SqlPollFields) createIndexesIfNotExists() {
+//	s.CreateIndexIfNotExists("idx_poll_fields_post_id", "Poll_Fields", "postId")
+//}
+
+func (s SqlPollFields) GetPollFields(postId string) ([]*model.PollFields, *model.AppError) {
+	var fields []*model.PollFields
+	params := map[string]interface{}{}
+	params["PostId"] = postId
+	where := `pf.PostId = ?`
+	query := s.pollFields.Where(where, params)
+	queryString, _, err := query.ToSql()
+	if err != nil {
+		return nil, model.NewAppError("SqlPollFieldsStore.fields.tosql", "store.sql_poll_fields.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+
+	if err := s.GetReplicaX().Select(&fields, queryString, postId); err != nil {
+		return nil, model.NewAppError("SqlPollFieldsStore.fields", "store.sql_poll_fields.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	return fields, nil
+}
+func (s SqlPollFields) PollFieldsInsert(field *model.PollFields) *model.AppError {
+	//
+	var fields []*model.PollFields
+	params := map[string]interface{}{}
+	params["PostId"] = field.PostId
+	params["UserId"] = field.UserId
+	where := `pf.PostId = ?
+              AND UserId = ?`
+	query := s.pollFields.Where(where, params)
+	queryString, _, err := query.ToSql()
+	if err != nil {
+		return model.NewAppError("SqlMeetingMngStore.SaveRedisMeeting", "store.sql_meeting_mng.save_redis_meeting.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	if err := s.GetReplicaX().Select(&fields, queryString, field.PostId, field.UserId); err != nil {
+		return model.NewAppError("SqlMeetingMngStore.SaveRedisMeeting", "store.sql_meeting_mng.save_redis_meeting.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	isSelect := true
+	for _, pollFields := range fields {
+		if pollFields.UserId != "" {
+			isSelect = false
+			break
+		}
+	}
+	if isSelect {
+		answer := replaceSpecialLetters(field.Answer)
+		query := `INSERT INTO Poll_Fields(PostId,Voter,Answer,UserId)VALUES `
+		values := `('` + field.PostId + `','` + field.Voter + `','` + answer + `','` + field.UserId + `')`
+		query += values
+		tx, _ := s.GetMasterX().Begin()
+		if _, err := tx.Exec(query); err != nil {
+			tx.Rollback()
+			mlog.Error(err.Error())
+			return model.NewAppError("SqlMeetingMngStore.SaveRedisMeeting", "store.sql_meeting_mng.save_redis_meeting.app_error", nil, err.Error(), http.StatusInternalServerError)
+		}
+		tx.Commit()
+	} else {
+		_, err := s.GetMasterX().NamedExec("UPDATE Poll_Fields SET Answer = :Answer  WHERE UserId = :UserId And PostId= :PostId", map[string]interface{}{"Answer": field.Answer, "UserId": field.UserId, "PostId": field.PostId})
+		if err != nil {
+			mlog.Warn("Error updating Post .", mlog.Err(err))
+		}
+	}
+
+	return nil
+
+}
+func (s SqlPollFields) DeletePollFields(userId string, postId string) *model.AppError {
+	if _, err := s.GetMasterX().NamedExec("DELETE FROM Poll_Fields WHERE PostId = :PostId AND UserId = :UserId", map[string]interface{}{"PostId": postId, "UserId": userId}); err != nil {
+		return model.NewAppError("SqlPollFieldStore.DeletePollFields", "store.sql_delete_poll_fields.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+	return nil
+}
+func SpecialLetters(letter rune) (bool, []rune) {
+	if unicode.IsPunct(letter) || unicode.IsSymbol(letter) || unicode.Is(unicode.Han, letter) || isBackslash(letter) {
+		var chars []rune
+		chars = append(chars, '\\', letter)
+		return true, chars
+	}
+	return false, nil
+}
+
+func replaceSpecialLetters(str string) string {
+	var chars []rune
+	for _, letter := range str {
+		ok, letters := SpecialLetters(letter)
+		if ok {
+			chars = append(chars, letters...)
+		} else {
+			chars = append(chars, letter)
+		}
+	}
+	return fmt.Sprintf("%s", string(chars))
+}
+func isBackslash(letter rune) bool {
+	switch letter {
+	case '\\':
+		return true
+	}
+	return false
+}
Index: mattermost-server-7.8.1/store/sqlstore/post_store.go
===================================================================
--- mattermost-server-7.8.1/store/sqlstore/post_store.go	(revision 4484)
+++ mattermost-server-7.8.1/store/sqlstore/post_store.go	(revision 4485)
@@ -30,6 +30,7 @@
 	metrics           einterfaces.MetricsInterface
 	maxPostSizeOnce   sync.Once
 	maxPostSizeCached int
+	sqlPost           sq.UpdateBuilder
 }
 
 type postWithExtra struct {
@@ -126,13 +127,23 @@
 }
 
 func newSqlPostStore(sqlStore *SqlStore, metrics einterfaces.MetricsInterface) store.PostStore {
-	return &SqlPostStore{
+	s := &SqlPostStore{
 		SqlStore:          sqlStore,
 		metrics:           metrics,
 		maxPostSizeCached: model.PostMessageMaxRunesV1,
 	}
+	s.sqlPost = s.getQueryBuilder().
+		Update("Post")
+	return s
 }
 
+/* Ryobi Systems CloudOffice post Mod 20211203 START */
+//func (s *SqlPostStore) updateFullindexesForPost() {
+//	s.updateFullindexForPost("idx_posts_message_txt", "Posts", []string{"Message"})
+//}
+
+/* Ryobi Systems CloudOffice post Mod 20211203 START */
+
 func (s *SqlPostStore) SaveMultiple(posts []*model.Post) ([]*model.Post, int, error) {
 	channelNewPosts := make(map[string]int)
 	channelNewRootPosts := make(map[string]int)
@@ -391,6 +402,15 @@
 	return newPost, nil
 }
 
+func (s *SqlPostStore) UpdatePostWithCachereRefresh(post *model.Post) (*model.Post, error) {
+	_, err := s.GetMasterX().Exec("UPDATE Posts SET Props = :Props  WHERE Id = :Id", map[string]interface{}{"Props": model.StringInterfaceToJSON(post.GetProps()), "Id": post.Id})
+	if err != nil {
+		mlog.Warn("Error updating Post .", mlog.Err(err))
+	}
+	return post, err
+
+}
+
 func (s *SqlPostStore) OverwriteMultiple(posts []*model.Post) (_ []*model.Post, _ int, err error) {
 	updateAt := model.GetMillis()
 	maxPostSize := s.GetMaxPostSize()
@@ -1199,11 +1219,13 @@
 	parents := cpr.Data.([]*model.Post)
 
 	for _, p := range posts {
+		p = replaceFieldsIfNecessary(p, s)
 		list.AddPost(p)
 		list.AddOrder(p.Id)
 	}
 
 	for _, p := range parents {
+		p = replaceFieldsIfNecessary(p, s)
 		list.AddPost(p)
 	}
 
@@ -1212,6 +1234,55 @@
 	return list, nil
 }
 
+func replaceFieldsIfNecessary(p *model.Post, s *SqlPostStore) *model.Post {
+	if len(p.Attachments()) == 0 {
+		return p
+	}
+	anonymous, _ := p.GetProp("anonymous").(bool)
+	status, _ := p.GetProp("status").(string)
+	attachment := p.Attachments()[0]
+	var postId string
+	if p.OriginalId != "" {
+		postId = p.OriginalId
+	} else {
+		postId = p.Id
+	}
+	pollFields, _ := s.PollField().GetPollFields(postId)
+	if len(pollFields) == 0 {
+		return p
+	}
+	model.ParseSlackAttachment(p, getReplaceAttachment(attachment, pollFields, anonymous, status))
+	return p
+}
+
+func getReplaceAttachment(attachment *model.SlackAttachment, fields []*model.PollFields, anonymous bool, status string) []*model.SlackAttachment {
+	pollFields := []*model.SlackAttachmentField{}
+	for _, field := range fields {
+		value := field.Voter
+		webValue := field.Voter
+		if status != "end" {
+			webValue = ""
+			value = ""
+		}
+		if anonymous {
+			webValue = ""
+			value = ""
+		}
+		pollFields = append(pollFields, &model.SlackAttachmentField{
+			Short:    true,
+			Title:    field.Answer,
+			Value:    value,
+			WebValue: webValue,
+		})
+	}
+	return []*model.SlackAttachment{{
+		AuthorName: attachment.AuthorName,
+		Title:      attachment.Title,
+		Text:       attachment.Text,
+		Actions:    attachment.Actions,
+		Fields:     pollFields,
+	}}
+}
 func (s *SqlPostStore) getPostsSinceCollapsedThreads(options model.GetPostsSinceOptions, sanitizeOptions map[string]bool) (*model.PostList, error) {
 	var columns []string
 	for _, c := range postSliceColumns() {
@@ -2091,6 +2162,7 @@
 					continue
 				}
 			}
+			p = replaceFieldsIfNecessary(p, s)
 			list.AddPost(p)
 			list.AddOrder(p.Id)
 		}
@@ -2725,7 +2797,11 @@
 			return nil, result.NErr
 		}
 		data := result.Data.(*model.PostList)
-		posts.Extend(data)
+		for _, p := range data.Posts {
+			p = replaceFieldsIfNecessary(p, s)
+			posts.AddPost(p)
+			posts.AddOrder(p.Id)
+		}
 	}
 
 	posts.SortByCreateAt()
Index: mattermost-server-7.8.1/store/sqlstore/session_store.go
===================================================================
--- mattermost-server-7.8.1/store/sqlstore/session_store.go	(revision 4484)
+++ mattermost-server-7.8.1/store/sqlstore/session_store.go	(revision 4485)
@@ -27,7 +27,26 @@
 func newSqlSessionStore(sqlStore *SqlStore) store.SessionStore {
 	return &SqlSessionStore{sqlStore}
 }
+/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 START */
+func (me SqlSessionStore) SqlDeleteDefaultTeam() error {
+	me.Team().DeleteDefaultTeam()
+	return nil
+}
 
+func (me SqlSessionStore) SqlSaveDefaultTeam(DefaultTeam *model.DefaultTeam) {
+	me.Team().SaveDefaultTeam(DefaultTeam)
+	return
+}
+
+func (me SqlSessionStore) SqlGetDefaultTeam() (string, error) {
+	DefaultTeam, err := me.Team().GetDefaultTeam()
+	if err != nil {
+		return DefaultTeam, errors.Wrapf(err, "failed to find TeamMembers for Session with userId=%s")
+	}
+	return DefaultTeam, nil
+}
+
+/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 END */
 func (me SqlSessionStore) Save(session *model.Session) (*model.Session, error) {
 	if session.Id != "" {
 		return nil, store.NewErrInvalidInput("Session", "id", session.Id)
Index: mattermost-server-7.8.1/store/sqlstore/sqlx_wrapper.go
===================================================================
--- mattermost-server-7.8.1/store/sqlstore/sqlx_wrapper.go	(revision 4484)
+++ mattermost-server-7.8.1/store/sqlstore/sqlx_wrapper.go	(revision 4485)
@@ -457,5 +457,4 @@
 	for i, arg := range args {
 		fields = append(fields, mlog.Any("arg"+strconv.Itoa(i), arg))
 	}
-	mlog.Debug(query, fields...)
 }
Index: mattermost-server-7.8.1/store/sqlstore/store.go
===================================================================
--- mattermost-server-7.8.1/store/sqlstore/store.go	(revision 4484)
+++ mattermost-server-7.8.1/store/sqlstore/store.go	(revision 4485)
@@ -71,13 +71,23 @@
 var tablesToCheckForCollation = []string{"incomingwebhooks", "preferences", "users", "uploadsessions", "channels", "publicchannels"}
 
 type SqlStoreStores struct {
-	team                 store.TeamStore
-	channel              store.ChannelStore
-	post                 store.PostStore
-	retentionPolicy      store.RetentionPolicyStore
-	thread               store.ThreadStore
-	user                 store.UserStore
-	bot                  store.BotStore
+	team            store.TeamStore
+	channel         store.ChannelStore
+	post            store.PostStore
+	retentionPolicy store.RetentionPolicyStore
+	thread          store.ThreadStore
+	user            store.UserStore
+	bot             store.BotStore
+	meeting         store.MeetingStore
+	/* Ryobi Systems CloudOffice MeetingMng Mod 20210617 START */
+	meetingMng store.MeetingMngStore
+	/* Ryobi Systems CloudOffice MeetingMng Mod 20210617 END */
+	/* Ryobi Systems CloudOffice MeetingStatus Mod 20210913 START */
+	meetingstatus store.MeetingStatusStore
+	/* Ryobi Systems CloudOffice MeetingStatus Mod 20210913 END */
+	/* Ryobi Systems CloudOffice CronChat Mod 20211129 START */
+	cronChat store.CronChatStore
+	/* Ryobi Systems CloudOffice CronChat Mod 20211129 END */
 	audit                store.AuditStore
 	cluster              store.ClusterDiscoveryStore
 	remoteCluster        store.RemoteClusterStore
@@ -113,6 +123,7 @@
 	postPriority         store.PostPriorityStore
 	postAcknowledgement  store.PostAcknowledgementStore
 	trueUpReview         store.TrueUpReviewStore
+	pollFields           store.PollFieldsStore
 }
 
 type SqlStore struct {
@@ -140,6 +151,10 @@
 	pgDefaultTextSearchConfig string
 }
 
+func (ss *SqlStore) PollField() store.PollFieldsStore {
+	return ss.stores.pollFields
+}
+
 func New(settings model.SqlSettings, metrics einterfaces.MetricsInterface) *SqlStore {
 	store := &SqlStore{
 		rrCounter: 0,
@@ -186,6 +201,17 @@
 	store.stores.retentionPolicy = newSqlRetentionPolicyStore(store, metrics)
 	store.stores.user = newSqlUserStore(store, metrics)
 	store.stores.bot = newSqlBotStore(store, metrics)
+	store.stores.meeting = newSqlMeetingStore(store, metrics)
+	/* Ryobi Systems CloudOffice MeetingMng Mod 20210325 START */
+	store.stores.meetingMng = newSqlMeetingMngStore(store, metrics)
+	/* Ryobi Systems CloudOffice MeetingMng Mod 20210325 END */
+	store.stores.pollFields = newSqlPollFields(store, metrics)
+	/* Ryobi Systems CloudOffice MeetingStatus Mod 20210913 START */
+	store.stores.meetingstatus = newSqlMeetingStatusStore(store, metrics)
+	/* Ryobi Systems CloudOffice MeetingStatus Mod 20210913 END */
+	/* Ryobi Systems CloudOffice CronChat Mod 20211129 START */
+	store.stores.cronChat = newSqlCronChatStore(store, metrics)
+	/* Ryobi Systems CloudOffice CronChat Mod 20211129 END */
 	store.stores.audit = newSqlAuditStore(store)
 	store.stores.cluster = newSqlClusterDiscoveryStore(store)
 	store.stores.remoteCluster = newSqlRemoteClusterStore(store)
@@ -1284,3 +1310,29 @@
 
 	return migrations, nil
 }
+/* Ryobi Systems CloudOffice Meeting Mod 20210325 START */
+func (ss *SqlStore) Meeting() store.MeetingStore {
+	return ss.stores.meeting
+}
+
+/* Ryobi Systems CloudOffice Meeting Mod 20210325 END */
+/* Ryobi Systems CloudOffice MeetingMng Mod 20210617 START */
+func (ss *SqlStore) MeetingMng() store.MeetingMngStore {
+	return ss.stores.meetingMng
+}
+
+/* Ryobi Systems CloudOffice MeetingMng Mod 20210617 END */
+
+/* Ryobi Systems CloudOffice MeetingStatus Mod 20210913 START */
+func (ss *SqlStore) MeetingStatus() store.MeetingStatusStore {
+	return ss.stores.meetingstatus
+}
+
+/* Ryobi Systems CloudOffice MeetingStatus Mod 20210913 END */
+
+/* Ryobi Systems CloudOffice CronChat Mod 20211129 START */
+func (ss *SqlStore) CronChat() store.CronChatStore {
+	return ss.stores.cronChat
+}
+
+/* Ryobi Systems CloudOffice CronChat Mod 20211129 END */
Index: mattermost-server-7.8.1/store/sqlstore/team_store.go
===================================================================
--- mattermost-server-7.8.1/store/sqlstore/team_store.go	(revision 4484)
+++ mattermost-server-7.8.1/store/sqlstore/team_store.go	(revision 4485)
@@ -7,6 +7,7 @@
 	"context"
 	"database/sql"
 	"fmt"
+	"net/http"
 	"strings"
 
 	sq "github.com/mattermost/squirrel"
@@ -51,6 +52,14 @@
 	}
 }
 
+/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 START */
+type DefaultTeamWithSchemeRoles struct {
+	Id string
+}
+type DefaultTeamWithSchemeRolesList []DefaultTeamWithSchemeRoles
+
+/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 END */
+
 type teamMemberWithSchemeRoles struct {
 	TeamId                     string
 	UserId                     string
@@ -71,6 +80,12 @@
 	return []string{"TeamId", "UserId", "Roles", "DeleteAt", "SchemeUser", "SchemeAdmin", "SchemeGuest", "CreateAt"}
 }
 
+/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 START */
+func DefaultTeamSliceColumns() []string {
+	return []string{"id", "CreateAt", "UpdateAt"}
+}
+
+/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 END */
 func teamMemberToSlice(member *model.TeamMember) []any {
 	resultSlice := []any{}
 	resultSlice = append(resultSlice, member.TeamId)
@@ -84,6 +99,17 @@
 	return resultSlice
 }
 
+/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 START */
+func DefaultTeamToSlice(member *model.DefaultTeam) []interface{} {
+	resultSlice := []interface{}{}
+	resultSlice = append(resultSlice, member.Id)
+	resultSlice = append(resultSlice, member.CreateAt)
+	resultSlice = append(resultSlice, member.UpdateAt)
+	return resultSlice
+}
+
+/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 END */
+
 func wildcardSearchTerm(term string) string {
 	return strings.ToLower("%" + term + "%")
 }
@@ -214,6 +240,7 @@
 	s.teamsQuery = s.getQueryBuilder().
 		Select("Teams.*").
 		From("Teams")
+
 	return s
 }
 
@@ -722,6 +749,33 @@
 		LeftJoin("Schemes TeamScheme ON Teams.SchemeId = TeamScheme.Id")
 }
 
+/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 START */
+func (s SqlTeamStore) getDefaultTeamMembersWithSchemeSelectQuery() sq.SelectBuilder {
+	return s.getQueryBuilder().
+		Select(
+			"Id",
+		).
+		From("DefaultTeam")
+}
+
+func (s SqlTeamStore) SaveDefaultTeam(DefaultTeam *model.DefaultTeam) {
+
+	query := s.getQueryBuilder().Insert("DefaultTeam").Columns(DefaultTeamSliceColumns()...)
+	query = query.Values(DefaultTeamToSlice(DefaultTeam)...)
+
+	sql, args, err := query.ToSql()
+	if err != nil {
+		return
+	}
+	_, err = s.GetMasterX().Exec(sql, args...)
+	if err != nil {
+		return
+	}
+	return
+}
+
+/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 END */
+
 func (s SqlTeamStore) SaveMultipleMembers(members []*model.TeamMember, maxUsersPerTeam int) ([]*model.TeamMember, error) {
 	newTeamMembers := map[string]int{}
 	users := map[string]bool{}
@@ -1094,6 +1148,36 @@
 	return dbMembers.ToModel(), nil
 }
 
+/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 START */
+func (s SqlTeamStore) GetDefaultTeam() (string, *model.AppError) {
+	errDefaultTeam := ""
+
+	query := s.getDefaultTeamMembersWithSchemeSelectQuery()
+
+	queryString, args, err := query.ToSql()
+
+	if err != nil {
+
+		return errDefaultTeam, model.NewAppError("SqlDefaultTeamStore", "store.sql_team.get_members.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+
+	var dbDefaultTeam DefaultTeamWithSchemeRolesList
+	err = s.GetReplicaX().Select(&dbDefaultTeam, queryString, args...)
+
+	if err != nil {
+
+		return errDefaultTeam, model.NewAppError("SqlDefaultTeamStore", "store.sql_team.get_members.app_error", nil, err.Error(), http.StatusInternalServerError)
+	}
+
+	if len(dbDefaultTeam) == 0 {
+		return "", nil
+	}
+	dbDefaultTeamid := dbDefaultTeam[0].Id
+
+	return dbDefaultTeamid, nil
+}
+
+/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 END */
 // GetTeamsForUser returns a list of teams that the user is a member of. Expects userId to be passed as a parameter. It can also negative the teamID passed.
 func (s SqlTeamStore) GetTeamsForUser(ctx context.Context, userId, excludeTeamID string, includeDeleted bool) ([]*model.TeamMember, error) {
 	query := s.getTeamMembersWithSchemeSelectQuery().
@@ -1187,6 +1271,18 @@
 	return channels, nil
 }
 
+/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 START */
+func (s SqlTeamStore) DeleteDefaultTeam() {
+	query := s.getQueryBuilder().
+		Delete("DefaultTeam")
+	sql, args, _ := query.ToSql()
+	_, _ = s.GetMasterX().Exec(sql, args...)
+
+	return
+}
+
+/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 END */
+
 func (s SqlTeamStore) RemoveMembers(teamId string, userIds []string) error {
 	builder := s.getQueryBuilder().
 		Delete("TeamMembers").
Index: mattermost-server-7.8.1/store/store.go
===================================================================
--- mattermost-server-7.8.1/store/store.go	(revision 4484)
+++ mattermost-server-7.8.1/store/store.go	(revision 4485)
@@ -7,6 +7,7 @@
 
 import (
 	"context"
+	"github.com/robfig/cron"
 	"database/sql"
 	"time"
 
@@ -28,6 +29,18 @@
 	RetentionPolicy() RetentionPolicyStore
 	Thread() ThreadStore
 	User() UserStore
+	/* Ryobi Systems CloudOffice Meeting Mod 20210325 START */
+	Meeting() MeetingStore
+	/* Ryobi Systems CloudOffice Meeting Mod 20210325 END */
+	/* Ryobi Systems CloudOffice MeetingMng Mod 20210617 START */
+	MeetingMng() MeetingMngStore
+	/* Ryobi Systems CloudOffice MeetingMng Mod 20210617 END */
+	/* Ryobi Systems CloudOffice MeetingStatus Mod 20210913 START */
+	MeetingStatus() MeetingStatusStore
+	/* Ryobi Systems CloudOffice MeetingStatus Mod 20210913 END */
+	/* Ryobi Systems CloudOffice CronChat Mod 20211129 START */
+	CronChat() CronChatStore
+	/* Ryobi Systems CloudOffice CronChat Mod 20211129 END */
 	Bot() BotStore
 	Audit() AuditStore
 	ClusterDiscovery() ClusterDiscoveryStore
@@ -88,6 +101,7 @@
 	PostPriority() PostPriorityStore
 	PostAcknowledgement() PostAcknowledgementStore
 	TrueUpReview() TrueUpReviewStore
+	PollField() PollFieldsStore	
 }
 
 type RetentionPolicyStore interface {
@@ -133,6 +147,10 @@
 	PermanentDelete(teamID string) error
 	AnalyticsTeamCount(opts *model.TeamSearch) (int64, error)
 	SaveMultipleMembers(members []*model.TeamMember, maxUsersPerTeam int) ([]*model.TeamMember, error)
+	/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 START */
+	SaveDefaultTeam(DefaultTeam *model.DefaultTeam)
+	DeleteDefaultTeam()
+	/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 END */
 	SaveMember(member *model.TeamMember, maxUsersPerTeam int) (*model.TeamMember, error)
 	UpdateMember(member *model.TeamMember) (*model.TeamMember, error)
 	UpdateMultipleMembers(members []*model.TeamMember) ([]*model.TeamMember, error)
@@ -142,6 +160,9 @@
 	GetTotalMemberCount(teamID string, restrictions *model.ViewUsersRestrictions) (int64, error)
 	GetActiveMemberCount(teamID string, restrictions *model.ViewUsersRestrictions) (int64, error)
 	GetTeamsForUser(ctx context.Context, userID, excludeTeamID string, includeDeleted bool) ([]*model.TeamMember, error)
+	/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 START */
+	GetDefaultTeam() (string, *model.AppError)
+	/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 END */
 	GetTeamsForUserWithPagination(userID string, page, perPage int) ([]*model.TeamMember, error)
 	GetChannelUnreadsForAllTeams(excludeTeamID, userID string) ([]*model.ChannelUnread, error)
 	GetChannelUnreadsForTeam(teamID, userID string) ([]*model.ChannelUnread, error)
@@ -401,6 +422,7 @@
 	GetOldestEntityCreationTime() (int64, error)
 	HasAutoResponsePostByUserSince(options model.GetPostsSinceOptions, userId string) (bool, error)
 	GetPostsSinceForSync(options model.GetPostsSinceForSyncOptions, cursor model.GetPostsSinceForSyncCursor, limit int) ([]*model.Post, model.GetPostsSinceForSyncCursor, error)
+	UpdatePostWithCachereRefresh(post *model.Post) (*model.Post, error)
 	SetPostReminder(reminder *model.PostReminder) error
 	GetPostReminders(now int64) ([]*model.PostReminder, error)
 	GetPostReminderMetadata(postID string) (*PostReminderMetadata, error)
@@ -491,6 +513,78 @@
 	GetFirstSystemAdminID() (string, error)
 }
 
+/* Ryobi Systems CloudOffice Meeting Mod 20210325 START */
+type MeetingStore interface {
+	GetMeetingByMeetingItemId(MeetingItemId string) (*model.Meeting, *model.AppError)
+	GetMeetingsByUserId(userId string, meetingAfter string, meetingBefore string) ([]*model.Meeting, *model.AppError)
+	GetDeletedMeetingInfoByMeetingItemIds(meetingItemIds []string) ([]*model.DeleteParamsToJson, *model.AppError)
+	GetMeetingUsersByMeetingItemIds(meetingItemIds []string) ([]*model.MeetingUser, *model.AppError)
+	Save(meeting *model.Meeting, usersfromjson []*model.MeetingUserFromJson, userValid string) ([]*model.MeetingUser, string, *model.AppError)
+	Update(meeting *model.Meeting, usersfromjson []*model.MeetingUserFromJson) *model.AppError
+	UpdateValidMeetingUsers(meetingItemId string, mailAddrs []string, itemValid int) *model.AppError
+	UpdateMeetingRepeatEndDate(meeting *model.Meeting) *model.AppError
+	RemoveDelRepeatMeetingAfterNow(meetingItemId string, timeStamp int64) *model.AppError
+	SaveDelRepeatMeeting(meeting *model.Meeting, delParams *model.DeleteParamsFromJson) *model.AppError
+	PermanentDelete(meetingId string) *model.AppError
+}
+/* Ryobi Systems CloudOffice Meeting Mod 20210325 END */
+
+/* Ryobi Systems CloudOffice MeetingMng Mod 20210617 START */
+type MeetingMngStore interface {
+	GetMeetingMngList(meeting *model.MeetingMngFromJson) ([]*model.MeetingMngUserCount, *model.AppError)
+	GetMeetingMngEndByMeetingItemId(MeetingItemId string) (*model.MeetingsMeetingEnd, *model.AppError)
+	GetMeetingMngUsersByMeetingItemId(MeetingItemId string) ([]*model.MeetingMngUser, *model.AppError)
+	GetUsersByUserMails(UserList []string) ([]*model.MeetUser, *model.AppError)
+	GetMeetingMngsByMeetingItemId(meetingItemId string) (*model.MeetingMng, *model.AppError)
+	DeleteMeetingMngByMeetingItemId(meetingItemId string) (*model.AppError)
+	UpdateMeetingMngByMeetingItemId(meetingItemId string, endTime string) (*model.AppError)
+	GetMeetingMngUsersByMeetingItemIdFormail(meetingItemId string) ([]*model.MeetingMngUser, *model.AppError)
+	SaveRedisMeeting(meetingId string, meetingList []string) *model.AppError
+	SaveRedisMeetingUser(meetingId string, meetingUserList []*model.MeetingMngUserRedis) *model.AppError
+	GetMeetingEndUsers(meetingId string, meetingStartTime int64) ([]*model.MeetingMngUserToJson, *model.AppError)
+}
+/* Ryobi Systems CloudOffice MeetingMng Mod 20210617 END */
+
+/* Ryobi Systems CloudOffice MeetingStatus Mod 20210913 START */
+type MeetingStatusStore interface {
+	GetMeetingNames(meetingIdList []string) ([]*model.MeetingStatus, *model.AppError)
+	GetUsersName(userEmailList []string) ([]*model.MeetUsers, *model.AppError)
+	GetMeetingEndData(meeting *model.MeetingEndFromJson) ([]*model.MeetingsEnd, *model.AppError)
+}
+type PollFieldsStore interface {
+	GetPollFields(postId string) ([]*model.PollFields, *model.AppError)
+	PollFieldsInsert(field *model.PollFields) *model.AppError
+	DeletePollFields(userId string, postId string) *model.AppError
+}
+
+/* Ryobi Systems CloudOffice MeetingStatus Mod 20210913 END */
+
+/* Ryobi Systems CloudOffice CronChat Mod 20211129 START */
+type CronChatStore interface {
+	GetCronId() ([]*model.CronSettings, *model.AppError)
+	SaveCronChatDelete(cronId cron.EntryID, spec string) *model.AppError
+	UpdateCronChatDelete(Id int) *model.AppError
+	GetChannelSettingByChannelId(channelId string) ([]*model.ChannelChatSaveSettings, *model.AppError)
+	GetChannelSettings() ([]*model.ChannelChatSaveSettings, *model.AppError)
+	SaveChannelsSetting(channel *model.ChannelChatSaveSettingsFromJson, userId string) *model.AppError
+	UpdateChannelsSetting(channel *model.ChannelChatSaveSettingsFromJson, userId string) *model.AppError
+	GetChatMessagesByChannelId(channelId string, deleteTime int64) (*model.PostList, *model.AppError)
+	DeleteChatMessagesByChannelId(channelId string, deleteTime int64) *model.AppError
+	GetChatMessagesOther(channelIds []string, deleteTime int64) (*model.PostList, *model.AppError)
+	DeleteChatMessagesOther(channelIds []string, deleteTime int64) *model.AppError
+	GetChatMessagesDeleted() (*model.PostList, *model.AppError)
+	DeleteChatMessagesDeleted() *model.AppError
+	GetChatFilesByChannelId(channelId string, deleteTime int64) ([]*model.ChatFiles, *model.AppError)
+	DeleteChatFilesByChannelId(channelId string, deleteTime int64, fileIds []string) *model.AppError
+	GetChatFilesOther(channelIds []string, deleteTime int64) ([]*model.ChatFiles, *model.AppError)
+	DeleteChatFilesOther(channelIds []string, deleteTime int64, fileIds []string) *model.AppError
+	GetChatFilesDeleted() (*model.PostList, *model.AppError)
+	DeleteChatFilesDeleted() *model.AppError
+	GetChatFilesPath() ([]*model.ChatFilesPath, *model.AppError)
+	DeleteFileInfos() *model.AppError
+}
+/* Ryobi Systems CloudOffice CronChat Mod 20211129 END */
+
 type BotStore interface {
 	Get(userID string, includeDeleted bool) (*model.Bot, error)
 	GetAll(options *model.BotGetOptions) ([]*model.Bot, error)
@@ -502,6 +596,11 @@
 type SessionStore interface {
 	Get(ctx context.Context, sessionIDOrToken string) (*model.Session, error)
 	Save(session *model.Session) (*model.Session, error)
+	/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 START */
+	SqlGetDefaultTeam() (string, error)
+	SqlSaveDefaultTeam(DefaultTeam *model.DefaultTeam)
+	SqlDeleteDefaultTeam() error
+	/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 END */
 	GetSessions(userID string) ([]*model.Session, error)
 	GetSessionsWithActiveDeviceIds(userID string) ([]*model.Session, error)
 	GetSessionsExpired(thresholdMillis int64, mobileOnly bool, unnotifiedOnly bool) ([]*model.Session, error)
@@ -710,6 +809,9 @@
 	GetStorageUsage(allowFromCache, includeDeleted bool) (int64, error)
 	// GetUptoNSizeFileTime returns the CreateAt time of the last accessible file with a running-total size upto n bytes.
 	GetUptoNSizeFileTime(n int64) (int64, error)
+	/* Ryobi Systems CloudOffice Files Mod 20211103 START */
+	GetFileTotalSize() (int64, error)
+	/* Ryobi Systems CloudOffice Files Mod 20211103 END */
 }
 
 type UploadSessionStore interface {
Index: mattermost-server-7.8.1/store/storetest/mocks/FileInfoStore.go
===================================================================
--- mattermost-server-7.8.1/store/storetest/mocks/FileInfoStore.go	(revision 4484)
+++ mattermost-server-7.8.1/store/storetest/mocks/FileInfoStore.go	(revision 4485)
@@ -444,3 +444,26 @@
 
 	return r0, r1
 }
+
+// Upsert provides a mock function with given fields: info
+func (_m *FileInfoStore) GetFileTotalSize() (int64, error) {
+	ret := _m.Called()
+
+	var r0 int64
+	if rf, ok := ret.Get(0).(func() int64); ok {
+		r0 = rf()
+	} else {
+		if ret.Get(0) != nil {
+			r0 = ret.Get(0).(int64)
+		}
+	}
+
+	var r1 error
+	if rf, ok := ret.Get(1).(func() error); ok {
+		r1 = rf()
+	} else {
+		r1 = ret.Error(1)
+	}
+
+	return r0, r1
+}
Index: mattermost-server-7.8.1/store/storetest/mocks/PostStore.go
===================================================================
--- mattermost-server-7.8.1/store/storetest/mocks/PostStore.go	(revision 4484)
+++ mattermost-server-7.8.1/store/storetest/mocks/PostStore.go	(revision 4485)
@@ -1099,3 +1099,25 @@
 
 	return r0, r1
 }
+// Update provides a mock function with given fields: newPost, oldPost
+func (_m *PostStore) UpdatePostWithCachereRefresh(post *model.Post) (*model.Post, error) {
+	ret := _m.Called(post)
+
+	var r0 *model.Post
+	if rf, ok := ret.Get(0).(func(*model.Post) *model.Post); ok {
+		r0 = rf(post)
+	} else {
+		if ret.Get(0) != nil {
+			r0 = ret.Get(0).(*model.Post)
+		}
+	}
+
+	var r1 error
+	if rf, ok := ret.Get(1).(func(*model.Post) error); ok {
+		r1 = rf(post)
+	} else {
+		r1 = ret.Error(1)
+	}
+
+	return r0, r1
+}
Index: mattermost-server-7.8.1/store/storetest/mocks/SessionStore.go
===================================================================
--- mattermost-server-7.8.1/store/storetest/mocks/SessionStore.go	(revision 4484)
+++ mattermost-server-7.8.1/store/storetest/mocks/SessionStore.go	(revision 4485)
@@ -326,3 +326,43 @@
 
 	return r0, r1
 }
+
+/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 START */
+func (_m *SessionStore) SqlDeleteDefaultTeam() error {
+
+	ret := _m.Called()
+
+	var r0 error
+	if rf, ok := ret.Get(0).(func() error); ok {
+		r0 = rf()
+	} else {
+		r0 = ret.Error(0)
+	}
+
+	return r0
+}
+
+func (_m *SessionStore) SqlGetDefaultTeam() (string, error) {
+
+	ret := _m.Called()
+
+	var r0 string
+	r0 = ret.Get(0).(string)
+
+	var r1 error
+	if rf, ok := ret.Get(0).(func() error); ok {
+		r1 = rf()
+	} else {
+		r1 = ret.Error(0)
+	}
+
+	return r0, r1
+}
+
+func (_m *SessionStore) SqlSaveDefaultTeam(DefaultTeam *model.DefaultTeam) {
+
+	_ = _m.Called(DefaultTeam)
+
+	return
+}
+/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 END */
Index: mattermost-server-7.8.1/store/storetest/mocks/Store.go
===================================================================
--- mattermost-server-7.8.1/store/storetest/mocks/Store.go	(revision 4484)
+++ mattermost-server-7.8.1/store/storetest/mocks/Store.go	(revision 4485)
@@ -54,6 +54,87 @@
 	return r0
 }
 
+/* Ryobi Systems CloudOffice Meeting Mod 20210325 START */
+func (_m *Store) Meeting() store.MeetingStore {
+	ret := _m.Called()
+
+	var r0 store.MeetingStore
+	if rf, ok := ret.Get(0).(func() store.MeetingStore); ok {
+		r0 = rf()
+	} else {
+		if ret.Get(0) != nil {
+			r0 = ret.Get(0).(store.MeetingStore)
+		}
+	}
+
+	return r0
+}
+/* Ryobi Systems CloudOffice Meeting Mod 20210325 END */
+
+/* Ryobi Systems CloudOffice MeetingMng Mod 20210617 START */
+func (_m *Store) MeetingMng() store.MeetingMngStore {
+	ret := _m.Called()
+
+	var r0 store.MeetingMngStore
+	if rf, ok := ret.Get(0).(func() store.MeetingMngStore); ok {
+		r0 = rf()
+	} else {
+		if ret.Get(0) != nil {
+			r0 = ret.Get(0).(store.MeetingMngStore)
+		}
+	}
+
+	return r0
+}
+func (_m *Store) PollField() store.PollFieldsStore {
+	ret := _m.Called()
+
+	var r0 store.PollFieldsStore
+	if rf, ok := ret.Get(0).(func() store.PollFieldsStore); ok {
+		r0 = rf()
+	} else {
+		if ret.Get(0) != nil {
+			r0 = ret.Get(0).(store.PollFieldsStore)
+		}
+	}
+	return r0
+}
+/* Ryobi Systems CloudOffice MeetingMng Mod 20210617 END */
+
+/* Ryobi Systems CloudOffice MeetingStatus Mod 20210913 START */
+func (_m *Store) MeetingStatus() store.MeetingStatusStore {
+	ret := _m.Called()
+
+	var r0 store.MeetingStatusStore
+	if rf, ok := ret.Get(0).(func() store.MeetingStatusStore); ok {
+		r0 = rf()
+	} else {
+		if ret.Get(0) != nil {
+			r0 = ret.Get(0).(store.MeetingStatusStore)
+		}
+	}
+
+	return r0
+}
+
+/* Ryobi Systems CloudOffice MeetingStatus Mod 20210913 END */
+/* Ryobi Systems CloudOffice CronChat Mod 20211129 START */
+func (_m *Store) CronChat() store.CronChatStore {
+	ret := _m.Called()
+
+	var r0 store.CronChatStore
+	if rf, ok := ret.Get(0).(func() store.CronChatStore); ok {
+		r0 = rf()
+	} else {
+		if ret.Get(0) != nil {
+			r0 = ret.Get(0).(store.CronChatStore)
+		}
+	}
+
+	return r0
+}
+/* Ryobi Systems CloudOffice CronChat Mod 20211129 END */
+
 // Channel provides a mock function with given fields:
 func (_m *Store) Channel() store.ChannelStore {
 	ret := _m.Called()
Index: mattermost-server-7.8.1/store/storetest/mocks/TeamStore.go
===================================================================
--- mattermost-server-7.8.1/store/storetest/mocks/TeamStore.go	(revision 4484)
+++ mattermost-server-7.8.1/store/storetest/mocks/TeamStore.go	(revision 4485)
@@ -1096,3 +1096,38 @@
 
 	return r0, r1
 }
+
+/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 START */
+func (_m *TeamStore) DeleteDefaultTeam()  {
+
+	return
+}
+
+
+func (_m *TeamStore) GetDefaultTeam() (string, *model.AppError)  {
+
+	ret := _m.Called()
+
+	var r0 string
+	r0 = ret.Get(0).(string)
+
+	var r1 *model.AppError
+	if rf, ok := ret.Get(0).(func() *model.AppError); ok {
+		r1 = rf()
+	} else {
+		if ret.Get(0) != nil {
+			r1 = ret.Get(0).(*model.AppError)
+		}
+	}
+
+
+	return r0, r1
+}
+
+func (_m *TeamStore) SaveDefaultTeam(DefaultTeam *model.DefaultTeam) {
+
+	_ = _m.Called(DefaultTeam)
+
+	return
+}
+/* Ryobi Systems DefaultTeamaSetUp Mod 20201211 END */
Index: mattermost-server-7.8.1/store/timerlayer/timerlayer.go
===================================================================
--- mattermost-server-7.8.1/store/timerlayer/timerlayer.go	(revision 4484)
+++ mattermost-server-7.8.1/store/timerlayer/timerlayer.go	(revision 4485)
@@ -6090,6 +6090,22 @@
 	return result, err
 }
 
+func (s *TimerLayerPostStore) UpdatePostWithCachereRefresh(post *model.Post) (*model.Post, error) {
+	start := time.Now()
+
+	result, err := s.PostStore.UpdatePostWithCachereRefresh(post)
+
+	elapsed := float64(time.Since(start)) / float64(time.Second)
+	if s.Root.Metrics != nil {
+		success := "false"
+		if err == nil {
+			success = "true"
+		}
+		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.UpdatePostWithCachereRefresh", success, elapsed)
+	}
+	return result, err
+}
+
 func (s *TimerLayerPostAcknowledgementStore) GetForPost(postID string) ([]*model.PostAcknowledgement, error) {
 	start := time.Now()
 
Index: mattermost-server-7.8.1/templates/messages_notification.html
===================================================================
--- mattermost-server-7.8.1/templates/messages_notification.html	(revision 4484)
+++ mattermost-server-7.8.1/templates/messages_notification.html	(revision 4485)
@@ -536,7 +536,7 @@
                                     <tbody>
                                       <tr>
                                         <td style="width:132px;">
-                                          <img alt height="21" src="{{.Props.SiteURL}}/static/images/logo_email_dark.png" style="border:0;display:block;outline:none;text-decoration:none;height:21.76px;width:100%;font-size:13px;" width="132">
+                                          <img alt height="21" src="{{.Props.SiteURL}}/static/images/logo_email_blue.png" style="border:0;display:block;outline:none;text-decoration:none;height:21.76px;width:100%;font-size:13px;" width="132">
                                         </td>
                                       </tr>
                                     </tbody>
Index: mattermost-server-7.8.1/templates/partials/logo.mjml
===================================================================
--- mattermost-server-7.8.1/templates/partials/logo.mjml	(revision 4484)
+++ mattermost-server-7.8.1/templates/partials/logo.mjml	(revision 4485)
@@ -1,5 +1,5 @@
 <mj-section padding="0px 0px 40px 0px">
   <mj-column>
-    <mj-image mj-class="logo" src="{{.Props.SiteURL}}/static/images/logo_email_dark.png" />
+    <mj-image mj-class="logo" src="{{.Props.SiteURL}}/static/images/logo_email_blue.png" />
   </mj-column>
 </mj-section>
\ No newline at end of file
Index: mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/.github/CONTRIBUTING.md
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/.github/CONTRIBUTING.md	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/.github/CONTRIBUTING.md	(revision 4485)
@@ -0,0 +1,5 @@
+Ask questions at
+[StackOverflow](https://stackoverflow.com/questions/ask?tags=go+redis).
+
+[Open an issue](https://github.com/garyburd/redigo/issues/new) to discuss your
+plans before doing any work on Redigo.
Index: mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/.github/ISSUE_TEMPLATE.md
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/.github/ISSUE_TEMPLATE.md	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/.github/ISSUE_TEMPLATE.md	(revision 4485)
@@ -0,0 +1 @@
+Ask questions at https://stackoverflow.com/questions/ask?tags=go+redis
Index: mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/.travis.yml
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/.travis.yml	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/.travis.yml	(revision 4485)
@@ -0,0 +1,20 @@
+language: go
+sudo: false
+services:
+  - redis-server
+
+go:
+  - 1.4
+  - 1.5.x
+  - 1.6.x
+  - 1.7.x
+  - 1.8.x
+  - 1.9.x
+  - 1.10.x
+  - tip
+
+script:
+  - go get -t -v ./...
+  - diff -u <(echo -n) <(gofmt -d .)
+  - go vet $(go list ./... | grep -v /vendor/)
+  - go test -v -race ./...
Index: mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/LICENSE
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/LICENSE	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/LICENSE	(revision 4485)
@@ -0,0 +1,175 @@
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
Index: mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/README.markdown
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/README.markdown	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/README.markdown	(revision 4485)
@@ -0,0 +1,4 @@
+Future development of Redigo is at
+[github.com/gomodule/redigo](https://github.com/gomodule/redigo). Please submit
+issues at gomodule/redigo. The repository at github.com/garyburd/redigo is a
+read-only snapshot.
Index: mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/internal/commandinfo.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/internal/commandinfo.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/internal/commandinfo.go	(revision 4485)
@@ -0,0 +1,54 @@
+// Copyright 2014 Gary Burd
+//
+// Licensed under the Apache License, Version 2.0 (the "License"): you may
+// not use this file except in compliance with the License. You may obtain
+// a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+// License for the specific language governing permissions and limitations
+// under the License.
+
+package internal // import "github.com/garyburd/redigo/internal"
+
+import (
+	"strings"
+)
+
+const (
+	WatchState = 1 << iota
+	MultiState
+	SubscribeState
+	MonitorState
+)
+
+type CommandInfo struct {
+	Set, Clear int
+}
+
+var commandInfos = map[string]CommandInfo{
+	"WATCH":      {Set: WatchState},
+	"UNWATCH":    {Clear: WatchState},
+	"MULTI":      {Set: MultiState},
+	"EXEC":       {Clear: WatchState | MultiState},
+	"DISCARD":    {Clear: WatchState | MultiState},
+	"PSUBSCRIBE": {Set: SubscribeState},
+	"SUBSCRIBE":  {Set: SubscribeState},
+	"MONITOR":    {Set: MonitorState},
+}
+
+func init() {
+	for n, ci := range commandInfos {
+		commandInfos[strings.ToLower(n)] = ci
+	}
+}
+
+func LookupCommandInfo(commandName string) CommandInfo {
+	if ci, ok := commandInfos[commandName]; ok {
+		return ci
+	}
+	return commandInfos[strings.ToUpper(commandName)]
+}
Index: mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/internal/commandinfo_test.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/internal/commandinfo_test.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/internal/commandinfo_test.go	(revision 4485)
@@ -0,0 +1,27 @@
+package internal
+
+import "testing"
+
+func TestLookupCommandInfo(t *testing.T) {
+	for _, n := range []string{"watch", "WATCH", "wAtch"} {
+		if LookupCommandInfo(n) == (CommandInfo{}) {
+			t.Errorf("LookupCommandInfo(%q) = CommandInfo{}, expected non-zero value", n)
+		}
+	}
+}
+
+func benchmarkLookupCommandInfo(b *testing.B, names ...string) {
+	for i := 0; i < b.N; i++ {
+		for _, c := range names {
+			LookupCommandInfo(c)
+		}
+	}
+}
+
+func BenchmarkLookupCommandInfoCorrectCase(b *testing.B) {
+	benchmarkLookupCommandInfo(b, "watch", "WATCH", "monitor", "MONITOR")
+}
+
+func BenchmarkLookupCommandInfoMixedCase(b *testing.B) {
+	benchmarkLookupCommandInfo(b, "wAtch", "WeTCH", "monItor", "MONiTOR")
+}
Index: mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/internal/redistest/testdb.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/internal/redistest/testdb.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/internal/redistest/testdb.go	(revision 4485)
@@ -0,0 +1,68 @@
+// Copyright 2014 Gary Burd
+//
+// Licensed under the Apache License, Version 2.0 (the "License"): you may
+// not use this file except in compliance with the License. You may obtain
+// a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+// License for the specific language governing permissions and limitations
+// under the License.
+
+// Package redistest contains utilities for writing Redigo tests.
+package redistest
+
+import (
+	"errors"
+	"time"
+
+	"github.com/garyburd/redigo/redis"
+)
+
+type testConn struct {
+	redis.Conn
+}
+
+func (t testConn) Close() error {
+	_, err := t.Conn.Do("SELECT", "9")
+	if err != nil {
+		return nil
+	}
+	_, err = t.Conn.Do("FLUSHDB")
+	if err != nil {
+		return err
+	}
+	return t.Conn.Close()
+}
+
+// Dial dials the local Redis server and selects database 9. To prevent
+// stomping on real data, DialTestDB fails if database 9 contains data. The
+// returned connection flushes database 9 on close.
+func Dial() (redis.Conn, error) {
+	c, err := redis.DialTimeout("tcp", ":6379", 0, 1*time.Second, 1*time.Second)
+	if err != nil {
+		return nil, err
+	}
+
+	_, err = c.Do("SELECT", "9")
+	if err != nil {
+		c.Close()
+		return nil, err
+	}
+
+	n, err := redis.Int(c.Do("DBSIZE"))
+	if err != nil {
+		c.Close()
+		return nil, err
+	}
+
+	if n != 0 {
+		c.Close()
+		return nil, errors.New("database #9 is not empty, test can not continue")
+	}
+
+	return testConn{c}, nil
+}
Index: mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/conn.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/conn.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/conn.go	(revision 4485)
@@ -0,0 +1,673 @@
+// Copyright 2012 Gary Burd
+//
+// Licensed under the Apache License, Version 2.0 (the "License"): you may
+// not use this file except in compliance with the License. You may obtain
+// a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+// License for the specific language governing permissions and limitations
+// under the License.
+
+package redis
+
+import (
+	"bufio"
+	"bytes"
+	"crypto/tls"
+	"errors"
+	"fmt"
+	"io"
+	"net"
+	"net/url"
+	"regexp"
+	"strconv"
+	"sync"
+	"time"
+)
+
+var (
+	_ ConnWithTimeout = (*conn)(nil)
+)
+
+// conn is the low-level implementation of Conn
+type conn struct {
+	// Shared
+	mu      sync.Mutex
+	pending int
+	err     error
+	conn    net.Conn
+
+	// Read
+	readTimeout time.Duration
+	br          *bufio.Reader
+
+	// Write
+	writeTimeout time.Duration
+	bw           *bufio.Writer
+
+	// Scratch space for formatting argument length.
+	// '*' or '$', length, "\r\n"
+	lenScratch [32]byte
+
+	// Scratch space for formatting integers and floats.
+	numScratch [40]byte
+}
+
+// DialTimeout acts like Dial but takes timeouts for establishing the
+// connection to the server, writing a command and reading a reply.
+//
+// Deprecated: Use Dial with options instead.
+func DialTimeout(network, address string, connectTimeout, readTimeout, writeTimeout time.Duration) (Conn, error) {
+	return Dial(network, address,
+		DialConnectTimeout(connectTimeout),
+		DialReadTimeout(readTimeout),
+		DialWriteTimeout(writeTimeout))
+}
+
+// DialOption specifies an option for dialing a Redis server.
+type DialOption struct {
+	f func(*dialOptions)
+}
+
+type dialOptions struct {
+	readTimeout  time.Duration
+	writeTimeout time.Duration
+	dialer       *net.Dialer
+	dial         func(network, addr string) (net.Conn, error)
+	db           int
+	password     string
+	useTLS       bool
+	skipVerify   bool
+	tlsConfig    *tls.Config
+}
+
+// DialReadTimeout specifies the timeout for reading a single command reply.
+func DialReadTimeout(d time.Duration) DialOption {
+	return DialOption{func(do *dialOptions) {
+		do.readTimeout = d
+	}}
+}
+
+// DialWriteTimeout specifies the timeout for writing a single command.
+func DialWriteTimeout(d time.Duration) DialOption {
+	return DialOption{func(do *dialOptions) {
+		do.writeTimeout = d
+	}}
+}
+
+// DialConnectTimeout specifies the timeout for connecting to the Redis server when
+// no DialNetDial option is specified.
+func DialConnectTimeout(d time.Duration) DialOption {
+	return DialOption{func(do *dialOptions) {
+		do.dialer.Timeout = d
+	}}
+}
+
+// DialKeepAlive specifies the keep-alive period for TCP connections to the Redis server
+// when no DialNetDial option is specified.
+// If zero, keep-alives are not enabled. If no DialKeepAlive option is specified then
+// the default of 5 minutes is used to ensure that half-closed TCP sessions are detected.
+func DialKeepAlive(d time.Duration) DialOption {
+	return DialOption{func(do *dialOptions) {
+		do.dialer.KeepAlive = d
+	}}
+}
+
+// DialNetDial specifies a custom dial function for creating TCP
+// connections, otherwise a net.Dialer customized via the other options is used.
+// DialNetDial overrides DialConnectTimeout and DialKeepAlive.
+func DialNetDial(dial func(network, addr string) (net.Conn, error)) DialOption {
+	return DialOption{func(do *dialOptions) {
+		do.dial = dial
+	}}
+}
+
+// DialDatabase specifies the database to select when dialing a connection.
+func DialDatabase(db int) DialOption {
+	return DialOption{func(do *dialOptions) {
+		do.db = db
+	}}
+}
+
+// DialPassword specifies the password to use when connecting to
+// the Redis server.
+func DialPassword(password string) DialOption {
+	return DialOption{func(do *dialOptions) {
+		do.password = password
+	}}
+}
+
+// DialTLSConfig specifies the config to use when a TLS connection is dialed.
+// Has no effect when not dialing a TLS connection.
+func DialTLSConfig(c *tls.Config) DialOption {
+	return DialOption{func(do *dialOptions) {
+		do.tlsConfig = c
+	}}
+}
+
+// DialTLSSkipVerify disables server name verification when connecting over
+// TLS. Has no effect when not dialing a TLS connection.
+func DialTLSSkipVerify(skip bool) DialOption {
+	return DialOption{func(do *dialOptions) {
+		do.skipVerify = skip
+	}}
+}
+
+// DialUseTLS specifies whether TLS should be used when connecting to the
+// server. This option is ignore by DialURL.
+func DialUseTLS(useTLS bool) DialOption {
+	return DialOption{func(do *dialOptions) {
+		do.useTLS = useTLS
+	}}
+}
+
+// Dial connects to the Redis server at the given network and
+// address using the specified options.
+func Dial(network, address string, options ...DialOption) (Conn, error) {
+	do := dialOptions{
+		dialer: &net.Dialer{
+			KeepAlive: time.Minute * 5,
+		},
+	}
+	for _, option := range options {
+		option.f(&do)
+	}
+	if do.dial == nil {
+		do.dial = do.dialer.Dial
+	}
+
+	netConn, err := do.dial(network, address)
+	if err != nil {
+		return nil, err
+	}
+
+	if do.useTLS {
+		var tlsConfig *tls.Config
+		if do.tlsConfig == nil {
+			tlsConfig = &tls.Config{InsecureSkipVerify: do.skipVerify}
+		} else {
+			tlsConfig = cloneTLSConfig(do.tlsConfig)
+		}
+		if tlsConfig.ServerName == "" {
+			host, _, err := net.SplitHostPort(address)
+			if err != nil {
+				netConn.Close()
+				return nil, err
+			}
+			tlsConfig.ServerName = host
+		}
+
+		tlsConn := tls.Client(netConn, tlsConfig)
+		if err := tlsConn.Handshake(); err != nil {
+			netConn.Close()
+			return nil, err
+		}
+		netConn = tlsConn
+	}
+
+	c := &conn{
+		conn:         netConn,
+		bw:           bufio.NewWriter(netConn),
+		br:           bufio.NewReader(netConn),
+		readTimeout:  do.readTimeout,
+		writeTimeout: do.writeTimeout,
+	}
+
+	if do.password != "" {
+		if _, err := c.Do("AUTH", do.password); err != nil {
+			netConn.Close()
+			return nil, err
+		}
+	}
+
+	if do.db != 0 {
+		if _, err := c.Do("SELECT", do.db); err != nil {
+			netConn.Close()
+			return nil, err
+		}
+	}
+
+	return c, nil
+}
+
+var pathDBRegexp = regexp.MustCompile(`/(\d*)\z`)
+
+// DialURL connects to a Redis server at the given URL using the Redis
+// URI scheme. URLs should follow the draft IANA specification for the
+// scheme (https://www.iana.org/assignments/uri-schemes/prov/redis).
+func DialURL(rawurl string, options ...DialOption) (Conn, error) {
+	u, err := url.Parse(rawurl)
+	if err != nil {
+		return nil, err
+	}
+
+	if u.Scheme != "redis" && u.Scheme != "rediss" {
+		return nil, fmt.Errorf("invalid redis URL scheme: %s", u.Scheme)
+	}
+
+	// As per the IANA draft spec, the host defaults to localhost and
+	// the port defaults to 6379.
+	host, port, err := net.SplitHostPort(u.Host)
+	if err != nil {
+		// assume port is missing
+		host = u.Host
+		port = "6379"
+	}
+	if host == "" {
+		host = "localhost"
+	}
+	address := net.JoinHostPort(host, port)
+
+	if u.User != nil {
+		password, isSet := u.User.Password()
+		if isSet {
+			options = append(options, DialPassword(password))
+		}
+	}
+
+	match := pathDBRegexp.FindStringSubmatch(u.Path)
+	if len(match) == 2 {
+		db := 0
+		if len(match[1]) > 0 {
+			db, err = strconv.Atoi(match[1])
+			if err != nil {
+				return nil, fmt.Errorf("invalid database: %s", u.Path[1:])
+			}
+		}
+		if db != 0 {
+			options = append(options, DialDatabase(db))
+		}
+	} else if u.Path != "" {
+		return nil, fmt.Errorf("invalid database: %s", u.Path[1:])
+	}
+
+	options = append(options, DialUseTLS(u.Scheme == "rediss"))
+
+	return Dial("tcp", address, options...)
+}
+
+// NewConn returns a new Redigo connection for the given net connection.
+func NewConn(netConn net.Conn, readTimeout, writeTimeout time.Duration) Conn {
+	return &conn{
+		conn:         netConn,
+		bw:           bufio.NewWriter(netConn),
+		br:           bufio.NewReader(netConn),
+		readTimeout:  readTimeout,
+		writeTimeout: writeTimeout,
+	}
+}
+
+func (c *conn) Close() error {
+	c.mu.Lock()
+	err := c.err
+	if c.err == nil {
+		c.err = errors.New("redigo: closed")
+		err = c.conn.Close()
+	}
+	c.mu.Unlock()
+	return err
+}
+
+func (c *conn) fatal(err error) error {
+	c.mu.Lock()
+	if c.err == nil {
+		c.err = err
+		// Close connection to force errors on subsequent calls and to unblock
+		// other reader or writer.
+		c.conn.Close()
+	}
+	c.mu.Unlock()
+	return err
+}
+
+func (c *conn) Err() error {
+	c.mu.Lock()
+	err := c.err
+	c.mu.Unlock()
+	return err
+}
+
+func (c *conn) writeLen(prefix byte, n int) error {
+	c.lenScratch[len(c.lenScratch)-1] = '\n'
+	c.lenScratch[len(c.lenScratch)-2] = '\r'
+	i := len(c.lenScratch) - 3
+	for {
+		c.lenScratch[i] = byte('0' + n%10)
+		i -= 1
+		n = n / 10
+		if n == 0 {
+			break
+		}
+	}
+	c.lenScratch[i] = prefix
+	_, err := c.bw.Write(c.lenScratch[i:])
+	return err
+}
+
+func (c *conn) writeString(s string) error {
+	c.writeLen('$', len(s))
+	c.bw.WriteString(s)
+	_, err := c.bw.WriteString("\r\n")
+	return err
+}
+
+func (c *conn) writeBytes(p []byte) error {
+	c.writeLen('$', len(p))
+	c.bw.Write(p)
+	_, err := c.bw.WriteString("\r\n")
+	return err
+}
+
+func (c *conn) writeInt64(n int64) error {
+	return c.writeBytes(strconv.AppendInt(c.numScratch[:0], n, 10))
+}
+
+func (c *conn) writeFloat64(n float64) error {
+	return c.writeBytes(strconv.AppendFloat(c.numScratch[:0], n, 'g', -1, 64))
+}
+
+func (c *conn) writeCommand(cmd string, args []interface{}) error {
+	c.writeLen('*', 1+len(args))
+	if err := c.writeString(cmd); err != nil {
+		return err
+	}
+	for _, arg := range args {
+		if err := c.writeArg(arg, true); err != nil {
+			return err
+		}
+	}
+	return nil
+}
+
+func (c *conn) writeArg(arg interface{}, argumentTypeOK bool) (err error) {
+	switch arg := arg.(type) {
+	case string:
+		return c.writeString(arg)
+	case []byte:
+		return c.writeBytes(arg)
+	case int:
+		return c.writeInt64(int64(arg))
+	case int64:
+		return c.writeInt64(arg)
+	case float64:
+		return c.writeFloat64(arg)
+	case bool:
+		if arg {
+			return c.writeString("1")
+		} else {
+			return c.writeString("0")
+		}
+	case nil:
+		return c.writeString("")
+	case Argument:
+		if argumentTypeOK {
+			return c.writeArg(arg.RedisArg(), false)
+		}
+		// See comment in default clause below.
+		var buf bytes.Buffer
+		fmt.Fprint(&buf, arg)
+		return c.writeBytes(buf.Bytes())
+	default:
+		// This default clause is intended to handle builtin numeric types.
+		// The function should return an error for other types, but this is not
+		// done for compatibility with previous versions of the package.
+		var buf bytes.Buffer
+		fmt.Fprint(&buf, arg)
+		return c.writeBytes(buf.Bytes())
+	}
+}
+
+type protocolError string
+
+func (pe protocolError) Error() string {
+	return fmt.Sprintf("redigo: %s (possible server error or unsupported concurrent read by application)", string(pe))
+}
+
+func (c *conn) readLine() ([]byte, error) {
+	p, err := c.br.ReadSlice('\n')
+	if err == bufio.ErrBufferFull {
+		return nil, protocolError("long response line")
+	}
+	if err != nil {
+		return nil, err
+	}
+	i := len(p) - 2
+	if i < 0 || p[i] != '\r' {
+		return nil, protocolError("bad response line terminator")
+	}
+	return p[:i], nil
+}
+
+// parseLen parses bulk string and array lengths.
+func parseLen(p []byte) (int, error) {
+	if len(p) == 0 {
+		return -1, protocolError("malformed length")
+	}
+
+	if p[0] == '-' && len(p) == 2 && p[1] == '1' {
+		// handle $-1 and $-1 null replies.
+		return -1, nil
+	}
+
+	var n int
+	for _, b := range p {
+		n *= 10
+		if b < '0' || b > '9' {
+			return -1, protocolError("illegal bytes in length")
+		}
+		n += int(b - '0')
+	}
+
+	return n, nil
+}
+
+// parseInt parses an integer reply.
+func parseInt(p []byte) (interface{}, error) {
+	if len(p) == 0 {
+		return 0, protocolError("malformed integer")
+	}
+
+	var negate bool
+	if p[0] == '-' {
+		negate = true
+		p = p[1:]
+		if len(p) == 0 {
+			return 0, protocolError("malformed integer")
+		}
+	}
+
+	var n int64
+	for _, b := range p {
+		n *= 10
+		if b < '0' || b > '9' {
+			return 0, protocolError("illegal bytes in length")
+		}
+		n += int64(b - '0')
+	}
+
+	if negate {
+		n = -n
+	}
+	return n, nil
+}
+
+var (
+	okReply   interface{} = "OK"
+	pongReply interface{} = "PONG"
+)
+
+func (c *conn) readReply() (interface{}, error) {
+	line, err := c.readLine()
+	if err != nil {
+		return nil, err
+	}
+	if len(line) == 0 {
+		return nil, protocolError("short response line")
+	}
+	switch line[0] {
+	case '+':
+		switch {
+		case len(line) == 3 && line[1] == 'O' && line[2] == 'K':
+			// Avoid allocation for frequent "+OK" response.
+			return okReply, nil
+		case len(line) == 5 && line[1] == 'P' && line[2] == 'O' && line[3] == 'N' && line[4] == 'G':
+			// Avoid allocation in PING command benchmarks :)
+			return pongReply, nil
+		default:
+			return string(line[1:]), nil
+		}
+	case '-':
+		return Error(string(line[1:])), nil
+	case ':':
+		return parseInt(line[1:])
+	case '$':
+		n, err := parseLen(line[1:])
+		if n < 0 || err != nil {
+			return nil, err
+		}
+		p := make([]byte, n)
+		_, err = io.ReadFull(c.br, p)
+		if err != nil {
+			return nil, err
+		}
+		if line, err := c.readLine(); err != nil {
+			return nil, err
+		} else if len(line) != 0 {
+			return nil, protocolError("bad bulk string format")
+		}
+		return p, nil
+	case '*':
+		n, err := parseLen(line[1:])
+		if n < 0 || err != nil {
+			return nil, err
+		}
+		r := make([]interface{}, n)
+		for i := range r {
+			r[i], err = c.readReply()
+			if err != nil {
+				return nil, err
+			}
+		}
+		return r, nil
+	}
+	return nil, protocolError("unexpected response line")
+}
+
+func (c *conn) Send(cmd string, args ...interface{}) error {
+	c.mu.Lock()
+	c.pending += 1
+	c.mu.Unlock()
+	if c.writeTimeout != 0 {
+		c.conn.SetWriteDeadline(time.Now().Add(c.writeTimeout))
+	}
+	if err := c.writeCommand(cmd, args); err != nil {
+		return c.fatal(err)
+	}
+	return nil
+}
+
+func (c *conn) Flush() error {
+	if c.writeTimeout != 0 {
+		c.conn.SetWriteDeadline(time.Now().Add(c.writeTimeout))
+	}
+	if err := c.bw.Flush(); err != nil {
+		return c.fatal(err)
+	}
+	return nil
+}
+
+func (c *conn) Receive() (interface{}, error) {
+	return c.ReceiveWithTimeout(c.readTimeout)
+}
+
+func (c *conn) ReceiveWithTimeout(timeout time.Duration) (reply interface{}, err error) {
+	var deadline time.Time
+	if timeout != 0 {
+		deadline = time.Now().Add(timeout)
+	}
+	c.conn.SetReadDeadline(deadline)
+
+	if reply, err = c.readReply(); err != nil {
+		return nil, c.fatal(err)
+	}
+	// When using pub/sub, the number of receives can be greater than the
+	// number of sends. To enable normal use of the connection after
+	// unsubscribing from all channels, we do not decrement pending to a
+	// negative value.
+	//
+	// The pending field is decremented after the reply is read to handle the
+	// case where Receive is called before Send.
+	c.mu.Lock()
+	if c.pending > 0 {
+		c.pending -= 1
+	}
+	c.mu.Unlock()
+	if err, ok := reply.(Error); ok {
+		return nil, err
+	}
+	return
+}
+
+func (c *conn) Do(cmd string, args ...interface{}) (interface{}, error) {
+	return c.DoWithTimeout(c.readTimeout, cmd, args...)
+}
+
+func (c *conn) DoWithTimeout(readTimeout time.Duration, cmd string, args ...interface{}) (interface{}, error) {
+	c.mu.Lock()
+	pending := c.pending
+	c.pending = 0
+	c.mu.Unlock()
+
+	if cmd == "" && pending == 0 {
+		return nil, nil
+	}
+
+	if c.writeTimeout != 0 {
+		c.conn.SetWriteDeadline(time.Now().Add(c.writeTimeout))
+	}
+
+	if cmd != "" {
+		if err := c.writeCommand(cmd, args); err != nil {
+			return nil, c.fatal(err)
+		}
+	}
+
+	if err := c.bw.Flush(); err != nil {
+		return nil, c.fatal(err)
+	}
+
+	var deadline time.Time
+	if readTimeout != 0 {
+		deadline = time.Now().Add(readTimeout)
+	}
+	c.conn.SetReadDeadline(deadline)
+
+	if cmd == "" {
+		reply := make([]interface{}, pending)
+		for i := range reply {
+			r, e := c.readReply()
+			if e != nil {
+				return nil, c.fatal(e)
+			}
+			reply[i] = r
+		}
+		return reply, nil
+	}
+
+	var err error
+	var reply interface{}
+	for i := 0; i <= pending; i++ {
+		var e error
+		if reply, e = c.readReply(); e != nil {
+			return nil, c.fatal(e)
+		}
+		if e, ok := reply.(Error); ok && err == nil {
+			err = e
+		}
+	}
+	return reply, err
+}
Index: mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/conn_test.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/conn_test.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/conn_test.go	(revision 4485)
@@ -0,0 +1,867 @@
+// Copyright 2012 Gary Burd
+//
+// Licensed under the Apache License, Version 2.0 (the "License"): you may
+// not use this file except in compliance with the License. You may obtain
+// a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+// License for the specific language governing permissions and limitations
+// under the License.
+
+package redis_test
+
+import (
+	"bytes"
+	"crypto/tls"
+	"crypto/x509"
+	"fmt"
+	"io"
+	"math"
+	"net"
+	"os"
+	"reflect"
+	"strings"
+	"testing"
+	"time"
+
+	"github.com/garyburd/redigo/redis"
+)
+
+type testConn struct {
+	io.Reader
+	io.Writer
+	readDeadline  time.Time
+	writeDeadline time.Time
+}
+
+func (*testConn) Close() error                         { return nil }
+func (*testConn) LocalAddr() net.Addr                  { return nil }
+func (*testConn) RemoteAddr() net.Addr                 { return nil }
+func (c *testConn) SetDeadline(t time.Time) error      { c.readDeadline = t; c.writeDeadline = t; return nil }
+func (c *testConn) SetReadDeadline(t time.Time) error  { c.readDeadline = t; return nil }
+func (c *testConn) SetWriteDeadline(t time.Time) error { c.writeDeadline = t; return nil }
+
+func dialTestConn(r string, w io.Writer) redis.DialOption {
+	return redis.DialNetDial(func(network, addr string) (net.Conn, error) {
+		return &testConn{Reader: strings.NewReader(r), Writer: w}, nil
+	})
+}
+
+type tlsTestConn struct {
+	net.Conn
+	done chan struct{}
+}
+
+func (c *tlsTestConn) Close() error {
+	c.Conn.Close()
+	<-c.done
+	return nil
+}
+
+func dialTestConnTLS(r string, w io.Writer) redis.DialOption {
+	return redis.DialNetDial(func(network, addr string) (net.Conn, error) {
+		client, server := net.Pipe()
+		tlsServer := tls.Server(server, &serverTLSConfig)
+		go io.Copy(tlsServer, strings.NewReader(r))
+		done := make(chan struct{})
+		go func() {
+			io.Copy(w, tlsServer)
+			close(done)
+		}()
+		return &tlsTestConn{Conn: client, done: done}, nil
+	})
+}
+
+type durationArg struct {
+	time.Duration
+}
+
+func (t durationArg) RedisArg() interface{} {
+	return t.Seconds()
+}
+
+type recursiveArg int
+
+func (v recursiveArg) RedisArg() interface{} { return v }
+
+var writeTests = []struct {
+	args     []interface{}
+	expected string
+}{
+	{
+		[]interface{}{"SET", "key", "value"},
+		"*3\r\n$3\r\nSET\r\n$3\r\nkey\r\n$5\r\nvalue\r\n",
+	},
+	{
+		[]interface{}{"SET", "key", "value"},
+		"*3\r\n$3\r\nSET\r\n$3\r\nkey\r\n$5\r\nvalue\r\n",
+	},
+	{
+		[]interface{}{"SET", "key", byte(100)},
+		"*3\r\n$3\r\nSET\r\n$3\r\nkey\r\n$3\r\n100\r\n",
+	},
+	{
+		[]interface{}{"SET", "key", 100},
+		"*3\r\n$3\r\nSET\r\n$3\r\nkey\r\n$3\r\n100\r\n",
+	},
+	{
+		[]interface{}{"SET", "key", int64(math.MinInt64)},
+		"*3\r\n$3\r\nSET\r\n$3\r\nkey\r\n$20\r\n-9223372036854775808\r\n",
+	},
+	{
+		[]interface{}{"SET", "key", float64(1349673917.939762)},
+		"*3\r\n$3\r\nSET\r\n$3\r\nkey\r\n$21\r\n1.349673917939762e+09\r\n",
+	},
+	{
+		[]interface{}{"SET", "key", ""},
+		"*3\r\n$3\r\nSET\r\n$3\r\nkey\r\n$0\r\n\r\n",
+	},
+	{
+		[]interface{}{"SET", "key", nil},
+		"*3\r\n$3\r\nSET\r\n$3\r\nkey\r\n$0\r\n\r\n",
+	},
+	{
+		[]interface{}{"SET", "key", durationArg{time.Minute}},
+		"*3\r\n$3\r\nSET\r\n$3\r\nkey\r\n$2\r\n60\r\n",
+	},
+	{
+		[]interface{}{"SET", "key", recursiveArg(123)},
+		"*3\r\n$3\r\nSET\r\n$3\r\nkey\r\n$3\r\n123\r\n",
+	},
+	{
+		[]interface{}{"ECHO", true, false},
+		"*3\r\n$4\r\nECHO\r\n$1\r\n1\r\n$1\r\n0\r\n",
+	},
+}
+
+func TestWrite(t *testing.T) {
+	for _, tt := range writeTests {
+		var buf bytes.Buffer
+		c, _ := redis.Dial("", "", dialTestConn("", &buf))
+		err := c.Send(tt.args[0].(string), tt.args[1:]...)
+		if err != nil {
+			t.Errorf("Send(%v) returned error %v", tt.args, err)
+			continue
+		}
+		c.Flush()
+		actual := buf.String()
+		if actual != tt.expected {
+			t.Errorf("Send(%v) = %q, want %q", tt.args, actual, tt.expected)
+		}
+	}
+}
+
+var errorSentinel = &struct{}{}
+
+var readTests = []struct {
+	reply    string
+	expected interface{}
+}{
+	{
+		"+OK\r\n",
+		"OK",
+	},
+	{
+		"+PONG\r\n",
+		"PONG",
+	},
+	{
+		"@OK\r\n",
+		errorSentinel,
+	},
+	{
+		"$6\r\nfoobar\r\n",
+		[]byte("foobar"),
+	},
+	{
+		"$-1\r\n",
+		nil,
+	},
+	{
+		":1\r\n",
+		int64(1),
+	},
+	{
+		":-2\r\n",
+		int64(-2),
+	},
+	{
+		"*0\r\n",
+		[]interface{}{},
+	},
+	{
+		"*-1\r\n",
+		nil,
+	},
+	{
+		"*4\r\n$3\r\nfoo\r\n$3\r\nbar\r\n$5\r\nHello\r\n$5\r\nWorld\r\n",
+		[]interface{}{[]byte("foo"), []byte("bar"), []byte("Hello"), []byte("World")},
+	},
+	{
+		"*3\r\n$3\r\nfoo\r\n$-1\r\n$3\r\nbar\r\n",
+		[]interface{}{[]byte("foo"), nil, []byte("bar")},
+	},
+
+	{
+		// "x" is not a valid length
+		"$x\r\nfoobar\r\n",
+		errorSentinel,
+	},
+	{
+		// -2 is not a valid length
+		"$-2\r\n",
+		errorSentinel,
+	},
+	{
+		// "x"  is not a valid integer
+		":x\r\n",
+		errorSentinel,
+	},
+	{
+		// missing \r\n following value
+		"$6\r\nfoobar",
+		errorSentinel,
+	},
+	{
+		// short value
+		"$6\r\nxx",
+		errorSentinel,
+	},
+	{
+		// long value
+		"$6\r\nfoobarx\r\n",
+		errorSentinel,
+	},
+}
+
+func TestRead(t *testing.T) {
+	for _, tt := range readTests {
+		c, _ := redis.Dial("", "", dialTestConn(tt.reply, nil))
+		actual, err := c.Receive()
+		if tt.expected == errorSentinel {
+			if err == nil {
+				t.Errorf("Receive(%q) did not return expected error", tt.reply)
+			}
+		} else {
+			if err != nil {
+				t.Errorf("Receive(%q) returned error %v", tt.reply, err)
+				continue
+			}
+			if !reflect.DeepEqual(actual, tt.expected) {
+				t.Errorf("Receive(%q) = %v, want %v", tt.reply, actual, tt.expected)
+			}
+		}
+	}
+}
+
+var testCommands = []struct {
+	args     []interface{}
+	expected interface{}
+}{
+	{
+		[]interface{}{"PING"},
+		"PONG",
+	},
+	{
+		[]interface{}{"SET", "foo", "bar"},
+		"OK",
+	},
+	{
+		[]interface{}{"GET", "foo"},
+		[]byte("bar"),
+	},
+	{
+		[]interface{}{"GET", "nokey"},
+		nil,
+	},
+	{
+		[]interface{}{"MGET", "nokey", "foo"},
+		[]interface{}{nil, []byte("bar")},
+	},
+	{
+		[]interface{}{"INCR", "mycounter"},
+		int64(1),
+	},
+	{
+		[]interface{}{"LPUSH", "mylist", "foo"},
+		int64(1),
+	},
+	{
+		[]interface{}{"LPUSH", "mylist", "bar"},
+		int64(2),
+	},
+	{
+		[]interface{}{"LRANGE", "mylist", 0, -1},
+		[]interface{}{[]byte("bar"), []byte("foo")},
+	},
+	{
+		[]interface{}{"MULTI"},
+		"OK",
+	},
+	{
+		[]interface{}{"LRANGE", "mylist", 0, -1},
+		"QUEUED",
+	},
+	{
+		[]interface{}{"PING"},
+		"QUEUED",
+	},
+	{
+		[]interface{}{"EXEC"},
+		[]interface{}{
+			[]interface{}{[]byte("bar"), []byte("foo")},
+			"PONG",
+		},
+	},
+}
+
+func TestDoCommands(t *testing.T) {
+	c, err := redis.DialDefaultServer()
+	if err != nil {
+		t.Fatalf("error connection to database, %v", err)
+	}
+	defer c.Close()
+
+	for _, cmd := range testCommands {
+		actual, err := c.Do(cmd.args[0].(string), cmd.args[1:]...)
+		if err != nil {
+			t.Errorf("Do(%v) returned error %v", cmd.args, err)
+			continue
+		}
+		if !reflect.DeepEqual(actual, cmd.expected) {
+			t.Errorf("Do(%v) = %v, want %v", cmd.args, actual, cmd.expected)
+		}
+	}
+}
+
+func TestPipelineCommands(t *testing.T) {
+	c, err := redis.DialDefaultServer()
+	if err != nil {
+		t.Fatalf("error connection to database, %v", err)
+	}
+	defer c.Close()
+
+	for _, cmd := range testCommands {
+		if err := c.Send(cmd.args[0].(string), cmd.args[1:]...); err != nil {
+			t.Fatalf("Send(%v) returned error %v", cmd.args, err)
+		}
+	}
+	if err := c.Flush(); err != nil {
+		t.Errorf("Flush() returned error %v", err)
+	}
+	for _, cmd := range testCommands {
+		actual, err := c.Receive()
+		if err != nil {
+			t.Fatalf("Receive(%v) returned error %v", cmd.args, err)
+		}
+		if !reflect.DeepEqual(actual, cmd.expected) {
+			t.Errorf("Receive(%v) = %v, want %v", cmd.args, actual, cmd.expected)
+		}
+	}
+}
+
+func TestBlankCommmand(t *testing.T) {
+	c, err := redis.DialDefaultServer()
+	if err != nil {
+		t.Fatalf("error connection to database, %v", err)
+	}
+	defer c.Close()
+
+	for _, cmd := range testCommands {
+		if err := c.Send(cmd.args[0].(string), cmd.args[1:]...); err != nil {
+			t.Fatalf("Send(%v) returned error %v", cmd.args, err)
+		}
+	}
+	reply, err := redis.Values(c.Do(""))
+	if err != nil {
+		t.Fatalf("Do() returned error %v", err)
+	}
+	if len(reply) != len(testCommands) {
+		t.Fatalf("len(reply)=%d, want %d", len(reply), len(testCommands))
+	}
+	for i, cmd := range testCommands {
+		actual := reply[i]
+		if !reflect.DeepEqual(actual, cmd.expected) {
+			t.Errorf("Receive(%v) = %v, want %v", cmd.args, actual, cmd.expected)
+		}
+	}
+}
+
+func TestRecvBeforeSend(t *testing.T) {
+	c, err := redis.DialDefaultServer()
+	if err != nil {
+		t.Fatalf("error connection to database, %v", err)
+	}
+	defer c.Close()
+	done := make(chan struct{})
+	go func() {
+		c.Receive()
+		close(done)
+	}()
+	time.Sleep(time.Millisecond)
+	c.Send("PING")
+	c.Flush()
+	<-done
+	_, err = c.Do("")
+	if err != nil {
+		t.Fatalf("error=%v", err)
+	}
+}
+
+func TestError(t *testing.T) {
+	c, err := redis.DialDefaultServer()
+	if err != nil {
+		t.Fatalf("error connection to database, %v", err)
+	}
+	defer c.Close()
+
+	c.Do("SET", "key", "val")
+	_, err = c.Do("HSET", "key", "fld", "val")
+	if err == nil {
+		t.Errorf("Expected err for HSET on string key.")
+	}
+	if c.Err() != nil {
+		t.Errorf("Conn has Err()=%v, expect nil", c.Err())
+	}
+	_, err = c.Do("SET", "key", "val")
+	if err != nil {
+		t.Errorf("Do(SET, key, val) returned error %v, expected nil.", err)
+	}
+}
+
+func TestReadTimeout(t *testing.T) {
+	l, err := net.Listen("tcp", "127.0.0.1:0")
+	if err != nil {
+		t.Fatalf("net.Listen returned %v", err)
+	}
+	defer l.Close()
+
+	go func() {
+		for {
+			c, err := l.Accept()
+			if err != nil {
+				return
+			}
+			go func() {
+				time.Sleep(time.Second)
+				c.Write([]byte("+OK\r\n"))
+				c.Close()
+			}()
+		}
+	}()
+
+	// Do
+
+	c1, err := redis.Dial(l.Addr().Network(), l.Addr().String(), redis.DialReadTimeout(time.Millisecond))
+	if err != nil {
+		t.Fatalf("redis.Dial returned %v", err)
+	}
+	defer c1.Close()
+
+	_, err = c1.Do("PING")
+	if err == nil {
+		t.Fatalf("c1.Do() returned nil, expect error")
+	}
+	if c1.Err() == nil {
+		t.Fatalf("c1.Err() = nil, expect error")
+	}
+
+	// Send/Flush/Receive
+
+	c2, err := redis.Dial(l.Addr().Network(), l.Addr().String(), redis.DialReadTimeout(time.Millisecond))
+	if err != nil {
+		t.Fatalf("redis.Dial returned %v", err)
+	}
+	defer c2.Close()
+
+	c2.Send("PING")
+	c2.Flush()
+	_, err = c2.Receive()
+	if err == nil {
+		t.Fatalf("c2.Receive() returned nil, expect error")
+	}
+	if c2.Err() == nil {
+		t.Fatalf("c2.Err() = nil, expect error")
+	}
+}
+
+var dialErrors = []struct {
+	rawurl        string
+	expectedError string
+}{
+	{
+		"localhost",
+		"invalid redis URL scheme",
+	},
+	// The error message for invalid hosts is different in different
+	// versions of Go, so just check that there is an error message.
+	{
+		"redis://weird url",
+		"",
+	},
+	{
+		"redis://foo:bar:baz",
+		"",
+	},
+	{
+		"http://www.google.com",
+		"invalid redis URL scheme: http",
+	},
+	{
+		"redis://localhost:6379/abc123",
+		"invalid database: abc123",
+	},
+}
+
+func TestDialURLErrors(t *testing.T) {
+	for _, d := range dialErrors {
+		_, err := redis.DialURL(d.rawurl)
+		if err == nil || !strings.Contains(err.Error(), d.expectedError) {
+			t.Errorf("DialURL did not return expected error (expected %v to contain %s)", err, d.expectedError)
+		}
+	}
+}
+
+func TestDialURLPort(t *testing.T) {
+	checkPort := func(network, address string) (net.Conn, error) {
+		if address != "localhost:6379" {
+			t.Errorf("DialURL did not set port to 6379 by default (got %v)", address)
+		}
+		return nil, nil
+	}
+	_, err := redis.DialURL("redis://localhost", redis.DialNetDial(checkPort))
+	if err != nil {
+		t.Error("dial error:", err)
+	}
+}
+
+func TestDialURLHost(t *testing.T) {
+	checkHost := func(network, address string) (net.Conn, error) {
+		if address != "localhost:6379" {
+			t.Errorf("DialURL did not set host to localhost by default (got %v)", address)
+		}
+		return nil, nil
+	}
+	_, err := redis.DialURL("redis://:6379", redis.DialNetDial(checkHost))
+	if err != nil {
+		t.Error("dial error:", err)
+	}
+}
+
+var dialURLTests = []struct {
+	description string
+	url         string
+	r           string
+	w           string
+}{
+	{"password", "redis://x:abc123@localhost", "+OK\r\n", "*2\r\n$4\r\nAUTH\r\n$6\r\nabc123\r\n"},
+	{"database 3", "redis://localhost/3", "+OK\r\n", "*2\r\n$6\r\nSELECT\r\n$1\r\n3\r\n"},
+	{"database 99", "redis://localhost/99", "+OK\r\n", "*2\r\n$6\r\nSELECT\r\n$2\r\n99\r\n"},
+	{"no database", "redis://localhost/", "+OK\r\n", ""},
+}
+
+func TestDialURL(t *testing.T) {
+	for _, tt := range dialURLTests {
+		var buf bytes.Buffer
+		// UseTLS should be ignored in all of these tests.
+		_, err := redis.DialURL(tt.url, dialTestConn(tt.r, &buf), redis.DialUseTLS(true))
+		if err != nil {
+			t.Errorf("%s dial error: %v", tt.description, err)
+			continue
+		}
+		if w := buf.String(); w != tt.w {
+			t.Errorf("%s commands = %q, want %q", tt.description, w, tt.w)
+		}
+	}
+}
+
+func checkPingPong(t *testing.T, buf *bytes.Buffer, c redis.Conn) {
+	resp, err := c.Do("PING")
+	if err != nil {
+		t.Fatal("ping error:", err)
+	}
+	// Close connection to ensure that writes to buf are complete.
+	c.Close()
+	expected := "*1\r\n$4\r\nPING\r\n"
+	actual := buf.String()
+	if actual != expected {
+		t.Errorf("commands = %q, want %q", actual, expected)
+	}
+	if resp != "PONG" {
+		t.Errorf("resp = %v, want %v", resp, "PONG")
+	}
+}
+
+const pingResponse = "+PONG\r\n"
+
+func TestDialURLTLS(t *testing.T) {
+	var buf bytes.Buffer
+	c, err := redis.DialURL("rediss://example.com/",
+		redis.DialTLSConfig(&clientTLSConfig),
+		dialTestConnTLS(pingResponse, &buf))
+	if err != nil {
+		t.Fatal("dial error:", err)
+	}
+	checkPingPong(t, &buf, c)
+}
+
+func TestDialUseTLS(t *testing.T) {
+	var buf bytes.Buffer
+	c, err := redis.Dial("tcp", "example.com:6379",
+		redis.DialTLSConfig(&clientTLSConfig),
+		dialTestConnTLS(pingResponse, &buf),
+		redis.DialUseTLS(true))
+	if err != nil {
+		t.Fatal("dial error:", err)
+	}
+	checkPingPong(t, &buf, c)
+}
+
+func TestDialTLSSKipVerify(t *testing.T) {
+	var buf bytes.Buffer
+	c, err := redis.Dial("tcp", "example.com:6379",
+		dialTestConnTLS(pingResponse, &buf),
+		redis.DialTLSSkipVerify(true),
+		redis.DialUseTLS(true))
+	if err != nil {
+		t.Fatal("dial error:", err)
+	}
+	checkPingPong(t, &buf, c)
+}
+
+// Connect to local instance of Redis running on the default port.
+func ExampleDial() {
+	c, err := redis.Dial("tcp", ":6379")
+	if err != nil {
+		// handle error
+	}
+	defer c.Close()
+}
+
+// Connect to remote instance of Redis using a URL.
+func ExampleDialURL() {
+	c, err := redis.DialURL(os.Getenv("REDIS_URL"))
+	if err != nil {
+		// handle connection error
+	}
+	defer c.Close()
+}
+
+// TextExecError tests handling of errors in a transaction. See
+// http://redis.io/topics/transactions for information on how Redis handles
+// errors in a transaction.
+func TestExecError(t *testing.T) {
+	c, err := redis.DialDefaultServer()
+	if err != nil {
+		t.Fatalf("error connection to database, %v", err)
+	}
+	defer c.Close()
+
+	// Execute commands that fail before EXEC is called.
+
+	c.Do("DEL", "k0")
+	c.Do("ZADD", "k0", 0, 0)
+	c.Send("MULTI")
+	c.Send("NOTACOMMAND", "k0", 0, 0)
+	c.Send("ZINCRBY", "k0", 0, 0)
+	v, err := c.Do("EXEC")
+	if err == nil {
+		t.Fatalf("EXEC returned values %v, expected error", v)
+	}
+
+	// Execute commands that fail after EXEC is called. The first command
+	// returns an error.
+
+	c.Do("DEL", "k1")
+	c.Do("ZADD", "k1", 0, 0)
+	c.Send("MULTI")
+	c.Send("HSET", "k1", 0, 0)
+	c.Send("ZINCRBY", "k1", 0, 0)
+	v, err = c.Do("EXEC")
+	if err != nil {
+		t.Fatalf("EXEC returned error %v", err)
+	}
+
+	vs, err := redis.Values(v, nil)
+	if err != nil {
+		t.Fatalf("Values(v) returned error %v", err)
+	}
+
+	if len(vs) != 2 {
+		t.Fatalf("len(vs) == %d, want 2", len(vs))
+	}
+
+	if _, ok := vs[0].(error); !ok {
+		t.Fatalf("first result is type %T, expected error", vs[0])
+	}
+
+	if _, ok := vs[1].([]byte); !ok {
+		t.Fatalf("second result is type %T, expected []byte", vs[1])
+	}
+
+	// Execute commands that fail after EXEC is called. The second command
+	// returns an error.
+
+	c.Do("ZADD", "k2", 0, 0)
+	c.Send("MULTI")
+	c.Send("ZINCRBY", "k2", 0, 0)
+	c.Send("HSET", "k2", 0, 0)
+	v, err = c.Do("EXEC")
+	if err != nil {
+		t.Fatalf("EXEC returned error %v", err)
+	}
+
+	vs, err = redis.Values(v, nil)
+	if err != nil {
+		t.Fatalf("Values(v) returned error %v", err)
+	}
+
+	if len(vs) != 2 {
+		t.Fatalf("len(vs) == %d, want 2", len(vs))
+	}
+
+	if _, ok := vs[0].([]byte); !ok {
+		t.Fatalf("first result is type %T, expected []byte", vs[0])
+	}
+
+	if _, ok := vs[1].(error); !ok {
+		t.Fatalf("second result is type %T, expected error", vs[2])
+	}
+}
+
+func BenchmarkDoEmpty(b *testing.B) {
+	b.StopTimer()
+	c, err := redis.DialDefaultServer()
+	if err != nil {
+		b.Fatal(err)
+	}
+	defer c.Close()
+	b.StartTimer()
+	for i := 0; i < b.N; i++ {
+		if _, err := c.Do(""); err != nil {
+			b.Fatal(err)
+		}
+	}
+}
+
+func BenchmarkDoPing(b *testing.B) {
+	b.StopTimer()
+	c, err := redis.DialDefaultServer()
+	if err != nil {
+		b.Fatal(err)
+	}
+	defer c.Close()
+	b.StartTimer()
+	for i := 0; i < b.N; i++ {
+		if _, err := c.Do("PING"); err != nil {
+			b.Fatal(err)
+		}
+	}
+}
+
+var clientTLSConfig, serverTLSConfig tls.Config
+
+func init() {
+	// The certificate and key for testing TLS dial options was created
+	// using the command
+	//
+	//   go run GOROOT/src/crypto/tls/generate_cert.go  \
+	//      --rsa-bits 1024 \
+	//      --host 127.0.0.1,::1,example.com --ca \
+	//      --start-date "Jan 1 00:00:00 1970" \
+	//      --duration=1000000h
+	//
+	// where GOROOT is the value of GOROOT reported by go env.
+	localhostCert := []byte(`
+-----BEGIN CERTIFICATE-----
+MIICFDCCAX2gAwIBAgIRAJfBL4CUxkXcdlFurb3K+iowDQYJKoZIhvcNAQELBQAw
+EjEQMA4GA1UEChMHQWNtZSBDbzAgFw03MDAxMDEwMDAwMDBaGA8yMDg0MDEyOTE2
+MDAwMFowEjEQMA4GA1UEChMHQWNtZSBDbzCBnzANBgkqhkiG9w0BAQEFAAOBjQAw
+gYkCgYEArizw8WxMUQ3bGHLeuJ4fDrEpy+L2pqrbYRlKk1DasJ/VkB8bImzIpe6+
+LGjiYIxvnDCOJ3f3QplcQuiuMyl6f2irJlJsbFT8Lo/3obnuTKAIaqUdJUqBg6y+
+JaL8Auk97FvunfKFv8U1AIhgiLzAfQ/3Eaq1yi87Ra6pMjGbTtcCAwEAAaNoMGYw
+DgYDVR0PAQH/BAQDAgKkMBMGA1UdJQQMMAoGCCsGAQUFBwMBMA8GA1UdEwEB/wQF
+MAMBAf8wLgYDVR0RBCcwJYILZXhhbXBsZS5jb22HBH8AAAGHEAAAAAAAAAAAAAAA
+AAAAAAEwDQYJKoZIhvcNAQELBQADgYEAdZ8daIVkyhVwflt5I19m0oq1TycbGO1+
+ach7T6cZiBQeNR/SJtxr/wKPEpmvUgbv2BfFrKJ8QoIHYsbNSURTWSEa02pfw4k9
+6RQhij3ZkG79Ituj5OYRORV6Z0HUW32r670BtcuHuAhq7YA6Nxy4FtSt7bAlVdRt
+rrKgNsltzMk=
+-----END CERTIFICATE-----`)
+
+	localhostKey := []byte(`
+-----BEGIN RSA PRIVATE KEY-----
+MIICXAIBAAKBgQCuLPDxbExRDdsYct64nh8OsSnL4vamqtthGUqTUNqwn9WQHxsi
+bMil7r4saOJgjG+cMI4nd/dCmVxC6K4zKXp/aKsmUmxsVPwuj/ehue5MoAhqpR0l
+SoGDrL4lovwC6T3sW+6d8oW/xTUAiGCIvMB9D/cRqrXKLztFrqkyMZtO1wIDAQAB
+AoGACrc5G6FOEK6JjDeE/Fa+EmlT6PdNtXNNi+vCas3Opo8u1G8VfEi1D4BgstrB
+Eq+RLkrOdB8tVyuYQYWPMhabMqF+hhKJN72j0OwfuPlVvTInwb/cKjo/zbH1IA+Y
+HenHNK4ywv7/p/9/MvQPJ3I32cQBCgGUW5chVSH5M1sj5gECQQDabQAI1X0uDqCm
+KbX9gXVkAgxkFddrt6LBHt57xujFcqEKFE7nwKhDh7DweVs/VEJ+kpid4z+UnLOw
+KjtP9JolAkEAzCNBphQ//IsbH5rNs10wIUw3Ks/Oepicvr6kUFbIv+neRzi1iJHa
+m6H7EayK3PWgax6BAsR/t0Jc9XV7r2muSwJAVzN09BHnK+ADGtNEKLTqXMbEk6B0
+pDhn7ZmZUOkUPN+Kky+QYM11X6Bob1jDqQDGmymDbGUxGO+GfSofC8inUQJAGfci
+Eo3g1a6b9JksMPRZeuLG4ZstGErxJRH6tH1Va5PDwitka8qhk8o2tTjNMO3NSdLH
+diKoXBcE2/Pll5pJoQJBAIMiiMIzXJhnN4mX8may44J/HvMlMf2xuVH2gNMwmZuc
+Bjqn3yoLHaoZVvbWOi0C2TCN4FjXjaLNZGifQPbIcaA=
+-----END RSA PRIVATE KEY-----`)
+
+	cert, err := tls.X509KeyPair(localhostCert, localhostKey)
+	if err != nil {
+		panic(fmt.Sprintf("error creating key pair: %v", err))
+	}
+	serverTLSConfig.Certificates = []tls.Certificate{cert}
+
+	certificate, err := x509.ParseCertificate(serverTLSConfig.Certificates[0].Certificate[0])
+	if err != nil {
+		panic(fmt.Sprintf("error parsing x509 certificate: %v", err))
+	}
+
+	clientTLSConfig.RootCAs = x509.NewCertPool()
+	clientTLSConfig.RootCAs.AddCert(certificate)
+}
+
+func TestWithTimeout(t *testing.T) {
+	for _, recv := range []bool{true, false} {
+		for _, defaultTimout := range []time.Duration{0, time.Minute} {
+			var buf bytes.Buffer
+			nc := &testConn{Reader: strings.NewReader("+OK\r\n+OK\r\n+OK\r\n+OK\r\n+OK\r\n+OK\r\n+OK\r\n+OK\r\n+OK\r\n+OK\r\n"), Writer: &buf}
+			c, _ := redis.Dial("", "", redis.DialReadTimeout(defaultTimout), redis.DialNetDial(func(network, addr string) (net.Conn, error) { return nc, nil }))
+			for i := 0; i < 4; i++ {
+				var minDeadline, maxDeadline time.Time
+
+				// Alternate between default and specified timeout.
+				if i%2 == 0 {
+					if defaultTimout != 0 {
+						minDeadline = time.Now().Add(defaultTimout)
+					}
+					if recv {
+						c.Receive()
+					} else {
+						c.Do("PING")
+					}
+					if defaultTimout != 0 {
+						maxDeadline = time.Now().Add(defaultTimout)
+					}
+				} else {
+					timeout := 10 * time.Minute
+					minDeadline = time.Now().Add(timeout)
+					if recv {
+						redis.ReceiveWithTimeout(c, timeout)
+					} else {
+						redis.DoWithTimeout(c, timeout, "PING")
+					}
+					maxDeadline = time.Now().Add(timeout)
+				}
+
+				// Expect set deadline in expected range.
+				if nc.readDeadline.Before(minDeadline) || nc.readDeadline.After(maxDeadline) {
+					t.Errorf("recv %v, %d: do deadline error: %v, %v, %v", recv, i, minDeadline, nc.readDeadline, maxDeadline)
+				}
+			}
+		}
+	}
+}
Index: mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/doc.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/doc.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/doc.go	(revision 4485)
@@ -0,0 +1,177 @@
+// Copyright 2012 Gary Burd
+//
+// Licensed under the Apache License, Version 2.0 (the "License"): you may
+// not use this file except in compliance with the License. You may obtain
+// a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+// License for the specific language governing permissions and limitations
+// under the License.
+
+// Package redis is a client for the Redis database.
+//
+// The Redigo FAQ (https://github.com/garyburd/redigo/wiki/FAQ) contains more
+// documentation about this package.
+//
+// Connections
+//
+// The Conn interface is the primary interface for working with Redis.
+// Applications create connections by calling the Dial, DialWithTimeout or
+// NewConn functions. In the future, functions will be added for creating
+// sharded and other types of connections.
+//
+// The application must call the connection Close method when the application
+// is done with the connection.
+//
+// Executing Commands
+//
+// The Conn interface has a generic method for executing Redis commands:
+//
+//  Do(commandName string, args ...interface{}) (reply interface{}, err error)
+//
+// The Redis command reference (http://redis.io/commands) lists the available
+// commands. An example of using the Redis APPEND command is:
+//
+//  n, err := conn.Do("APPEND", "key", "value")
+//
+// The Do method converts command arguments to bulk strings for transmission
+// to the server as follows:
+//
+//  Go Type                 Conversion
+//  []byte                  Sent as is
+//  string                  Sent as is
+//  int, int64              strconv.FormatInt(v)
+//  float64                 strconv.FormatFloat(v, 'g', -1, 64)
+//  bool                    true -> "1", false -> "0"
+//  nil                     ""
+//  all other types         fmt.Fprint(w, v)
+//
+// Redis command reply types are represented using the following Go types:
+//
+//  Redis type              Go type
+//  error                   redis.Error
+//  integer                 int64
+//  simple string           string
+//  bulk string             []byte or nil if value not present.
+//  array                   []interface{} or nil if value not present.
+//
+// Use type assertions or the reply helper functions to convert from
+// interface{} to the specific Go type for the command result.
+//
+// Pipelining
+//
+// Connections support pipelining using the Send, Flush and Receive methods.
+//
+//  Send(commandName string, args ...interface{}) error
+//  Flush() error
+//  Receive() (reply interface{}, err error)
+//
+// Send writes the command to the connection's output buffer. Flush flushes the
+// connection's output buffer to the server. Receive reads a single reply from
+// the server. The following example shows a simple pipeline.
+//
+//  c.Send("SET", "foo", "bar")
+//  c.Send("GET", "foo")
+//  c.Flush()
+//  c.Receive() // reply from SET
+//  v, err = c.Receive() // reply from GET
+//
+// The Do method combines the functionality of the Send, Flush and Receive
+// methods. The Do method starts by writing the command and flushing the output
+// buffer. Next, the Do method receives all pending replies including the reply
+// for the command just sent by Do. If any of the received replies is an error,
+// then Do returns the error. If there are no errors, then Do returns the last
+// reply. If the command argument to the Do method is "", then the Do method
+// will flush the output buffer and receive pending replies without sending a
+// command.
+//
+// Use the Send and Do methods to implement pipelined transactions.
+//
+//  c.Send("MULTI")
+//  c.Send("INCR", "foo")
+//  c.Send("INCR", "bar")
+//  r, err := c.Do("EXEC")
+//  fmt.Println(r) // prints [1, 1]
+//
+// Concurrency
+//
+// Connections support one concurrent caller to the Receive method and one
+// concurrent caller to the Send and Flush methods. No other concurrency is
+// supported including concurrent calls to the Do method.
+//
+// For full concurrent access to Redis, use the thread-safe Pool to get, use
+// and release a connection from within a goroutine. Connections returned from
+// a Pool have the concurrency restrictions described in the previous
+// paragraph.
+//
+// Publish and Subscribe
+//
+// Use the Send, Flush and Receive methods to implement Pub/Sub subscribers.
+//
+//  c.Send("SUBSCRIBE", "example")
+//  c.Flush()
+//  for {
+//      reply, err := c.Receive()
+//      if err != nil {
+//          return err
+//      }
+//      // process pushed message
+//  }
+//
+// The PubSubConn type wraps a Conn with convenience methods for implementing
+// subscribers. The Subscribe, PSubscribe, Unsubscribe and PUnsubscribe methods
+// send and flush a subscription management command. The receive method
+// converts a pushed message to convenient types for use in a type switch.
+//
+//  psc := redis.PubSubConn{Conn: c}
+//  psc.Subscribe("example")
+//  for {
+//      switch v := psc.Receive().(type) {
+//      case redis.Message:
+//          fmt.Printf("%s: message: %s\n", v.Channel, v.Data)
+//      case redis.Subscription:
+//          fmt.Printf("%s: %s %d\n", v.Channel, v.Kind, v.Count)
+//      case error:
+//          return v
+//      }
+//  }
+//
+// Reply Helpers
+//
+// The Bool, Int, Bytes, String, Strings and Values functions convert a reply
+// to a value of a specific type. To allow convenient wrapping of calls to the
+// connection Do and Receive methods, the functions take a second argument of
+// type error.  If the error is non-nil, then the helper function returns the
+// error. If the error is nil, the function converts the reply to the specified
+// type:
+//
+//  exists, err := redis.Bool(c.Do("EXISTS", "foo"))
+//  if err != nil {
+//      // handle error return from c.Do or type conversion error.
+//  }
+//
+// The Scan function converts elements of a array reply to Go types:
+//
+//  var value1 int
+//  var value2 string
+//  reply, err := redis.Values(c.Do("MGET", "key1", "key2"))
+//  if err != nil {
+//      // handle error
+//  }
+//   if _, err := redis.Scan(reply, &value1, &value2); err != nil {
+//      // handle error
+//  }
+//
+// Errors
+//
+// Connection methods return error replies from the server as type redis.Error.
+//
+// Call the connection Err() method to determine if the connection encountered
+// non-recoverable error such as a network error or protocol parsing error. If
+// Err() returns a non-nil value, then the connection is not usable and should
+// be closed.
+package redis // import "github.com/garyburd/redigo/redis"
Index: mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/go16.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/go16.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/go16.go	(revision 4485)
@@ -0,0 +1,27 @@
+// +build !go1.7
+
+package redis
+
+import "crypto/tls"
+
+func cloneTLSConfig(cfg *tls.Config) *tls.Config {
+	return &tls.Config{
+		Rand:                     cfg.Rand,
+		Time:                     cfg.Time,
+		Certificates:             cfg.Certificates,
+		NameToCertificate:        cfg.NameToCertificate,
+		GetCertificate:           cfg.GetCertificate,
+		RootCAs:                  cfg.RootCAs,
+		NextProtos:               cfg.NextProtos,
+		ServerName:               cfg.ServerName,
+		ClientAuth:               cfg.ClientAuth,
+		ClientCAs:                cfg.ClientCAs,
+		InsecureSkipVerify:       cfg.InsecureSkipVerify,
+		CipherSuites:             cfg.CipherSuites,
+		PreferServerCipherSuites: cfg.PreferServerCipherSuites,
+		ClientSessionCache:       cfg.ClientSessionCache,
+		MinVersion:               cfg.MinVersion,
+		MaxVersion:               cfg.MaxVersion,
+		CurvePreferences:         cfg.CurvePreferences,
+	}
+}
Index: mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/go17.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/go17.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/go17.go	(revision 4485)
@@ -0,0 +1,29 @@
+// +build go1.7,!go1.8
+
+package redis
+
+import "crypto/tls"
+
+func cloneTLSConfig(cfg *tls.Config) *tls.Config {
+	return &tls.Config{
+		Rand:                        cfg.Rand,
+		Time:                        cfg.Time,
+		Certificates:                cfg.Certificates,
+		NameToCertificate:           cfg.NameToCertificate,
+		GetCertificate:              cfg.GetCertificate,
+		RootCAs:                     cfg.RootCAs,
+		NextProtos:                  cfg.NextProtos,
+		ServerName:                  cfg.ServerName,
+		ClientAuth:                  cfg.ClientAuth,
+		ClientCAs:                   cfg.ClientCAs,
+		InsecureSkipVerify:          cfg.InsecureSkipVerify,
+		CipherSuites:                cfg.CipherSuites,
+		PreferServerCipherSuites:    cfg.PreferServerCipherSuites,
+		ClientSessionCache:          cfg.ClientSessionCache,
+		MinVersion:                  cfg.MinVersion,
+		MaxVersion:                  cfg.MaxVersion,
+		CurvePreferences:            cfg.CurvePreferences,
+		DynamicRecordSizingDisabled: cfg.DynamicRecordSizingDisabled,
+		Renegotiation:               cfg.Renegotiation,
+	}
+}
Index: mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/go18.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/go18.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/go18.go	(revision 4485)
@@ -0,0 +1,9 @@
+// +build go1.8
+
+package redis
+
+import "crypto/tls"
+
+func cloneTLSConfig(cfg *tls.Config) *tls.Config {
+	return cfg.Clone()
+}
Index: mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/list_test.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/list_test.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/list_test.go	(revision 4485)
@@ -0,0 +1,85 @@
+// Copyright 2018 Gary Burd
+//
+// Licensed under the Apache License, Version 2.0 (the "License"): you may
+// not use this file except in compliance with the License. You may obtain
+// a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+// License for the specific language governing permissions and limitations
+// under the License.
+
+// +build go1.9
+
+package redis
+
+import "testing"
+
+func TestPoolList(t *testing.T) {
+	var idle idleList
+	var a, b, c poolConn
+
+	check := func(pcs ...*poolConn) {
+		if idle.count != len(pcs) {
+			t.Fatal("idle.count != len(pcs)")
+		}
+		if len(pcs) == 0 {
+			if idle.front != nil {
+				t.Fatalf("front not nil")
+			}
+			if idle.back != nil {
+				t.Fatalf("back not nil")
+			}
+			return
+		}
+		if idle.front != pcs[0] {
+			t.Fatal("front != pcs[0]")
+		}
+		if idle.back != pcs[len(pcs)-1] {
+			t.Fatal("back != pcs[len(pcs)-1]")
+		}
+		if idle.front.prev != nil {
+			t.Fatal("front.prev != nil")
+		}
+		if idle.back.next != nil {
+			t.Fatal("back.next != nil")
+		}
+		for i := 1; i < len(pcs)-1; i++ {
+			if pcs[i-1].next != pcs[i] {
+				t.Fatal("pcs[i-1].next != pcs[i]")
+			}
+			if pcs[i+1].prev != pcs[i] {
+				t.Fatal("pcs[i+1].prev != pcs[i]")
+			}
+		}
+	}
+
+	idle.pushFront(&c)
+	check(&c)
+	idle.pushFront(&b)
+	check(&b, &c)
+	idle.pushFront(&a)
+	check(&a, &b, &c)
+	idle.popFront()
+	check(&b, &c)
+	idle.popFront()
+	check(&c)
+	idle.popFront()
+	check()
+
+	idle.pushFront(&c)
+	check(&c)
+	idle.pushFront(&b)
+	check(&b, &c)
+	idle.pushFront(&a)
+	check(&a, &b, &c)
+	idle.popBack()
+	check(&a, &b)
+	idle.popBack()
+	check(&a)
+	idle.popBack()
+	check()
+}
Index: mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/log.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/log.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/log.go	(revision 4485)
@@ -0,0 +1,134 @@
+// Copyright 2012 Gary Burd
+//
+// Licensed under the Apache License, Version 2.0 (the "License"): you may
+// not use this file except in compliance with the License. You may obtain
+// a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+// License for the specific language governing permissions and limitations
+// under the License.
+
+package redis
+
+import (
+	"bytes"
+	"fmt"
+	"log"
+	"time"
+)
+
+var (
+	_ ConnWithTimeout = (*loggingConn)(nil)
+)
+
+// NewLoggingConn returns a logging wrapper around a connection.
+func NewLoggingConn(conn Conn, logger *log.Logger, prefix string) Conn {
+	if prefix != "" {
+		prefix = prefix + "."
+	}
+	return &loggingConn{conn, logger, prefix}
+}
+
+type loggingConn struct {
+	Conn
+	logger *log.Logger
+	prefix string
+}
+
+func (c *loggingConn) Close() error {
+	err := c.Conn.Close()
+	var buf bytes.Buffer
+	fmt.Fprintf(&buf, "%sClose() -> (%v)", c.prefix, err)
+	c.logger.Output(2, buf.String())
+	return err
+}
+
+func (c *loggingConn) printValue(buf *bytes.Buffer, v interface{}) {
+	const chop = 32
+	switch v := v.(type) {
+	case []byte:
+		if len(v) > chop {
+			fmt.Fprintf(buf, "%q...", v[:chop])
+		} else {
+			fmt.Fprintf(buf, "%q", v)
+		}
+	case string:
+		if len(v) > chop {
+			fmt.Fprintf(buf, "%q...", v[:chop])
+		} else {
+			fmt.Fprintf(buf, "%q", v)
+		}
+	case []interface{}:
+		if len(v) == 0 {
+			buf.WriteString("[]")
+		} else {
+			sep := "["
+			fin := "]"
+			if len(v) > chop {
+				v = v[:chop]
+				fin = "...]"
+			}
+			for _, vv := range v {
+				buf.WriteString(sep)
+				c.printValue(buf, vv)
+				sep = ", "
+			}
+			buf.WriteString(fin)
+		}
+	default:
+		fmt.Fprint(buf, v)
+	}
+}
+
+func (c *loggingConn) print(method, commandName string, args []interface{}, reply interface{}, err error) {
+	var buf bytes.Buffer
+	fmt.Fprintf(&buf, "%s%s(", c.prefix, method)
+	if method != "Receive" {
+		buf.WriteString(commandName)
+		for _, arg := range args {
+			buf.WriteString(", ")
+			c.printValue(&buf, arg)
+		}
+	}
+	buf.WriteString(") -> (")
+	if method != "Send" {
+		c.printValue(&buf, reply)
+		buf.WriteString(", ")
+	}
+	fmt.Fprintf(&buf, "%v)", err)
+	c.logger.Output(3, buf.String())
+}
+
+func (c *loggingConn) Do(commandName string, args ...interface{}) (interface{}, error) {
+	reply, err := c.Conn.Do(commandName, args...)
+	c.print("Do", commandName, args, reply, err)
+	return reply, err
+}
+
+func (c *loggingConn) DoWithTimeout(timeout time.Duration, commandName string, args ...interface{}) (interface{}, error) {
+	reply, err := DoWithTimeout(c.Conn, timeout, commandName, args...)
+	c.print("DoWithTimeout", commandName, args, reply, err)
+	return reply, err
+}
+
+func (c *loggingConn) Send(commandName string, args ...interface{}) error {
+	err := c.Conn.Send(commandName, args...)
+	c.print("Send", commandName, args, nil, err)
+	return err
+}
+
+func (c *loggingConn) Receive() (interface{}, error) {
+	reply, err := c.Conn.Receive()
+	c.print("Receive", "", nil, reply, err)
+	return reply, err
+}
+
+func (c *loggingConn) ReceiveWithTimeout(timeout time.Duration) (interface{}, error) {
+	reply, err := ReceiveWithTimeout(c.Conn, timeout)
+	c.print("ReceiveWithTimeout", "", nil, reply, err)
+	return reply, err
+}
Index: mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/pool.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/pool.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/pool.go	(revision 4485)
@@ -0,0 +1,562 @@
+// Copyright 2012 Gary Burd
+//
+// Licensed under the Apache License, Version 2.0 (the "License"): you may
+// not use this file except in compliance with the License. You may obtain
+// a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+// License for the specific language governing permissions and limitations
+// under the License.
+
+package redis
+
+import (
+	"bytes"
+	"crypto/rand"
+	"crypto/sha1"
+	"errors"
+	"io"
+	"strconv"
+	"sync"
+	"sync/atomic"
+	"time"
+
+	"github.com/garyburd/redigo/internal"
+)
+
+var (
+	_ ConnWithTimeout = (*activeConn)(nil)
+	_ ConnWithTimeout = (*errorConn)(nil)
+)
+
+var nowFunc = time.Now // for testing
+
+// ErrPoolExhausted is returned from a pool connection method (Do, Send,
+// Receive, Flush, Err) when the maximum number of database connections in the
+// pool has been reached.
+var ErrPoolExhausted = errors.New("redigo: connection pool exhausted")
+
+var (
+	errPoolClosed = errors.New("redigo: connection pool closed")
+	errConnClosed = errors.New("redigo: connection closed")
+)
+
+// Pool maintains a pool of connections. The application calls the Get method
+// to get a connection from the pool and the connection's Close method to
+// return the connection's resources to the pool.
+//
+// The following example shows how to use a pool in a web application. The
+// application creates a pool at application startup and makes it available to
+// request handlers using a package level variable. The pool configuration used
+// here is an example, not a recommendation.
+//
+//  func newPool(addr string) *redis.Pool {
+//    return &redis.Pool{
+//      MaxIdle: 3,
+//      IdleTimeout: 240 * time.Second,
+//      Dial: func () (redis.Conn, error) { return redis.Dial("tcp", addr) },
+//    }
+//  }
+//
+//  var (
+//    pool *redis.Pool
+//    redisServer = flag.String("redisServer", ":6379", "")
+//  )
+//
+//  func main() {
+//    flag.Parse()
+//    pool = newPool(*redisServer)
+//    ...
+//  }
+//
+// A request handler gets a connection from the pool and closes the connection
+// when the handler is done:
+//
+//  func serveHome(w http.ResponseWriter, r *http.Request) {
+//      conn := pool.Get()
+//      defer conn.Close()
+//      ...
+//  }
+//
+// Use the Dial function to authenticate connections with the AUTH command or
+// select a database with the SELECT command:
+//
+//  pool := &redis.Pool{
+//    // Other pool configuration not shown in this example.
+//    Dial: func () (redis.Conn, error) {
+//      c, err := redis.Dial("tcp", server)
+//      if err != nil {
+//        return nil, err
+//      }
+//      if _, err := c.Do("AUTH", password); err != nil {
+//        c.Close()
+//        return nil, err
+//      }
+//      if _, err := c.Do("SELECT", db); err != nil {
+//        c.Close()
+//        return nil, err
+//      }
+//      return c, nil
+//    },
+//  }
+//
+// Use the TestOnBorrow function to check the health of an idle connection
+// before the connection is returned to the application. This example PINGs
+// connections that have been idle more than a minute:
+//
+//  pool := &redis.Pool{
+//    // Other pool configuration not shown in this example.
+//    TestOnBorrow: func(c redis.Conn, t time.Time) error {
+//      if time.Since(t) < time.Minute {
+//        return nil
+//      }
+//      _, err := c.Do("PING")
+//      return err
+//    },
+//  }
+//
+type Pool struct {
+	// Dial is an application supplied function for creating and configuring a
+	// connection.
+	//
+	// The connection returned from Dial must not be in a special state
+	// (subscribed to pubsub channel, transaction started, ...).
+	Dial func() (Conn, error)
+
+	// TestOnBorrow is an optional application supplied function for checking
+	// the health of an idle connection before the connection is used again by
+	// the application. Argument t is the time that the connection was returned
+	// to the pool. If the function returns an error, then the connection is
+	// closed.
+	TestOnBorrow func(c Conn, t time.Time) error
+
+	// Maximum number of idle connections in the pool.
+	MaxIdle int
+
+	// Maximum number of connections allocated by the pool at a given time.
+	// When zero, there is no limit on the number of connections in the pool.
+	MaxActive int
+
+	// Close connections after remaining idle for this duration. If the value
+	// is zero, then idle connections are not closed. Applications should set
+	// the timeout to a value less than the server's timeout.
+	IdleTimeout time.Duration
+
+	// If Wait is true and the pool is at the MaxActive limit, then Get() waits
+	// for a connection to be returned to the pool before returning.
+	Wait bool
+
+	// Close connections older than this duration. If the value is zero, then
+	// the pool does not close connections based on age.
+	MaxConnLifetime time.Duration
+
+	chInitialized uint32 // set to 1 when field ch is initialized
+
+	mu     sync.Mutex    // mu protects the following fields
+	closed bool          // set to true when the pool is closed.
+	active int           // the number of open connections in the pool
+	ch     chan struct{} // limits open connections when p.Wait is true
+	idle   idleList      // idle connections
+}
+
+// NewPool creates a new pool.
+//
+// Deprecated: Initialize the Pool directory as shown in the example.
+func NewPool(newFn func() (Conn, error), maxIdle int) *Pool {
+	return &Pool{Dial: newFn, MaxIdle: maxIdle}
+}
+
+// Get gets a connection. The application must close the returned connection.
+// This method always returns a valid connection so that applications can defer
+// error handling to the first use of the connection. If there is an error
+// getting an underlying connection, then the connection Err, Do, Send, Flush
+// and Receive methods return that error.
+func (p *Pool) Get() Conn {
+	pc, err := p.get(nil)
+	if err != nil {
+		return errorConn{err}
+	}
+	return &activeConn{p: p, pc: pc}
+}
+
+// PoolStats contains pool statistics.
+type PoolStats struct {
+	// ActiveCount is the number of connections in the pool. The count includes
+	// idle connections and connections in use.
+	ActiveCount int
+	// IdleCount is the number of idle connections in the pool.
+	IdleCount int
+}
+
+// Stats returns pool's statistics.
+func (p *Pool) Stats() PoolStats {
+	p.mu.Lock()
+	stats := PoolStats{
+		ActiveCount: p.active,
+		IdleCount:   p.idle.count,
+	}
+	p.mu.Unlock()
+
+	return stats
+}
+
+// ActiveCount returns the number of connections in the pool. The count
+// includes idle connections and connections in use.
+func (p *Pool) ActiveCount() int {
+	p.mu.Lock()
+	active := p.active
+	p.mu.Unlock()
+	return active
+}
+
+// IdleCount returns the number of idle connections in the pool.
+func (p *Pool) IdleCount() int {
+	p.mu.Lock()
+	idle := p.idle.count
+	p.mu.Unlock()
+	return idle
+}
+
+// Close releases the resources used by the pool.
+func (p *Pool) Close() error {
+	p.mu.Lock()
+	if p.closed {
+		p.mu.Unlock()
+		return nil
+	}
+	p.closed = true
+	p.active -= p.idle.count
+	pc := p.idle.front
+	p.idle.count = 0
+	p.idle.front, p.idle.back = nil, nil
+	if p.ch != nil {
+		close(p.ch)
+	}
+	p.mu.Unlock()
+	for ; pc != nil; pc = pc.next {
+		pc.c.Close()
+	}
+	return nil
+}
+
+func (p *Pool) lazyInit() {
+	// Fast path.
+	if atomic.LoadUint32(&p.chInitialized) == 1 {
+		return
+	}
+	// Slow path.
+	p.mu.Lock()
+	if p.chInitialized == 0 {
+		p.ch = make(chan struct{}, p.MaxActive)
+		if p.closed {
+			close(p.ch)
+		} else {
+			for i := 0; i < p.MaxActive; i++ {
+				p.ch <- struct{}{}
+			}
+		}
+		atomic.StoreUint32(&p.chInitialized, 1)
+	}
+	p.mu.Unlock()
+}
+
+// get prunes stale connections and returns a connection from the idle list or
+// creates a new connection.
+func (p *Pool) get(ctx interface {
+	Done() <-chan struct{}
+	Err() error
+}) (*poolConn, error) {
+
+	// Handle limit for p.Wait == true.
+	if p.Wait && p.MaxActive > 0 {
+		p.lazyInit()
+		if ctx == nil {
+			<-p.ch
+		} else {
+			select {
+			case <-p.ch:
+			case <-ctx.Done():
+				return nil, ctx.Err()
+			}
+		}
+	}
+
+	p.mu.Lock()
+
+	// Prune stale connections at the back of the idle list.
+	if p.IdleTimeout > 0 {
+		n := p.idle.count
+		for i := 0; i < n && p.idle.back != nil && p.idle.back.t.Add(p.IdleTimeout).Before(nowFunc()); i++ {
+			pc := p.idle.back
+			p.idle.popBack()
+			p.mu.Unlock()
+			pc.c.Close()
+			p.mu.Lock()
+			p.active--
+		}
+	}
+
+	// Get idle connection from the front of idle list.
+	for p.idle.front != nil {
+		pc := p.idle.front
+		p.idle.popFront()
+		p.mu.Unlock()
+		if (p.TestOnBorrow == nil || p.TestOnBorrow(pc.c, pc.t) == nil) &&
+			(p.MaxConnLifetime == 0 || nowFunc().Sub(pc.created) < p.MaxConnLifetime) {
+			return pc, nil
+		}
+		pc.c.Close()
+		p.mu.Lock()
+		p.active--
+	}
+
+	// Check for pool closed before dialing a new connection.
+	if p.closed {
+		p.mu.Unlock()
+		return nil, errors.New("redigo: get on closed pool")
+	}
+
+	// Handle limit for p.Wait == false.
+	if !p.Wait && p.MaxActive > 0 && p.active >= p.MaxActive {
+		p.mu.Unlock()
+		return nil, ErrPoolExhausted
+	}
+
+	p.active++
+	p.mu.Unlock()
+	c, err := p.Dial()
+	if err != nil {
+		c = nil
+		p.mu.Lock()
+		p.active--
+		if p.ch != nil && !p.closed {
+			p.ch <- struct{}{}
+		}
+		p.mu.Unlock()
+	}
+	return &poolConn{c: c, created: nowFunc()}, err
+}
+
+func (p *Pool) put(pc *poolConn, forceClose bool) error {
+	p.mu.Lock()
+	if !p.closed && !forceClose {
+		pc.t = nowFunc()
+		p.idle.pushFront(pc)
+		if p.idle.count > p.MaxIdle {
+			pc = p.idle.back
+			p.idle.popBack()
+		} else {
+			pc = nil
+		}
+	}
+
+	if pc != nil {
+		p.mu.Unlock()
+		pc.c.Close()
+		p.mu.Lock()
+		p.active--
+	}
+
+	if p.ch != nil && !p.closed {
+		p.ch <- struct{}{}
+	}
+	p.mu.Unlock()
+	return nil
+}
+
+type activeConn struct {
+	p     *Pool
+	pc    *poolConn
+	state int
+}
+
+var (
+	sentinel     []byte
+	sentinelOnce sync.Once
+)
+
+func initSentinel() {
+	p := make([]byte, 64)
+	if _, err := rand.Read(p); err == nil {
+		sentinel = p
+	} else {
+		h := sha1.New()
+		io.WriteString(h, "Oops, rand failed. Use time instead.")
+		io.WriteString(h, strconv.FormatInt(time.Now().UnixNano(), 10))
+		sentinel = h.Sum(nil)
+	}
+}
+
+func (ac *activeConn) Close() error {
+	pc := ac.pc
+	if pc == nil {
+		return nil
+	}
+	ac.pc = nil
+
+	if ac.state&internal.MultiState != 0 {
+		pc.c.Send("DISCARD")
+		ac.state &^= (internal.MultiState | internal.WatchState)
+	} else if ac.state&internal.WatchState != 0 {
+		pc.c.Send("UNWATCH")
+		ac.state &^= internal.WatchState
+	}
+	if ac.state&internal.SubscribeState != 0 {
+		pc.c.Send("UNSUBSCRIBE")
+		pc.c.Send("PUNSUBSCRIBE")
+		// To detect the end of the message stream, ask the server to echo
+		// a sentinel value and read until we see that value.
+		sentinelOnce.Do(initSentinel)
+		pc.c.Send("ECHO", sentinel)
+		pc.c.Flush()
+		for {
+			p, err := pc.c.Receive()
+			if err != nil {
+				break
+			}
+			if p, ok := p.([]byte); ok && bytes.Equal(p, sentinel) {
+				ac.state &^= internal.SubscribeState
+				break
+			}
+		}
+	}
+	pc.c.Do("")
+	ac.p.put(pc, ac.state != 0 || pc.c.Err() != nil)
+	return nil
+}
+
+func (ac *activeConn) Err() error {
+	pc := ac.pc
+	if pc == nil {
+		return errConnClosed
+	}
+	return pc.c.Err()
+}
+
+func (ac *activeConn) Do(commandName string, args ...interface{}) (reply interface{}, err error) {
+	pc := ac.pc
+	if pc == nil {
+		return nil, errConnClosed
+	}
+	ci := internal.LookupCommandInfo(commandName)
+	ac.state = (ac.state | ci.Set) &^ ci.Clear
+	return pc.c.Do(commandName, args...)
+}
+
+func (ac *activeConn) DoWithTimeout(timeout time.Duration, commandName string, args ...interface{}) (reply interface{}, err error) {
+	pc := ac.pc
+	if pc == nil {
+		return nil, errConnClosed
+	}
+	cwt, ok := pc.c.(ConnWithTimeout)
+	if !ok {
+		return nil, errTimeoutNotSupported
+	}
+	ci := internal.LookupCommandInfo(commandName)
+	ac.state = (ac.state | ci.Set) &^ ci.Clear
+	return cwt.DoWithTimeout(timeout, commandName, args...)
+}
+
+func (ac *activeConn) Send(commandName string, args ...interface{}) error {
+	pc := ac.pc
+	if pc == nil {
+		return errConnClosed
+	}
+	ci := internal.LookupCommandInfo(commandName)
+	ac.state = (ac.state | ci.Set) &^ ci.Clear
+	return pc.c.Send(commandName, args...)
+}
+
+func (ac *activeConn) Flush() error {
+	pc := ac.pc
+	if pc == nil {
+		return errConnClosed
+	}
+	return pc.c.Flush()
+}
+
+func (ac *activeConn) Receive() (reply interface{}, err error) {
+	pc := ac.pc
+	if pc == nil {
+		return nil, errConnClosed
+	}
+	return pc.c.Receive()
+}
+
+func (ac *activeConn) ReceiveWithTimeout(timeout time.Duration) (reply interface{}, err error) {
+	pc := ac.pc
+	if pc == nil {
+		return nil, errConnClosed
+	}
+	cwt, ok := pc.c.(ConnWithTimeout)
+	if !ok {
+		return nil, errTimeoutNotSupported
+	}
+	return cwt.ReceiveWithTimeout(timeout)
+}
+
+type errorConn struct{ err error }
+
+func (ec errorConn) Do(string, ...interface{}) (interface{}, error) { return nil, ec.err }
+func (ec errorConn) DoWithTimeout(time.Duration, string, ...interface{}) (interface{}, error) {
+	return nil, ec.err
+}
+func (ec errorConn) Send(string, ...interface{}) error                     { return ec.err }
+func (ec errorConn) Err() error                                            { return ec.err }
+func (ec errorConn) Close() error                                          { return nil }
+func (ec errorConn) Flush() error                                          { return ec.err }
+func (ec errorConn) Receive() (interface{}, error)                         { return nil, ec.err }
+func (ec errorConn) ReceiveWithTimeout(time.Duration) (interface{}, error) { return nil, ec.err }
+
+type idleList struct {
+	count       int
+	front, back *poolConn
+}
+
+type poolConn struct {
+	c          Conn
+	t          time.Time
+	created    time.Time
+	next, prev *poolConn
+}
+
+func (l *idleList) pushFront(pc *poolConn) {
+	pc.next = l.front
+	pc.prev = nil
+	if l.count == 0 {
+		l.back = pc
+	} else {
+		l.front.prev = pc
+	}
+	l.front = pc
+	l.count++
+	return
+}
+
+func (l *idleList) popFront() {
+	pc := l.front
+	l.count--
+	if l.count == 0 {
+		l.front, l.back = nil, nil
+	} else {
+		pc.next.prev = nil
+		l.front = pc.next
+	}
+	pc.next, pc.prev = nil, nil
+}
+
+func (l *idleList) popBack() {
+	pc := l.back
+	l.count--
+	if l.count == 0 {
+		l.front, l.back = nil, nil
+	} else {
+		pc.prev.next = nil
+		l.back = pc.prev
+	}
+	pc.next, pc.prev = nil, nil
+}
Index: mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/pool17.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/pool17.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/pool17.go	(revision 4485)
@@ -0,0 +1,35 @@
+// Copyright 2018 Gary Burd
+//
+// Licensed under the Apache License, Version 2.0 (the "License"): you may
+// not use this file except in compliance with the License. You may obtain
+// a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+// License for the specific language governing permissions and limitations
+// under the License.
+
+// +build go1.7
+
+package redis
+
+import "context"
+
+// GetContext gets a connection using the provided context.
+//
+// The provided Context must be non-nil. If the context expires before the
+// connection is complete, an error is returned. Any expiration on the context
+// will not affect the returned connection.
+//
+// If the function completes without error, then the application must close the
+// returned connection.
+func (p *Pool) GetContext(ctx context.Context) (Conn, error) {
+	pc, err := p.get(ctx)
+	if err != nil {
+		return errorConn{err}, err
+	}
+	return &activeConn{p: p, pc: pc}, nil
+}
Index: mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/pool17_test.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/pool17_test.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/pool17_test.go	(revision 4485)
@@ -0,0 +1,74 @@
+// Copyright 2018 Gary Burd
+//
+// Licensed under the Apache License, Version 2.0 (the "License"): you may
+// not use this file except in compliance with the License. You may obtain
+// a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+// License for the specific language governing permissions and limitations
+// under the License.
+
+// +build go1.7
+
+package redis_test
+
+import (
+	"context"
+	"testing"
+
+	"github.com/garyburd/redigo/redis"
+)
+
+func TestWaitPoolGetContext(t *testing.T) {
+	d := poolDialer{t: t}
+	p := &redis.Pool{
+		MaxIdle:   1,
+		MaxActive: 1,
+		Dial:      d.dial,
+		Wait:      true,
+	}
+	defer p.Close()
+	c, err := p.GetContext(context.Background())
+	if err != nil {
+		t.Fatalf("GetContext returned %v", err)
+	}
+	defer c.Close()
+}
+
+func TestWaitPoolGetAfterClose(t *testing.T) {
+	d := poolDialer{t: t}
+	p := &redis.Pool{
+		MaxIdle:   1,
+		MaxActive: 1,
+		Dial:      d.dial,
+		Wait:      true,
+	}
+	p.Close()
+	_, err := p.GetContext(context.Background())
+	if err == nil {
+		t.Fatal("expected error")
+	}
+}
+
+func TestWaitPoolGetCanceledContext(t *testing.T) {
+	d := poolDialer{t: t}
+	p := &redis.Pool{
+		MaxIdle:   1,
+		MaxActive: 1,
+		Dial:      d.dial,
+		Wait:      true,
+	}
+	defer p.Close()
+	ctx, f := context.WithCancel(context.Background())
+	f()
+	c := p.Get()
+	defer c.Close()
+	_, err := p.GetContext(ctx)
+	if err != context.Canceled {
+		t.Fatalf("got error %v, want %v", err, context.Canceled)
+	}
+}
Index: mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/pool_test.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/pool_test.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/pool_test.go	(revision 4485)
@@ -0,0 +1,746 @@
+// Copyright 2011 Gary Burd
+//
+// Licensed under the Apache License, Version 2.0 (the "License"): you may
+// not use this file except in compliance with the License. You may obtain
+// a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+// License for the specific language governing permissions and limitations
+// under the License.
+
+package redis_test
+
+import (
+	"errors"
+	"io"
+	"reflect"
+	"sync"
+	"testing"
+	"time"
+
+	"github.com/garyburd/redigo/redis"
+)
+
+type poolTestConn struct {
+	d   *poolDialer
+	err error
+	redis.Conn
+}
+
+func (c *poolTestConn) Close() error {
+	c.d.mu.Lock()
+	c.d.open -= 1
+	c.d.mu.Unlock()
+	return c.Conn.Close()
+}
+
+func (c *poolTestConn) Err() error { return c.err }
+
+func (c *poolTestConn) Do(commandName string, args ...interface{}) (interface{}, error) {
+	if commandName == "ERR" {
+		c.err = args[0].(error)
+		commandName = "PING"
+	}
+	if commandName != "" {
+		c.d.commands = append(c.d.commands, commandName)
+	}
+	return c.Conn.Do(commandName, args...)
+}
+
+func (c *poolTestConn) Send(commandName string, args ...interface{}) error {
+	c.d.commands = append(c.d.commands, commandName)
+	return c.Conn.Send(commandName, args...)
+}
+
+type poolDialer struct {
+	mu       sync.Mutex
+	t        *testing.T
+	dialed   int
+	open     int
+	commands []string
+	dialErr  error
+}
+
+func (d *poolDialer) dial() (redis.Conn, error) {
+	d.mu.Lock()
+	d.dialed += 1
+	dialErr := d.dialErr
+	d.mu.Unlock()
+	if dialErr != nil {
+		return nil, d.dialErr
+	}
+	c, err := redis.DialDefaultServer()
+	if err != nil {
+		return nil, err
+	}
+	d.mu.Lock()
+	d.open += 1
+	d.mu.Unlock()
+	return &poolTestConn{d: d, Conn: c}, nil
+}
+
+func (d *poolDialer) check(message string, p *redis.Pool, dialed, open, inuse int) {
+	d.mu.Lock()
+	if d.dialed != dialed {
+		d.t.Errorf("%s: dialed=%d, want %d", message, d.dialed, dialed)
+	}
+	if d.open != open {
+		d.t.Errorf("%s: open=%d, want %d", message, d.open, open)
+	}
+
+	stats := p.Stats()
+
+	if stats.ActiveCount != open {
+		d.t.Errorf("%s: active=%d, want %d", message, stats.ActiveCount, open)
+	}
+	if stats.IdleCount != open-inuse {
+		d.t.Errorf("%s: idle=%d, want %d", message, stats.IdleCount, open-inuse)
+	}
+
+	d.mu.Unlock()
+}
+
+func TestPoolReuse(t *testing.T) {
+	d := poolDialer{t: t}
+	p := &redis.Pool{
+		MaxIdle: 2,
+		Dial:    d.dial,
+	}
+
+	for i := 0; i < 10; i++ {
+		c1 := p.Get()
+		c1.Do("PING")
+		c2 := p.Get()
+		c2.Do("PING")
+		c1.Close()
+		c2.Close()
+	}
+
+	d.check("before close", p, 2, 2, 0)
+	p.Close()
+	d.check("after close", p, 2, 0, 0)
+}
+
+func TestPoolMaxIdle(t *testing.T) {
+	d := poolDialer{t: t}
+	p := &redis.Pool{
+		MaxIdle: 2,
+		Dial:    d.dial,
+	}
+	defer p.Close()
+
+	for i := 0; i < 10; i++ {
+		c1 := p.Get()
+		c1.Do("PING")
+		c2 := p.Get()
+		c2.Do("PING")
+		c3 := p.Get()
+		c3.Do("PING")
+		c1.Close()
+		c2.Close()
+		c3.Close()
+	}
+	d.check("before close", p, 12, 2, 0)
+	p.Close()
+	d.check("after close", p, 12, 0, 0)
+}
+
+func TestPoolError(t *testing.T) {
+	d := poolDialer{t: t}
+	p := &redis.Pool{
+		MaxIdle: 2,
+		Dial:    d.dial,
+	}
+	defer p.Close()
+
+	c := p.Get()
+	c.Do("ERR", io.EOF)
+	if c.Err() == nil {
+		t.Errorf("expected c.Err() != nil")
+	}
+	c.Close()
+
+	c = p.Get()
+	c.Do("ERR", io.EOF)
+	c.Close()
+
+	d.check(".", p, 2, 0, 0)
+}
+
+func TestPoolClose(t *testing.T) {
+	d := poolDialer{t: t}
+	p := &redis.Pool{
+		MaxIdle: 2,
+		Dial:    d.dial,
+	}
+	defer p.Close()
+
+	c1 := p.Get()
+	c1.Do("PING")
+	c2 := p.Get()
+	c2.Do("PING")
+	c3 := p.Get()
+	c3.Do("PING")
+
+	c1.Close()
+	if _, err := c1.Do("PING"); err == nil {
+		t.Errorf("expected error after connection closed")
+	}
+
+	c2.Close()
+	c2.Close()
+
+	p.Close()
+
+	d.check("after pool close", p, 3, 1, 1)
+
+	if _, err := c1.Do("PING"); err == nil {
+		t.Errorf("expected error after connection and pool closed")
+	}
+
+	c3.Close()
+
+	d.check("after conn close", p, 3, 0, 0)
+
+	c1 = p.Get()
+	if _, err := c1.Do("PING"); err == nil {
+		t.Errorf("expected error after pool closed")
+	}
+}
+
+func TestPoolClosedConn(t *testing.T) {
+	d := poolDialer{t: t}
+	p := &redis.Pool{
+		MaxIdle:     2,
+		IdleTimeout: 300 * time.Second,
+		Dial:        d.dial,
+	}
+	defer p.Close()
+	c := p.Get()
+	if c.Err() != nil {
+		t.Fatal("get failed")
+	}
+	c.Close()
+	if err := c.Err(); err == nil {
+		t.Fatal("Err on closed connection did not return error")
+	}
+	if _, err := c.Do("PING"); err == nil {
+		t.Fatal("Do on closed connection did not return error")
+	}
+	if err := c.Send("PING"); err == nil {
+		t.Fatal("Send on closed connection did not return error")
+	}
+	if err := c.Flush(); err == nil {
+		t.Fatal("Flush on closed connection did not return error")
+	}
+	if _, err := c.Receive(); err == nil {
+		t.Fatal("Receive on closed connection did not return error")
+	}
+}
+
+func TestPoolIdleTimeout(t *testing.T) {
+	d := poolDialer{t: t}
+	p := &redis.Pool{
+		MaxIdle:     2,
+		IdleTimeout: 300 * time.Second,
+		Dial:        d.dial,
+	}
+	defer p.Close()
+
+	now := time.Now()
+	redis.SetNowFunc(func() time.Time { return now })
+	defer redis.SetNowFunc(time.Now)
+
+	c := p.Get()
+	c.Do("PING")
+	c.Close()
+
+	d.check("1", p, 1, 1, 0)
+
+	now = now.Add(p.IdleTimeout + 1)
+
+	c = p.Get()
+	c.Do("PING")
+	c.Close()
+
+	d.check("2", p, 2, 1, 0)
+}
+
+func TestPoolMaxLifetime(t *testing.T) {
+	d := poolDialer{t: t}
+	p := &redis.Pool{
+		MaxIdle:         2,
+		MaxConnLifetime: 300 * time.Second,
+		Dial:            d.dial,
+	}
+	defer p.Close()
+
+	now := time.Now()
+	redis.SetNowFunc(func() time.Time { return now })
+	defer redis.SetNowFunc(time.Now)
+
+	c := p.Get()
+	c.Do("PING")
+	c.Close()
+
+	d.check("1", p, 1, 1, 0)
+
+	now = now.Add(p.MaxConnLifetime + 1)
+
+	c = p.Get()
+	c.Do("PING")
+	c.Close()
+
+	d.check("2", p, 2, 1, 0)
+}
+
+func TestPoolConcurrenSendReceive(t *testing.T) {
+	p := &redis.Pool{
+		Dial: redis.DialDefaultServer,
+	}
+	defer p.Close()
+
+	c := p.Get()
+	done := make(chan error, 1)
+	go func() {
+		_, err := c.Receive()
+		done <- err
+	}()
+	c.Send("PING")
+	c.Flush()
+	err := <-done
+	if err != nil {
+		t.Fatalf("Receive() returned error %v", err)
+	}
+	_, err = c.Do("")
+	if err != nil {
+		t.Fatalf("Do() returned error %v", err)
+	}
+	c.Close()
+}
+
+func TestPoolBorrowCheck(t *testing.T) {
+	d := poolDialer{t: t}
+	p := &redis.Pool{
+		MaxIdle:      2,
+		Dial:         d.dial,
+		TestOnBorrow: func(redis.Conn, time.Time) error { return redis.Error("BLAH") },
+	}
+	defer p.Close()
+
+	for i := 0; i < 10; i++ {
+		c := p.Get()
+		c.Do("PING")
+		c.Close()
+	}
+	d.check("1", p, 10, 1, 0)
+}
+
+func TestPoolMaxActive(t *testing.T) {
+	d := poolDialer{t: t}
+	p := &redis.Pool{
+		MaxIdle:   2,
+		MaxActive: 2,
+		Dial:      d.dial,
+	}
+	defer p.Close()
+
+	c1 := p.Get()
+	c1.Do("PING")
+	c2 := p.Get()
+	c2.Do("PING")
+
+	d.check("1", p, 2, 2, 2)
+
+	c3 := p.Get()
+	if _, err := c3.Do("PING"); err != redis.ErrPoolExhausted {
+		t.Errorf("expected pool exhausted")
+	}
+
+	c3.Close()
+	d.check("2", p, 2, 2, 2)
+	c2.Close()
+	d.check("3", p, 2, 2, 1)
+
+	c3 = p.Get()
+	if _, err := c3.Do("PING"); err != nil {
+		t.Errorf("expected good channel, err=%v", err)
+	}
+	c3.Close()
+
+	d.check("4", p, 2, 2, 1)
+}
+
+func TestPoolMonitorCleanup(t *testing.T) {
+	d := poolDialer{t: t}
+	p := &redis.Pool{
+		MaxIdle:   2,
+		MaxActive: 2,
+		Dial:      d.dial,
+	}
+	defer p.Close()
+
+	c := p.Get()
+	c.Send("MONITOR")
+	c.Close()
+
+	d.check("", p, 1, 0, 0)
+}
+
+func TestPoolPubSubCleanup(t *testing.T) {
+	d := poolDialer{t: t}
+	p := &redis.Pool{
+		MaxIdle:   2,
+		MaxActive: 2,
+		Dial:      d.dial,
+	}
+	defer p.Close()
+
+	c := p.Get()
+	c.Send("SUBSCRIBE", "x")
+	c.Close()
+
+	want := []string{"SUBSCRIBE", "UNSUBSCRIBE", "PUNSUBSCRIBE", "ECHO"}
+	if !reflect.DeepEqual(d.commands, want) {
+		t.Errorf("got commands %v, want %v", d.commands, want)
+	}
+	d.commands = nil
+
+	c = p.Get()
+	c.Send("PSUBSCRIBE", "x*")
+	c.Close()
+
+	want = []string{"PSUBSCRIBE", "UNSUBSCRIBE", "PUNSUBSCRIBE", "ECHO"}
+	if !reflect.DeepEqual(d.commands, want) {
+		t.Errorf("got commands %v, want %v", d.commands, want)
+	}
+	d.commands = nil
+}
+
+func TestPoolTransactionCleanup(t *testing.T) {
+	d := poolDialer{t: t}
+	p := &redis.Pool{
+		MaxIdle:   2,
+		MaxActive: 2,
+		Dial:      d.dial,
+	}
+	defer p.Close()
+
+	c := p.Get()
+	c.Do("WATCH", "key")
+	c.Do("PING")
+	c.Close()
+
+	want := []string{"WATCH", "PING", "UNWATCH"}
+	if !reflect.DeepEqual(d.commands, want) {
+		t.Errorf("got commands %v, want %v", d.commands, want)
+	}
+	d.commands = nil
+
+	c = p.Get()
+	c.Do("WATCH", "key")
+	c.Do("UNWATCH")
+	c.Do("PING")
+	c.Close()
+
+	want = []string{"WATCH", "UNWATCH", "PING"}
+	if !reflect.DeepEqual(d.commands, want) {
+		t.Errorf("got commands %v, want %v", d.commands, want)
+	}
+	d.commands = nil
+
+	c = p.Get()
+	c.Do("WATCH", "key")
+	c.Do("MULTI")
+	c.Do("PING")
+	c.Close()
+
+	want = []string{"WATCH", "MULTI", "PING", "DISCARD"}
+	if !reflect.DeepEqual(d.commands, want) {
+		t.Errorf("got commands %v, want %v", d.commands, want)
+	}
+	d.commands = nil
+
+	c = p.Get()
+	c.Do("WATCH", "key")
+	c.Do("MULTI")
+	c.Do("DISCARD")
+	c.Do("PING")
+	c.Close()
+
+	want = []string{"WATCH", "MULTI", "DISCARD", "PING"}
+	if !reflect.DeepEqual(d.commands, want) {
+		t.Errorf("got commands %v, want %v", d.commands, want)
+	}
+	d.commands = nil
+
+	c = p.Get()
+	c.Do("WATCH", "key")
+	c.Do("MULTI")
+	c.Do("EXEC")
+	c.Do("PING")
+	c.Close()
+
+	want = []string{"WATCH", "MULTI", "EXEC", "PING"}
+	if !reflect.DeepEqual(d.commands, want) {
+		t.Errorf("got commands %v, want %v", d.commands, want)
+	}
+	d.commands = nil
+}
+
+func startGoroutines(p *redis.Pool, cmd string, args ...interface{}) chan error {
+	errs := make(chan error, 10)
+	for i := 0; i < cap(errs); i++ {
+		go func() {
+			c := p.Get()
+			_, err := c.Do(cmd, args...)
+			c.Close()
+			errs <- err
+		}()
+	}
+
+	return errs
+}
+
+func TestWaitPool(t *testing.T) {
+	d := poolDialer{t: t}
+	p := &redis.Pool{
+		MaxIdle:   1,
+		MaxActive: 1,
+		Dial:      d.dial,
+		Wait:      true,
+	}
+	defer p.Close()
+
+	c := p.Get()
+	errs := startGoroutines(p, "PING")
+	d.check("before close", p, 1, 1, 1)
+	c.Close()
+	timeout := time.After(2 * time.Second)
+	for i := 0; i < cap(errs); i++ {
+		select {
+		case err := <-errs:
+			if err != nil {
+				t.Fatal(err)
+			}
+		case <-timeout:
+			t.Fatalf("timeout waiting for blocked goroutine %d", i)
+		}
+	}
+	d.check("done", p, 1, 1, 0)
+}
+
+func TestWaitPoolClose(t *testing.T) {
+	d := poolDialer{t: t}
+	p := &redis.Pool{
+		MaxIdle:   1,
+		MaxActive: 1,
+		Dial:      d.dial,
+		Wait:      true,
+	}
+	defer p.Close()
+
+	c := p.Get()
+	if _, err := c.Do("PING"); err != nil {
+		t.Fatal(err)
+	}
+	errs := startGoroutines(p, "PING")
+	d.check("before close", p, 1, 1, 1)
+	p.Close()
+	timeout := time.After(2 * time.Second)
+	for i := 0; i < cap(errs); i++ {
+		select {
+		case err := <-errs:
+			switch err {
+			case nil:
+				t.Fatal("blocked goroutine did not get error")
+			case redis.ErrPoolExhausted:
+				t.Fatal("blocked goroutine got pool exhausted error")
+			}
+		case <-timeout:
+			t.Fatal("timeout waiting for blocked goroutine")
+		}
+	}
+	c.Close()
+	d.check("done", p, 1, 0, 0)
+}
+
+func TestWaitPoolCommandError(t *testing.T) {
+	testErr := errors.New("test")
+	d := poolDialer{t: t}
+	p := &redis.Pool{
+		MaxIdle:   1,
+		MaxActive: 1,
+		Dial:      d.dial,
+		Wait:      true,
+	}
+	defer p.Close()
+
+	c := p.Get()
+	errs := startGoroutines(p, "ERR", testErr)
+	d.check("before close", p, 1, 1, 1)
+	c.Close()
+	timeout := time.After(2 * time.Second)
+	for i := 0; i < cap(errs); i++ {
+		select {
+		case err := <-errs:
+			if err != nil {
+				t.Fatal(err)
+			}
+		case <-timeout:
+			t.Fatalf("timeout waiting for blocked goroutine %d", i)
+		}
+	}
+	d.check("done", p, cap(errs), 0, 0)
+}
+
+func TestWaitPoolDialError(t *testing.T) {
+	testErr := errors.New("test")
+	d := poolDialer{t: t}
+	p := &redis.Pool{
+		MaxIdle:   1,
+		MaxActive: 1,
+		Dial:      d.dial,
+		Wait:      true,
+	}
+	defer p.Close()
+
+	c := p.Get()
+	errs := startGoroutines(p, "ERR", testErr)
+	d.check("before close", p, 1, 1, 1)
+
+	d.dialErr = errors.New("dial")
+	c.Close()
+
+	nilCount := 0
+	errCount := 0
+	timeout := time.After(2 * time.Second)
+	for i := 0; i < cap(errs); i++ {
+		select {
+		case err := <-errs:
+			switch err {
+			case nil:
+				nilCount++
+			case d.dialErr:
+				errCount++
+			default:
+				t.Fatalf("expected dial error or nil, got %v", err)
+			}
+		case <-timeout:
+			t.Fatalf("timeout waiting for blocked goroutine %d", i)
+		}
+	}
+	if nilCount != 1 {
+		t.Errorf("expected one nil error, got %d", nilCount)
+	}
+	if errCount != cap(errs)-1 {
+		t.Errorf("expected %d dial errors, got %d", cap(errs)-1, errCount)
+	}
+	d.check("done", p, cap(errs), 0, 0)
+}
+
+// Borrowing requires us to iterate over the idle connections, unlock the pool,
+// and perform a blocking operation to check the connection still works. If
+// TestOnBorrow fails, we must reacquire the lock and continue iteration. This
+// test ensures that iteration will work correctly if multiple threads are
+// iterating simultaneously.
+func TestLocking_TestOnBorrowFails_PoolDoesntCrash(t *testing.T) {
+	const count = 100
+
+	// First we'll Create a pool where the pilfering of idle connections fails.
+	d := poolDialer{t: t}
+	p := &redis.Pool{
+		MaxIdle:   count,
+		MaxActive: count,
+		Dial:      d.dial,
+		TestOnBorrow: func(c redis.Conn, t time.Time) error {
+			return errors.New("No way back into the real world.")
+		},
+	}
+	defer p.Close()
+
+	// Fill the pool with idle connections.
+	conns := make([]redis.Conn, count)
+	for i := range conns {
+		conns[i] = p.Get()
+	}
+	for i := range conns {
+		conns[i].Close()
+	}
+
+	// Spawn a bunch of goroutines to thrash the pool.
+	var wg sync.WaitGroup
+	wg.Add(count)
+	for i := 0; i < count; i++ {
+		go func() {
+			c := p.Get()
+			if c.Err() != nil {
+				t.Errorf("pool get failed: %v", c.Err())
+			}
+			c.Close()
+			wg.Done()
+		}()
+	}
+	wg.Wait()
+	if d.dialed != count*2 {
+		t.Errorf("Expected %d dials, got %d", count*2, d.dialed)
+	}
+}
+
+func BenchmarkPoolGet(b *testing.B) {
+	b.StopTimer()
+	p := redis.Pool{Dial: redis.DialDefaultServer, MaxIdle: 2}
+	c := p.Get()
+	if err := c.Err(); err != nil {
+		b.Fatal(err)
+	}
+	c.Close()
+	defer p.Close()
+	b.StartTimer()
+	for i := 0; i < b.N; i++ {
+		c = p.Get()
+		c.Close()
+	}
+}
+
+func BenchmarkPoolGetErr(b *testing.B) {
+	b.StopTimer()
+	p := redis.Pool{Dial: redis.DialDefaultServer, MaxIdle: 2}
+	c := p.Get()
+	if err := c.Err(); err != nil {
+		b.Fatal(err)
+	}
+	c.Close()
+	defer p.Close()
+	b.StartTimer()
+	for i := 0; i < b.N; i++ {
+		c = p.Get()
+		if err := c.Err(); err != nil {
+			b.Fatal(err)
+		}
+		c.Close()
+	}
+}
+
+func BenchmarkPoolGetPing(b *testing.B) {
+	b.StopTimer()
+	p := redis.Pool{Dial: redis.DialDefaultServer, MaxIdle: 2}
+	c := p.Get()
+	if err := c.Err(); err != nil {
+		b.Fatal(err)
+	}
+	c.Close()
+	defer p.Close()
+	b.StartTimer()
+	for i := 0; i < b.N; i++ {
+		c = p.Get()
+		if _, err := c.Do("PING"); err != nil {
+			b.Fatal(err)
+		}
+		c.Close()
+	}
+}
Index: mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/pubsub.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/pubsub.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/pubsub.go	(revision 4485)
@@ -0,0 +1,157 @@
+// Copyright 2012 Gary Burd
+//
+// Licensed under the Apache License, Version 2.0 (the "License"): you may
+// not use this file except in compliance with the License. You may obtain
+// a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+// License for the specific language governing permissions and limitations
+// under the License.
+
+package redis
+
+import (
+	"errors"
+	"time"
+)
+
+// Subscription represents a subscribe or unsubscribe notification.
+type Subscription struct {
+	// Kind is "subscribe", "unsubscribe", "psubscribe" or "punsubscribe"
+	Kind string
+
+	// The channel that was changed.
+	Channel string
+
+	// The current number of subscriptions for connection.
+	Count int
+}
+
+// Message represents a message notification.
+type Message struct {
+	// The originating channel.
+	Channel string
+
+	// The message data.
+	Data []byte
+}
+
+// PMessage represents a pmessage notification.
+type PMessage struct {
+	// The matched pattern.
+	Pattern string
+
+	// The originating channel.
+	Channel string
+
+	// The message data.
+	Data []byte
+}
+
+// Pong represents a pubsub pong notification.
+type Pong struct {
+	Data string
+}
+
+// PubSubConn wraps a Conn with convenience methods for subscribers.
+type PubSubConn struct {
+	Conn Conn
+}
+
+// Close closes the connection.
+func (c PubSubConn) Close() error {
+	return c.Conn.Close()
+}
+
+// Subscribe subscribes the connection to the specified channels.
+func (c PubSubConn) Subscribe(channel ...interface{}) error {
+	c.Conn.Send("SUBSCRIBE", channel...)
+	return c.Conn.Flush()
+}
+
+// PSubscribe subscribes the connection to the given patterns.
+func (c PubSubConn) PSubscribe(channel ...interface{}) error {
+	c.Conn.Send("PSUBSCRIBE", channel...)
+	return c.Conn.Flush()
+}
+
+// Unsubscribe unsubscribes the connection from the given channels, or from all
+// of them if none is given.
+func (c PubSubConn) Unsubscribe(channel ...interface{}) error {
+	c.Conn.Send("UNSUBSCRIBE", channel...)
+	return c.Conn.Flush()
+}
+
+// PUnsubscribe unsubscribes the connection from the given patterns, or from all
+// of them if none is given.
+func (c PubSubConn) PUnsubscribe(channel ...interface{}) error {
+	c.Conn.Send("PUNSUBSCRIBE", channel...)
+	return c.Conn.Flush()
+}
+
+// Ping sends a PING to the server with the specified data.
+//
+// The connection must be subscribed to at least one channel or pattern when
+// calling this method.
+func (c PubSubConn) Ping(data string) error {
+	c.Conn.Send("PING", data)
+	return c.Conn.Flush()
+}
+
+// Receive returns a pushed message as a Subscription, Message, PMessage, Pong
+// or error. The return value is intended to be used directly in a type switch
+// as illustrated in the PubSubConn example.
+func (c PubSubConn) Receive() interface{} {
+	return c.receiveInternal(c.Conn.Receive())
+}
+
+// ReceiveWithTimeout is like Receive, but it allows the application to
+// override the connection's default timeout.
+func (c PubSubConn) ReceiveWithTimeout(timeout time.Duration) interface{} {
+	return c.receiveInternal(ReceiveWithTimeout(c.Conn, timeout))
+}
+
+func (c PubSubConn) receiveInternal(replyArg interface{}, errArg error) interface{} {
+	reply, err := Values(replyArg, errArg)
+	if err != nil {
+		return err
+	}
+
+	var kind string
+	reply, err = Scan(reply, &kind)
+	if err != nil {
+		return err
+	}
+
+	switch kind {
+	case "message":
+		var m Message
+		if _, err := Scan(reply, &m.Channel, &m.Data); err != nil {
+			return err
+		}
+		return m
+	case "pmessage":
+		var pm PMessage
+		if _, err := Scan(reply, &pm.Pattern, &pm.Channel, &pm.Data); err != nil {
+			return err
+		}
+		return pm
+	case "subscribe", "psubscribe", "unsubscribe", "punsubscribe":
+		s := Subscription{Kind: kind}
+		if _, err := Scan(reply, &s.Channel, &s.Count); err != nil {
+			return err
+		}
+		return s
+	case "pong":
+		var p Pong
+		if _, err := Scan(reply, &p.Data); err != nil {
+			return err
+		}
+		return p
+	}
+	return errors.New("redigo: unknown pubsub notification")
+}
Index: mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/pubsub_example_test.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/pubsub_example_test.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/pubsub_example_test.go	(revision 4485)
@@ -0,0 +1,165 @@
+// Copyright 2012 Gary Burd
+//
+// Licensed under the Apache License, Version 2.0 (the "License"): you may
+// not use this file except in compliance with the License. You may obtain
+// a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+// License for the specific language governing permissions and limitations
+// under the License.
+
+// +build go1.7
+
+package redis_test
+
+import (
+	"context"
+	"fmt"
+	"time"
+
+	"github.com/garyburd/redigo/redis"
+)
+
+// listenPubSubChannels listens for messages on Redis pubsub channels. The
+// onStart function is called after the channels are subscribed. The onMessage
+// function is called for each message.
+func listenPubSubChannels(ctx context.Context, redisServerAddr string,
+	onStart func() error,
+	onMessage func(channel string, data []byte) error,
+	channels ...string) error {
+	// A ping is set to the server with this period to test for the health of
+	// the connection and server.
+	const healthCheckPeriod = time.Minute
+
+	c, err := redis.Dial("tcp", redisServerAddr,
+		// Read timeout on server should be greater than ping period.
+		redis.DialReadTimeout(healthCheckPeriod+10*time.Second),
+		redis.DialWriteTimeout(10*time.Second))
+	if err != nil {
+		return err
+	}
+	defer c.Close()
+
+	psc := redis.PubSubConn{Conn: c}
+
+	if err := psc.Subscribe(redis.Args{}.AddFlat(channels)...); err != nil {
+		return err
+	}
+
+	done := make(chan error, 1)
+
+	// Start a goroutine to receive notifications from the server.
+	go func() {
+		for {
+			switch n := psc.Receive().(type) {
+			case error:
+				done <- n
+				return
+			case redis.Message:
+				if err := onMessage(n.Channel, n.Data); err != nil {
+					done <- err
+					return
+				}
+			case redis.Subscription:
+				switch n.Count {
+				case len(channels):
+					// Notify application when all channels are subscribed.
+					if err := onStart(); err != nil {
+						done <- err
+						return
+					}
+				case 0:
+					// Return from the goroutine when all channels are unsubscribed.
+					done <- nil
+					return
+				}
+			}
+		}
+	}()
+
+	ticker := time.NewTicker(healthCheckPeriod)
+	defer ticker.Stop()
+loop:
+	for err == nil {
+		select {
+		case <-ticker.C:
+			// Send ping to test health of connection and server. If
+			// corresponding pong is not received, then receive on the
+			// connection will timeout and the receive goroutine will exit.
+			if err = psc.Ping(""); err != nil {
+				break loop
+			}
+		case <-ctx.Done():
+			break loop
+		case err := <-done:
+			// Return error from the receive goroutine.
+			return err
+		}
+	}
+
+	// Signal the receiving goroutine to exit by unsubscribing from all channels.
+	psc.Unsubscribe()
+
+	// Wait for goroutine to complete.
+	return <-done
+}
+
+func publish() {
+	c, err := dial()
+	if err != nil {
+		fmt.Println(err)
+		return
+	}
+	defer c.Close()
+
+	c.Do("PUBLISH", "c1", "hello")
+	c.Do("PUBLISH", "c2", "world")
+	c.Do("PUBLISH", "c1", "goodbye")
+}
+
+// This example shows how receive pubsub notifications with cancelation and
+// health checks.
+func ExamplePubSubConn() {
+	redisServerAddr, err := serverAddr()
+	if err != nil {
+		fmt.Println(err)
+		return
+	}
+
+	ctx, cancel := context.WithCancel(context.Background())
+
+	err = listenPubSubChannels(ctx,
+		redisServerAddr,
+		func() error {
+			// The start callback is a good place to backfill missed
+			// notifications. For the purpose of this example, a goroutine is
+			// started to send notifications.
+			go publish()
+			return nil
+		},
+		func(channel string, message []byte) error {
+			fmt.Printf("channel: %s, message: %s\n", channel, message)
+
+			// For the purpose of this example, cancel the listener's context
+			// after receiving last message sent by publish().
+			if string(message) == "goodbye" {
+				cancel()
+			}
+			return nil
+		},
+		"c1", "c2")
+
+	if err != nil {
+		fmt.Println(err)
+		return
+	}
+
+	// Output:
+	// channel: c1, message: hello
+	// channel: c2, message: world
+	// channel: c1, message: goodbye
+}
Index: mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/pubsub_test.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/pubsub_test.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/pubsub_test.go	(revision 4485)
@@ -0,0 +1,74 @@
+// Copyright 2012 Gary Burd
+//
+// Licensed under the Apache License, Version 2.0 (the "License"): you may
+// not use this file except in compliance with the License. You may obtain
+// a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+// License for the specific language governing permissions and limitations
+// under the License.
+
+package redis_test
+
+import (
+	"reflect"
+	"testing"
+	"time"
+
+	"github.com/garyburd/redigo/redis"
+)
+
+func expectPushed(t *testing.T, c redis.PubSubConn, message string, expected interface{}) {
+	actual := c.Receive()
+	if !reflect.DeepEqual(actual, expected) {
+		t.Errorf("%s = %v, want %v", message, actual, expected)
+	}
+}
+
+func TestPushed(t *testing.T) {
+	pc, err := redis.DialDefaultServer()
+	if err != nil {
+		t.Fatalf("error connection to database, %v", err)
+	}
+	defer pc.Close()
+
+	sc, err := redis.DialDefaultServer()
+	if err != nil {
+		t.Fatalf("error connection to database, %v", err)
+	}
+	defer sc.Close()
+
+	c := redis.PubSubConn{Conn: sc}
+
+	c.Subscribe("c1")
+	expectPushed(t, c, "Subscribe(c1)", redis.Subscription{Kind: "subscribe", Channel: "c1", Count: 1})
+	c.Subscribe("c2")
+	expectPushed(t, c, "Subscribe(c2)", redis.Subscription{Kind: "subscribe", Channel: "c2", Count: 2})
+	c.PSubscribe("p1")
+	expectPushed(t, c, "PSubscribe(p1)", redis.Subscription{Kind: "psubscribe", Channel: "p1", Count: 3})
+	c.PSubscribe("p2")
+	expectPushed(t, c, "PSubscribe(p2)", redis.Subscription{Kind: "psubscribe", Channel: "p2", Count: 4})
+	c.PUnsubscribe()
+	expectPushed(t, c, "Punsubscribe(p1)", redis.Subscription{Kind: "punsubscribe", Channel: "p1", Count: 3})
+	expectPushed(t, c, "Punsubscribe()", redis.Subscription{Kind: "punsubscribe", Channel: "p2", Count: 2})
+
+	pc.Do("PUBLISH", "c1", "hello")
+	expectPushed(t, c, "PUBLISH c1 hello", redis.Message{Channel: "c1", Data: []byte("hello")})
+
+	c.Ping("hello")
+	expectPushed(t, c, `Ping("hello")`, redis.Pong{Data: "hello"})
+
+	c.Conn.Send("PING")
+	c.Conn.Flush()
+	expectPushed(t, c, `Send("PING")`, redis.Pong{})
+
+	c.Ping("timeout")
+	got := c.ReceiveWithTimeout(time.Minute)
+	if want := (redis.Pong{Data: "timeout"}); want != got {
+		t.Errorf("recv /w timeout got %v, want %v", got, want)
+	}
+}
Index: mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/redis.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/redis.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/redis.go	(revision 4485)
@@ -0,0 +1,117 @@
+// Copyright 2012 Gary Burd
+//
+// Licensed under the Apache License, Version 2.0 (the "License"): you may
+// not use this file except in compliance with the License. You may obtain
+// a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+// License for the specific language governing permissions and limitations
+// under the License.
+
+package redis
+
+import (
+	"errors"
+	"time"
+)
+
+// Error represents an error returned in a command reply.
+type Error string
+
+func (err Error) Error() string { return string(err) }
+
+// Conn represents a connection to a Redis server.
+type Conn interface {
+	// Close closes the connection.
+	Close() error
+
+	// Err returns a non-nil value when the connection is not usable.
+	Err() error
+
+	// Do sends a command to the server and returns the received reply.
+	Do(commandName string, args ...interface{}) (reply interface{}, err error)
+
+	// Send writes the command to the client's output buffer.
+	Send(commandName string, args ...interface{}) error
+
+	// Flush flushes the output buffer to the Redis server.
+	Flush() error
+
+	// Receive receives a single reply from the Redis server
+	Receive() (reply interface{}, err error)
+}
+
+// Argument is the interface implemented by an object which wants to control how
+// the object is converted to Redis bulk strings.
+type Argument interface {
+	// RedisArg returns a value to be encoded as a bulk string per the
+	// conversions listed in the section 'Executing Commands'.
+	// Implementations should typically return a []byte or string.
+	RedisArg() interface{}
+}
+
+// Scanner is implemented by an object which wants to control its value is
+// interpreted when read from Redis.
+type Scanner interface {
+	// RedisScan assigns a value from a Redis value. The argument src is one of
+	// the reply types listed in the section `Executing Commands`.
+	//
+	// An error should be returned if the value cannot be stored without
+	// loss of information.
+	RedisScan(src interface{}) error
+}
+
+// ConnWithTimeout is an optional interface that allows the caller to override
+// a connection's default read timeout. This interface is useful for executing
+// the BLPOP, BRPOP, BRPOPLPUSH, XREAD and other commands that block at the
+// server.
+//
+// A connection's default read timeout is set with the DialReadTimeout dial
+// option. Applications should rely on the default timeout for commands that do
+// not block at the server.
+//
+// All of the Conn implementations in this package satisfy the ConnWithTimeout
+// interface.
+//
+// Use the DoWithTimeout and ReceiveWithTimeout helper functions to simplify
+// use of this interface.
+type ConnWithTimeout interface {
+	Conn
+
+	// Do sends a command to the server and returns the received reply.
+	// The timeout overrides the read timeout set when dialing the
+	// connection.
+	DoWithTimeout(timeout time.Duration, commandName string, args ...interface{}) (reply interface{}, err error)
+
+	// Receive receives a single reply from the Redis server. The timeout
+	// overrides the read timeout set when dialing the connection.
+	ReceiveWithTimeout(timeout time.Duration) (reply interface{}, err error)
+}
+
+var errTimeoutNotSupported = errors.New("redis: connection does not support ConnWithTimeout")
+
+// DoWithTimeout executes a Redis command with the specified read timeout. If
+// the connection does not satisfy the ConnWithTimeout interface, then an error
+// is returned.
+func DoWithTimeout(c Conn, timeout time.Duration, cmd string, args ...interface{}) (interface{}, error) {
+	cwt, ok := c.(ConnWithTimeout)
+	if !ok {
+		return nil, errTimeoutNotSupported
+	}
+	return cwt.DoWithTimeout(timeout, cmd, args...)
+}
+
+// ReceiveWithTimeout receives a reply with the specified read timeout. If the
+// connection does not satisfy the ConnWithTimeout interface, then an error is
+// returned.
+func ReceiveWithTimeout(c Conn, timeout time.Duration) (interface{}, error) {
+	cwt, ok := c.(ConnWithTimeout)
+	if !ok {
+		return nil, errTimeoutNotSupported
+	}
+	return cwt.ReceiveWithTimeout(timeout)
+}
Index: mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/redis_test.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/redis_test.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/redis_test.go	(revision 4485)
@@ -0,0 +1,71 @@
+// Copyright 2017 Gary Burd
+//
+// Licensed under the Apache License, Version 2.0 (the "License"): you may
+// not use this file except in compliance with the License. You may obtain
+// a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+// License for the specific language governing permissions and limitations
+// under the License.
+
+package redis_test
+
+import (
+	"testing"
+	"time"
+
+	"github.com/garyburd/redigo/redis"
+)
+
+type timeoutTestConn int
+
+func (tc timeoutTestConn) Do(string, ...interface{}) (interface{}, error) {
+	return time.Duration(-1), nil
+}
+func (tc timeoutTestConn) DoWithTimeout(timeout time.Duration, cmd string, args ...interface{}) (interface{}, error) {
+	return timeout, nil
+}
+
+func (tc timeoutTestConn) Receive() (interface{}, error) {
+	return time.Duration(-1), nil
+}
+func (tc timeoutTestConn) ReceiveWithTimeout(timeout time.Duration) (interface{}, error) {
+	return timeout, nil
+}
+
+func (tc timeoutTestConn) Send(string, ...interface{}) error { return nil }
+func (tc timeoutTestConn) Err() error                        { return nil }
+func (tc timeoutTestConn) Close() error                      { return nil }
+func (tc timeoutTestConn) Flush() error                      { return nil }
+
+func testTimeout(t *testing.T, c redis.Conn) {
+	r, err := c.Do("PING")
+	if r != time.Duration(-1) || err != nil {
+		t.Errorf("Do() = %v, %v, want %v, %v", r, err, time.Duration(-1), nil)
+	}
+	r, err = redis.DoWithTimeout(c, time.Minute, "PING")
+	if r != time.Minute || err != nil {
+		t.Errorf("DoWithTimeout() = %v, %v, want %v, %v", r, err, time.Minute, nil)
+	}
+	r, err = c.Receive()
+	if r != time.Duration(-1) || err != nil {
+		t.Errorf("Receive() = %v, %v, want %v, %v", r, err, time.Duration(-1), nil)
+	}
+	r, err = redis.ReceiveWithTimeout(c, time.Minute)
+	if r != time.Minute || err != nil {
+		t.Errorf("ReceiveWithTimeout() = %v, %v, want %v, %v", r, err, time.Minute, nil)
+	}
+}
+
+func TestConnTimeout(t *testing.T) {
+	testTimeout(t, timeoutTestConn(0))
+}
+
+func TestPoolConnTimeout(t *testing.T) {
+	p := &redis.Pool{Dial: func() (redis.Conn, error) { return timeoutTestConn(0), nil }}
+	testTimeout(t, p.Get())
+}
Index: mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/reply.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/reply.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/reply.go	(revision 4485)
@@ -0,0 +1,479 @@
+// Copyright 2012 Gary Burd
+//
+// Licensed under the Apache License, Version 2.0 (the "License"): you may
+// not use this file except in compliance with the License. You may obtain
+// a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+// License for the specific language governing permissions and limitations
+// under the License.
+
+package redis
+
+import (
+	"errors"
+	"fmt"
+	"strconv"
+)
+
+// ErrNil indicates that a reply value is nil.
+var ErrNil = errors.New("redigo: nil returned")
+
+// Int is a helper that converts a command reply to an integer. If err is not
+// equal to nil, then Int returns 0, err. Otherwise, Int converts the
+// reply to an int as follows:
+//
+//  Reply type    Result
+//  integer       int(reply), nil
+//  bulk string   parsed reply, nil
+//  nil           0, ErrNil
+//  other         0, error
+func Int(reply interface{}, err error) (int, error) {
+	if err != nil {
+		return 0, err
+	}
+	switch reply := reply.(type) {
+	case int64:
+		x := int(reply)
+		if int64(x) != reply {
+			return 0, strconv.ErrRange
+		}
+		return x, nil
+	case []byte:
+		n, err := strconv.ParseInt(string(reply), 10, 0)
+		return int(n), err
+	case nil:
+		return 0, ErrNil
+	case Error:
+		return 0, reply
+	}
+	return 0, fmt.Errorf("redigo: unexpected type for Int, got type %T", reply)
+}
+
+// Int64 is a helper that converts a command reply to 64 bit integer. If err is
+// not equal to nil, then Int returns 0, err. Otherwise, Int64 converts the
+// reply to an int64 as follows:
+//
+//  Reply type    Result
+//  integer       reply, nil
+//  bulk string   parsed reply, nil
+//  nil           0, ErrNil
+//  other         0, error
+func Int64(reply interface{}, err error) (int64, error) {
+	if err != nil {
+		return 0, err
+	}
+	switch reply := reply.(type) {
+	case int64:
+		return reply, nil
+	case []byte:
+		n, err := strconv.ParseInt(string(reply), 10, 64)
+		return n, err
+	case nil:
+		return 0, ErrNil
+	case Error:
+		return 0, reply
+	}
+	return 0, fmt.Errorf("redigo: unexpected type for Int64, got type %T", reply)
+}
+
+var errNegativeInt = errors.New("redigo: unexpected value for Uint64")
+
+// Uint64 is a helper that converts a command reply to 64 bit integer. If err is
+// not equal to nil, then Int returns 0, err. Otherwise, Int64 converts the
+// reply to an int64 as follows:
+//
+//  Reply type    Result
+//  integer       reply, nil
+//  bulk string   parsed reply, nil
+//  nil           0, ErrNil
+//  other         0, error
+func Uint64(reply interface{}, err error) (uint64, error) {
+	if err != nil {
+		return 0, err
+	}
+	switch reply := reply.(type) {
+	case int64:
+		if reply < 0 {
+			return 0, errNegativeInt
+		}
+		return uint64(reply), nil
+	case []byte:
+		n, err := strconv.ParseUint(string(reply), 10, 64)
+		return n, err
+	case nil:
+		return 0, ErrNil
+	case Error:
+		return 0, reply
+	}
+	return 0, fmt.Errorf("redigo: unexpected type for Uint64, got type %T", reply)
+}
+
+// Float64 is a helper that converts a command reply to 64 bit float. If err is
+// not equal to nil, then Float64 returns 0, err. Otherwise, Float64 converts
+// the reply to an int as follows:
+//
+//  Reply type    Result
+//  bulk string   parsed reply, nil
+//  nil           0, ErrNil
+//  other         0, error
+func Float64(reply interface{}, err error) (float64, error) {
+	if err != nil {
+		return 0, err
+	}
+	switch reply := reply.(type) {
+	case []byte:
+		n, err := strconv.ParseFloat(string(reply), 64)
+		return n, err
+	case nil:
+		return 0, ErrNil
+	case Error:
+		return 0, reply
+	}
+	return 0, fmt.Errorf("redigo: unexpected type for Float64, got type %T", reply)
+}
+
+// String is a helper that converts a command reply to a string. If err is not
+// equal to nil, then String returns "", err. Otherwise String converts the
+// reply to a string as follows:
+//
+//  Reply type      Result
+//  bulk string     string(reply), nil
+//  simple string   reply, nil
+//  nil             "",  ErrNil
+//  other           "",  error
+func String(reply interface{}, err error) (string, error) {
+	if err != nil {
+		return "", err
+	}
+	switch reply := reply.(type) {
+	case []byte:
+		return string(reply), nil
+	case string:
+		return reply, nil
+	case nil:
+		return "", ErrNil
+	case Error:
+		return "", reply
+	}
+	return "", fmt.Errorf("redigo: unexpected type for String, got type %T", reply)
+}
+
+// Bytes is a helper that converts a command reply to a slice of bytes. If err
+// is not equal to nil, then Bytes returns nil, err. Otherwise Bytes converts
+// the reply to a slice of bytes as follows:
+//
+//  Reply type      Result
+//  bulk string     reply, nil
+//  simple string   []byte(reply), nil
+//  nil             nil, ErrNil
+//  other           nil, error
+func Bytes(reply interface{}, err error) ([]byte, error) {
+	if err != nil {
+		return nil, err
+	}
+	switch reply := reply.(type) {
+	case []byte:
+		return reply, nil
+	case string:
+		return []byte(reply), nil
+	case nil:
+		return nil, ErrNil
+	case Error:
+		return nil, reply
+	}
+	return nil, fmt.Errorf("redigo: unexpected type for Bytes, got type %T", reply)
+}
+
+// Bool is a helper that converts a command reply to a boolean. If err is not
+// equal to nil, then Bool returns false, err. Otherwise Bool converts the
+// reply to boolean as follows:
+//
+//  Reply type      Result
+//  integer         value != 0, nil
+//  bulk string     strconv.ParseBool(reply)
+//  nil             false, ErrNil
+//  other           false, error
+func Bool(reply interface{}, err error) (bool, error) {
+	if err != nil {
+		return false, err
+	}
+	switch reply := reply.(type) {
+	case int64:
+		return reply != 0, nil
+	case []byte:
+		return strconv.ParseBool(string(reply))
+	case nil:
+		return false, ErrNil
+	case Error:
+		return false, reply
+	}
+	return false, fmt.Errorf("redigo: unexpected type for Bool, got type %T", reply)
+}
+
+// MultiBulk is a helper that converts an array command reply to a []interface{}.
+//
+// Deprecated: Use Values instead.
+func MultiBulk(reply interface{}, err error) ([]interface{}, error) { return Values(reply, err) }
+
+// Values is a helper that converts an array command reply to a []interface{}.
+// If err is not equal to nil, then Values returns nil, err. Otherwise, Values
+// converts the reply as follows:
+//
+//  Reply type      Result
+//  array           reply, nil
+//  nil             nil, ErrNil
+//  other           nil, error
+func Values(reply interface{}, err error) ([]interface{}, error) {
+	if err != nil {
+		return nil, err
+	}
+	switch reply := reply.(type) {
+	case []interface{}:
+		return reply, nil
+	case nil:
+		return nil, ErrNil
+	case Error:
+		return nil, reply
+	}
+	return nil, fmt.Errorf("redigo: unexpected type for Values, got type %T", reply)
+}
+
+func sliceHelper(reply interface{}, err error, name string, makeSlice func(int), assign func(int, interface{}) error) error {
+	if err != nil {
+		return err
+	}
+	switch reply := reply.(type) {
+	case []interface{}:
+		makeSlice(len(reply))
+		for i := range reply {
+			if reply[i] == nil {
+				continue
+			}
+			if err := assign(i, reply[i]); err != nil {
+				return err
+			}
+		}
+		return nil
+	case nil:
+		return ErrNil
+	case Error:
+		return reply
+	}
+	return fmt.Errorf("redigo: unexpected type for %s, got type %T", name, reply)
+}
+
+// Float64s is a helper that converts an array command reply to a []float64. If
+// err is not equal to nil, then Float64s returns nil, err. Nil array items are
+// converted to 0 in the output slice. Floats64 returns an error if an array
+// item is not a bulk string or nil.
+func Float64s(reply interface{}, err error) ([]float64, error) {
+	var result []float64
+	err = sliceHelper(reply, err, "Float64s", func(n int) { result = make([]float64, n) }, func(i int, v interface{}) error {
+		p, ok := v.([]byte)
+		if !ok {
+			return fmt.Errorf("redigo: unexpected element type for Floats64, got type %T", v)
+		}
+		f, err := strconv.ParseFloat(string(p), 64)
+		result[i] = f
+		return err
+	})
+	return result, err
+}
+
+// Strings is a helper that converts an array command reply to a []string. If
+// err is not equal to nil, then Strings returns nil, err. Nil array items are
+// converted to "" in the output slice. Strings returns an error if an array
+// item is not a bulk string or nil.
+func Strings(reply interface{}, err error) ([]string, error) {
+	var result []string
+	err = sliceHelper(reply, err, "Strings", func(n int) { result = make([]string, n) }, func(i int, v interface{}) error {
+		switch v := v.(type) {
+		case string:
+			result[i] = v
+			return nil
+		case []byte:
+			result[i] = string(v)
+			return nil
+		default:
+			return fmt.Errorf("redigo: unexpected element type for Strings, got type %T", v)
+		}
+	})
+	return result, err
+}
+
+// ByteSlices is a helper that converts an array command reply to a [][]byte.
+// If err is not equal to nil, then ByteSlices returns nil, err. Nil array
+// items are stay nil. ByteSlices returns an error if an array item is not a
+// bulk string or nil.
+func ByteSlices(reply interface{}, err error) ([][]byte, error) {
+	var result [][]byte
+	err = sliceHelper(reply, err, "ByteSlices", func(n int) { result = make([][]byte, n) }, func(i int, v interface{}) error {
+		p, ok := v.([]byte)
+		if !ok {
+			return fmt.Errorf("redigo: unexpected element type for ByteSlices, got type %T", v)
+		}
+		result[i] = p
+		return nil
+	})
+	return result, err
+}
+
+// Int64s is a helper that converts an array command reply to a []int64.
+// If err is not equal to nil, then Int64s returns nil, err. Nil array
+// items are stay nil. Int64s returns an error if an array item is not a
+// bulk string or nil.
+func Int64s(reply interface{}, err error) ([]int64, error) {
+	var result []int64
+	err = sliceHelper(reply, err, "Int64s", func(n int) { result = make([]int64, n) }, func(i int, v interface{}) error {
+		switch v := v.(type) {
+		case int64:
+			result[i] = v
+			return nil
+		case []byte:
+			n, err := strconv.ParseInt(string(v), 10, 64)
+			result[i] = n
+			return err
+		default:
+			return fmt.Errorf("redigo: unexpected element type for Int64s, got type %T", v)
+		}
+	})
+	return result, err
+}
+
+// Ints is a helper that converts an array command reply to a []in.
+// If err is not equal to nil, then Ints returns nil, err. Nil array
+// items are stay nil. Ints returns an error if an array item is not a
+// bulk string or nil.
+func Ints(reply interface{}, err error) ([]int, error) {
+	var result []int
+	err = sliceHelper(reply, err, "Ints", func(n int) { result = make([]int, n) }, func(i int, v interface{}) error {
+		switch v := v.(type) {
+		case int64:
+			n := int(v)
+			if int64(n) != v {
+				return strconv.ErrRange
+			}
+			result[i] = n
+			return nil
+		case []byte:
+			n, err := strconv.Atoi(string(v))
+			result[i] = n
+			return err
+		default:
+			return fmt.Errorf("redigo: unexpected element type for Ints, got type %T", v)
+		}
+	})
+	return result, err
+}
+
+// StringMap is a helper that converts an array of strings (alternating key, value)
+// into a map[string]string. The HGETALL and CONFIG GET commands return replies in this format.
+// Requires an even number of values in result.
+func StringMap(result interface{}, err error) (map[string]string, error) {
+	values, err := Values(result, err)
+	if err != nil {
+		return nil, err
+	}
+	if len(values)%2 != 0 {
+		return nil, errors.New("redigo: StringMap expects even number of values result")
+	}
+	m := make(map[string]string, len(values)/2)
+	for i := 0; i < len(values); i += 2 {
+		key, okKey := values[i].([]byte)
+		value, okValue := values[i+1].([]byte)
+		if !okKey || !okValue {
+			return nil, errors.New("redigo: StringMap key not a bulk string value")
+		}
+		m[string(key)] = string(value)
+	}
+	return m, nil
+}
+
+// IntMap is a helper that converts an array of strings (alternating key, value)
+// into a map[string]int. The HGETALL commands return replies in this format.
+// Requires an even number of values in result.
+func IntMap(result interface{}, err error) (map[string]int, error) {
+	values, err := Values(result, err)
+	if err != nil {
+		return nil, err
+	}
+	if len(values)%2 != 0 {
+		return nil, errors.New("redigo: IntMap expects even number of values result")
+	}
+	m := make(map[string]int, len(values)/2)
+	for i := 0; i < len(values); i += 2 {
+		key, ok := values[i].([]byte)
+		if !ok {
+			return nil, errors.New("redigo: IntMap key not a bulk string value")
+		}
+		value, err := Int(values[i+1], nil)
+		if err != nil {
+			return nil, err
+		}
+		m[string(key)] = value
+	}
+	return m, nil
+}
+
+// Int64Map is a helper that converts an array of strings (alternating key, value)
+// into a map[string]int64. The HGETALL commands return replies in this format.
+// Requires an even number of values in result.
+func Int64Map(result interface{}, err error) (map[string]int64, error) {
+	values, err := Values(result, err)
+	if err != nil {
+		return nil, err
+	}
+	if len(values)%2 != 0 {
+		return nil, errors.New("redigo: Int64Map expects even number of values result")
+	}
+	m := make(map[string]int64, len(values)/2)
+	for i := 0; i < len(values); i += 2 {
+		key, ok := values[i].([]byte)
+		if !ok {
+			return nil, errors.New("redigo: Int64Map key not a bulk string value")
+		}
+		value, err := Int64(values[i+1], nil)
+		if err != nil {
+			return nil, err
+		}
+		m[string(key)] = value
+	}
+	return m, nil
+}
+
+// Positions is a helper that converts an array of positions (lat, long)
+// into a [][2]float64. The GEOPOS command returns replies in this format.
+func Positions(result interface{}, err error) ([]*[2]float64, error) {
+	values, err := Values(result, err)
+	if err != nil {
+		return nil, err
+	}
+	positions := make([]*[2]float64, len(values))
+	for i := range values {
+		if values[i] == nil {
+			continue
+		}
+		p, ok := values[i].([]interface{})
+		if !ok {
+			return nil, fmt.Errorf("redigo: unexpected element type for interface slice, got type %T", values[i])
+		}
+		if len(p) != 2 {
+			return nil, fmt.Errorf("redigo: unexpected number of values for a member position, got %d", len(p))
+		}
+		lat, err := Float64(p[0], nil)
+		if err != nil {
+			return nil, err
+		}
+		long, err := Float64(p[1], nil)
+		if err != nil {
+			return nil, err
+		}
+		positions[i] = &[2]float64{lat, long}
+	}
+	return positions, nil
+}
Index: mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/reply_test.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/reply_test.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/reply_test.go	(revision 4485)
@@ -0,0 +1,209 @@
+// Copyright 2012 Gary Burd
+//
+// Licensed under the Apache License, Version 2.0 (the "License"): you may
+// not use this file except in compliance with the License. You may obtain
+// a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+// License for the specific language governing permissions and limitations
+// under the License.
+
+package redis_test
+
+import (
+	"fmt"
+	"reflect"
+	"testing"
+
+	"github.com/garyburd/redigo/redis"
+)
+
+type valueError struct {
+	v   interface{}
+	err error
+}
+
+func ve(v interface{}, err error) valueError {
+	return valueError{v, err}
+}
+
+var replyTests = []struct {
+	name     interface{}
+	actual   valueError
+	expected valueError
+}{
+	{
+		"ints([[]byte, []byte])",
+		ve(redis.Ints([]interface{}{[]byte("4"), []byte("5")}, nil)),
+		ve([]int{4, 5}, nil),
+	},
+	{
+		"ints([nt64, int64])",
+		ve(redis.Ints([]interface{}{int64(4), int64(5)}, nil)),
+		ve([]int{4, 5}, nil),
+	},
+	{
+		"ints([[]byte, nil, []byte])",
+		ve(redis.Ints([]interface{}{[]byte("4"), nil, []byte("5")}, nil)),
+		ve([]int{4, 0, 5}, nil),
+	},
+	{
+		"ints(nil)",
+		ve(redis.Ints(nil, nil)),
+		ve([]int(nil), redis.ErrNil),
+	},
+	{
+		"int64s([[]byte, []byte])",
+		ve(redis.Int64s([]interface{}{[]byte("4"), []byte("5")}, nil)),
+		ve([]int64{4, 5}, nil),
+	},
+	{
+		"int64s([int64, int64])",
+		ve(redis.Int64s([]interface{}{int64(4), int64(5)}, nil)),
+		ve([]int64{4, 5}, nil),
+	},
+	{
+		"strings([[]byte, []bytev2])",
+		ve(redis.Strings([]interface{}{[]byte("v1"), []byte("v2")}, nil)),
+		ve([]string{"v1", "v2"}, nil),
+	},
+	{
+		"strings([string, string])",
+		ve(redis.Strings([]interface{}{"v1", "v2"}, nil)),
+		ve([]string{"v1", "v2"}, nil),
+	},
+	{
+		"byteslices([v1, v2])",
+		ve(redis.ByteSlices([]interface{}{[]byte("v1"), []byte("v2")}, nil)),
+		ve([][]byte{[]byte("v1"), []byte("v2")}, nil),
+	},
+	{
+		"float64s([v1, v2])",
+		ve(redis.Float64s([]interface{}{[]byte("1.234"), []byte("5.678")}, nil)),
+		ve([]float64{1.234, 5.678}, nil),
+	},
+	{
+		"values([v1, v2])",
+		ve(redis.Values([]interface{}{[]byte("v1"), []byte("v2")}, nil)),
+		ve([]interface{}{[]byte("v1"), []byte("v2")}, nil),
+	},
+	{
+		"values(nil)",
+		ve(redis.Values(nil, nil)),
+		ve([]interface{}(nil), redis.ErrNil),
+	},
+	{
+		"float64(1.0)",
+		ve(redis.Float64([]byte("1.0"), nil)),
+		ve(float64(1.0), nil),
+	},
+	{
+		"float64(nil)",
+		ve(redis.Float64(nil, nil)),
+		ve(float64(0.0), redis.ErrNil),
+	},
+	{
+		"uint64(1)",
+		ve(redis.Uint64(int64(1), nil)),
+		ve(uint64(1), nil),
+	},
+	{
+		"uint64(-1)",
+		ve(redis.Uint64(int64(-1), nil)),
+		ve(uint64(0), redis.ErrNegativeInt),
+	},
+	{
+		"positions([[1, 2], nil, [3, 4]])",
+		ve(redis.Positions([]interface{}{[]interface{}{[]byte("1"), []byte("2")}, nil, []interface{}{[]byte("3"), []byte("4")}}, nil)),
+		ve([]*[2]float64{{1.0, 2.0}, nil, {3.0, 4.0}}, nil),
+	},
+}
+
+func TestReply(t *testing.T) {
+	for _, rt := range replyTests {
+		if rt.actual.err != rt.expected.err {
+			t.Errorf("%s returned err %v, want %v", rt.name, rt.actual.err, rt.expected.err)
+			continue
+		}
+		if !reflect.DeepEqual(rt.actual.v, rt.expected.v) {
+			t.Errorf("%s=%+v, want %+v", rt.name, rt.actual.v, rt.expected.v)
+		}
+	}
+}
+
+// dial wraps DialDefaultServer() with a more suitable function name for examples.
+func dial() (redis.Conn, error) {
+	return redis.DialDefaultServer()
+}
+
+// serverAddr wraps DefaultServerAddr() with a more suitable function name for examples.
+func serverAddr() (string, error) {
+	return redis.DefaultServerAddr()
+}
+
+func ExampleBool() {
+	c, err := dial()
+	if err != nil {
+		fmt.Println(err)
+		return
+	}
+	defer c.Close()
+
+	c.Do("SET", "foo", 1)
+	exists, _ := redis.Bool(c.Do("EXISTS", "foo"))
+	fmt.Printf("%#v\n", exists)
+	// Output:
+	// true
+}
+
+func ExampleInt() {
+	c, err := dial()
+	if err != nil {
+		fmt.Println(err)
+		return
+	}
+	defer c.Close()
+
+	c.Do("SET", "k1", 1)
+	n, _ := redis.Int(c.Do("GET", "k1"))
+	fmt.Printf("%#v\n", n)
+	n, _ = redis.Int(c.Do("INCR", "k1"))
+	fmt.Printf("%#v\n", n)
+	// Output:
+	// 1
+	// 2
+}
+
+func ExampleInts() {
+	c, err := dial()
+	if err != nil {
+		fmt.Println(err)
+		return
+	}
+	defer c.Close()
+
+	c.Do("SADD", "set_with_integers", 4, 5, 6)
+	ints, _ := redis.Ints(c.Do("SMEMBERS", "set_with_integers"))
+	fmt.Printf("%#v\n", ints)
+	// Output:
+	// []int{4, 5, 6}
+}
+
+func ExampleString() {
+	c, err := dial()
+	if err != nil {
+		fmt.Println(err)
+		return
+	}
+	defer c.Close()
+
+	c.Do("SET", "hello", "world")
+	s, err := redis.String(c.Do("GET", "hello"))
+	fmt.Printf("%#v\n", s)
+	// Output:
+	// "world"
+}
Index: mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/scan.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/scan.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/scan.go	(revision 4485)
@@ -0,0 +1,585 @@
+// Copyright 2012 Gary Burd
+//
+// Licensed under the Apache License, Version 2.0 (the "License"): you may
+// not use this file except in compliance with the License. You may obtain
+// a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+// License for the specific language governing permissions and limitations
+// under the License.
+
+package redis
+
+import (
+	"errors"
+	"fmt"
+	"reflect"
+	"strconv"
+	"strings"
+	"sync"
+)
+
+func ensureLen(d reflect.Value, n int) {
+	if n > d.Cap() {
+		d.Set(reflect.MakeSlice(d.Type(), n, n))
+	} else {
+		d.SetLen(n)
+	}
+}
+
+func cannotConvert(d reflect.Value, s interface{}) error {
+	var sname string
+	switch s.(type) {
+	case string:
+		sname = "Redis simple string"
+	case Error:
+		sname = "Redis error"
+	case int64:
+		sname = "Redis integer"
+	case []byte:
+		sname = "Redis bulk string"
+	case []interface{}:
+		sname = "Redis array"
+	default:
+		sname = reflect.TypeOf(s).String()
+	}
+	return fmt.Errorf("cannot convert from %s to %s", sname, d.Type())
+}
+
+func convertAssignBulkString(d reflect.Value, s []byte) (err error) {
+	switch d.Type().Kind() {
+	case reflect.Float32, reflect.Float64:
+		var x float64
+		x, err = strconv.ParseFloat(string(s), d.Type().Bits())
+		d.SetFloat(x)
+	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
+		var x int64
+		x, err = strconv.ParseInt(string(s), 10, d.Type().Bits())
+		d.SetInt(x)
+	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
+		var x uint64
+		x, err = strconv.ParseUint(string(s), 10, d.Type().Bits())
+		d.SetUint(x)
+	case reflect.Bool:
+		var x bool
+		x, err = strconv.ParseBool(string(s))
+		d.SetBool(x)
+	case reflect.String:
+		d.SetString(string(s))
+	case reflect.Slice:
+		if d.Type().Elem().Kind() != reflect.Uint8 {
+			err = cannotConvert(d, s)
+		} else {
+			d.SetBytes(s)
+		}
+	default:
+		err = cannotConvert(d, s)
+	}
+	return
+}
+
+func convertAssignInt(d reflect.Value, s int64) (err error) {
+	switch d.Type().Kind() {
+	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
+		d.SetInt(s)
+		if d.Int() != s {
+			err = strconv.ErrRange
+			d.SetInt(0)
+		}
+	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
+		if s < 0 {
+			err = strconv.ErrRange
+		} else {
+			x := uint64(s)
+			d.SetUint(x)
+			if d.Uint() != x {
+				err = strconv.ErrRange
+				d.SetUint(0)
+			}
+		}
+	case reflect.Bool:
+		d.SetBool(s != 0)
+	default:
+		err = cannotConvert(d, s)
+	}
+	return
+}
+
+func convertAssignValue(d reflect.Value, s interface{}) (err error) {
+	if d.Kind() != reflect.Ptr {
+		if d.CanAddr() {
+			d2 := d.Addr()
+			if d2.CanInterface() {
+				if scanner, ok := d2.Interface().(Scanner); ok {
+					return scanner.RedisScan(s)
+				}
+			}
+		}
+	} else if d.CanInterface() {
+		// Already a reflect.Ptr
+		if d.IsNil() {
+			d.Set(reflect.New(d.Type().Elem()))
+		}
+		if scanner, ok := d.Interface().(Scanner); ok {
+			return scanner.RedisScan(s)
+		}
+	}
+
+	switch s := s.(type) {
+	case []byte:
+		err = convertAssignBulkString(d, s)
+	case int64:
+		err = convertAssignInt(d, s)
+	default:
+		err = cannotConvert(d, s)
+	}
+	return err
+}
+
+func convertAssignArray(d reflect.Value, s []interface{}) error {
+	if d.Type().Kind() != reflect.Slice {
+		return cannotConvert(d, s)
+	}
+	ensureLen(d, len(s))
+	for i := 0; i < len(s); i++ {
+		if err := convertAssignValue(d.Index(i), s[i]); err != nil {
+			return err
+		}
+	}
+	return nil
+}
+
+func convertAssign(d interface{}, s interface{}) (err error) {
+	if scanner, ok := d.(Scanner); ok {
+		return scanner.RedisScan(s)
+	}
+
+	// Handle the most common destination types using type switches and
+	// fall back to reflection for all other types.
+	switch s := s.(type) {
+	case nil:
+		// ignore
+	case []byte:
+		switch d := d.(type) {
+		case *string:
+			*d = string(s)
+		case *int:
+			*d, err = strconv.Atoi(string(s))
+		case *bool:
+			*d, err = strconv.ParseBool(string(s))
+		case *[]byte:
+			*d = s
+		case *interface{}:
+			*d = s
+		case nil:
+			// skip value
+		default:
+			if d := reflect.ValueOf(d); d.Type().Kind() != reflect.Ptr {
+				err = cannotConvert(d, s)
+			} else {
+				err = convertAssignBulkString(d.Elem(), s)
+			}
+		}
+	case int64:
+		switch d := d.(type) {
+		case *int:
+			x := int(s)
+			if int64(x) != s {
+				err = strconv.ErrRange
+				x = 0
+			}
+			*d = x
+		case *bool:
+			*d = s != 0
+		case *interface{}:
+			*d = s
+		case nil:
+			// skip value
+		default:
+			if d := reflect.ValueOf(d); d.Type().Kind() != reflect.Ptr {
+				err = cannotConvert(d, s)
+			} else {
+				err = convertAssignInt(d.Elem(), s)
+			}
+		}
+	case string:
+		switch d := d.(type) {
+		case *string:
+			*d = s
+		case *interface{}:
+			*d = s
+		case nil:
+			// skip value
+		default:
+			err = cannotConvert(reflect.ValueOf(d), s)
+		}
+	case []interface{}:
+		switch d := d.(type) {
+		case *[]interface{}:
+			*d = s
+		case *interface{}:
+			*d = s
+		case nil:
+			// skip value
+		default:
+			if d := reflect.ValueOf(d); d.Type().Kind() != reflect.Ptr {
+				err = cannotConvert(d, s)
+			} else {
+				err = convertAssignArray(d.Elem(), s)
+			}
+		}
+	case Error:
+		err = s
+	default:
+		err = cannotConvert(reflect.ValueOf(d), s)
+	}
+	return
+}
+
+// Scan copies from src to the values pointed at by dest.
+//
+// Scan uses RedisScan if available otherwise:
+//
+// The values pointed at by dest must be an integer, float, boolean, string,
+// []byte, interface{} or slices of these types. Scan uses the standard strconv
+// package to convert bulk strings to numeric and boolean types.
+//
+// If a dest value is nil, then the corresponding src value is skipped.
+//
+// If a src element is nil, then the corresponding dest value is not modified.
+//
+// To enable easy use of Scan in a loop, Scan returns the slice of src
+// following the copied values.
+func Scan(src []interface{}, dest ...interface{}) ([]interface{}, error) {
+	if len(src) < len(dest) {
+		return nil, errors.New("redigo.Scan: array short")
+	}
+	var err error
+	for i, d := range dest {
+		err = convertAssign(d, src[i])
+		if err != nil {
+			err = fmt.Errorf("redigo.Scan: cannot assign to dest %d: %v", i, err)
+			break
+		}
+	}
+	return src[len(dest):], err
+}
+
+type fieldSpec struct {
+	name      string
+	index     []int
+	omitEmpty bool
+}
+
+type structSpec struct {
+	m map[string]*fieldSpec
+	l []*fieldSpec
+}
+
+func (ss *structSpec) fieldSpec(name []byte) *fieldSpec {
+	return ss.m[string(name)]
+}
+
+func compileStructSpec(t reflect.Type, depth map[string]int, index []int, ss *structSpec) {
+	for i := 0; i < t.NumField(); i++ {
+		f := t.Field(i)
+		switch {
+		case f.PkgPath != "" && !f.Anonymous:
+			// Ignore unexported fields.
+		case f.Anonymous:
+			// TODO: Handle pointers. Requires change to decoder and
+			// protection against infinite recursion.
+			if f.Type.Kind() == reflect.Struct {
+				compileStructSpec(f.Type, depth, append(index, i), ss)
+			}
+		default:
+			fs := &fieldSpec{name: f.Name}
+			tag := f.Tag.Get("redis")
+			p := strings.Split(tag, ",")
+			if len(p) > 0 {
+				if p[0] == "-" {
+					continue
+				}
+				if len(p[0]) > 0 {
+					fs.name = p[0]
+				}
+				for _, s := range p[1:] {
+					switch s {
+					case "omitempty":
+						fs.omitEmpty = true
+					default:
+						panic(fmt.Errorf("redigo: unknown field tag %s for type %s", s, t.Name()))
+					}
+				}
+			}
+			d, found := depth[fs.name]
+			if !found {
+				d = 1 << 30
+			}
+			switch {
+			case len(index) == d:
+				// At same depth, remove from result.
+				delete(ss.m, fs.name)
+				j := 0
+				for i := 0; i < len(ss.l); i++ {
+					if fs.name != ss.l[i].name {
+						ss.l[j] = ss.l[i]
+						j += 1
+					}
+				}
+				ss.l = ss.l[:j]
+			case len(index) < d:
+				fs.index = make([]int, len(index)+1)
+				copy(fs.index, index)
+				fs.index[len(index)] = i
+				depth[fs.name] = len(index)
+				ss.m[fs.name] = fs
+				ss.l = append(ss.l, fs)
+			}
+		}
+	}
+}
+
+var (
+	structSpecMutex  sync.RWMutex
+	structSpecCache  = make(map[reflect.Type]*structSpec)
+	defaultFieldSpec = &fieldSpec{}
+)
+
+func structSpecForType(t reflect.Type) *structSpec {
+
+	structSpecMutex.RLock()
+	ss, found := structSpecCache[t]
+	structSpecMutex.RUnlock()
+	if found {
+		return ss
+	}
+
+	structSpecMutex.Lock()
+	defer structSpecMutex.Unlock()
+	ss, found = structSpecCache[t]
+	if found {
+		return ss
+	}
+
+	ss = &structSpec{m: make(map[string]*fieldSpec)}
+	compileStructSpec(t, make(map[string]int), nil, ss)
+	structSpecCache[t] = ss
+	return ss
+}
+
+var errScanStructValue = errors.New("redigo.ScanStruct: value must be non-nil pointer to a struct")
+
+// ScanStruct scans alternating names and values from src to a struct. The
+// HGETALL and CONFIG GET commands return replies in this format.
+//
+// ScanStruct uses exported field names to match values in the response. Use
+// 'redis' field tag to override the name:
+//
+//      Field int `redis:"myName"`
+//
+// Fields with the tag redis:"-" are ignored.
+//
+// Each field uses RedisScan if available otherwise:
+// Integer, float, boolean, string and []byte fields are supported. Scan uses the
+// standard strconv package to convert bulk string values to numeric and
+// boolean types.
+//
+// If a src element is nil, then the corresponding field is not modified.
+func ScanStruct(src []interface{}, dest interface{}) error {
+	d := reflect.ValueOf(dest)
+	if d.Kind() != reflect.Ptr || d.IsNil() {
+		return errScanStructValue
+	}
+	d = d.Elem()
+	if d.Kind() != reflect.Struct {
+		return errScanStructValue
+	}
+	ss := structSpecForType(d.Type())
+
+	if len(src)%2 != 0 {
+		return errors.New("redigo.ScanStruct: number of values not a multiple of 2")
+	}
+
+	for i := 0; i < len(src); i += 2 {
+		s := src[i+1]
+		if s == nil {
+			continue
+		}
+		name, ok := src[i].([]byte)
+		if !ok {
+			return fmt.Errorf("redigo.ScanStruct: key %d not a bulk string value", i)
+		}
+		fs := ss.fieldSpec(name)
+		if fs == nil {
+			continue
+		}
+		if err := convertAssignValue(d.FieldByIndex(fs.index), s); err != nil {
+			return fmt.Errorf("redigo.ScanStruct: cannot assign field %s: %v", fs.name, err)
+		}
+	}
+	return nil
+}
+
+var (
+	errScanSliceValue = errors.New("redigo.ScanSlice: dest must be non-nil pointer to a struct")
+)
+
+// ScanSlice scans src to the slice pointed to by dest. The elements the dest
+// slice must be integer, float, boolean, string, struct or pointer to struct
+// values.
+//
+// Struct fields must be integer, float, boolean or string values. All struct
+// fields are used unless a subset is specified using fieldNames.
+func ScanSlice(src []interface{}, dest interface{}, fieldNames ...string) error {
+	d := reflect.ValueOf(dest)
+	if d.Kind() != reflect.Ptr || d.IsNil() {
+		return errScanSliceValue
+	}
+	d = d.Elem()
+	if d.Kind() != reflect.Slice {
+		return errScanSliceValue
+	}
+
+	isPtr := false
+	t := d.Type().Elem()
+	if t.Kind() == reflect.Ptr && t.Elem().Kind() == reflect.Struct {
+		isPtr = true
+		t = t.Elem()
+	}
+
+	if t.Kind() != reflect.Struct {
+		ensureLen(d, len(src))
+		for i, s := range src {
+			if s == nil {
+				continue
+			}
+			if err := convertAssignValue(d.Index(i), s); err != nil {
+				return fmt.Errorf("redigo.ScanSlice: cannot assign element %d: %v", i, err)
+			}
+		}
+		return nil
+	}
+
+	ss := structSpecForType(t)
+	fss := ss.l
+	if len(fieldNames) > 0 {
+		fss = make([]*fieldSpec, len(fieldNames))
+		for i, name := range fieldNames {
+			fss[i] = ss.m[name]
+			if fss[i] == nil {
+				return fmt.Errorf("redigo.ScanSlice: ScanSlice bad field name %s", name)
+			}
+		}
+	}
+
+	if len(fss) == 0 {
+		return errors.New("redigo.ScanSlice: no struct fields")
+	}
+
+	n := len(src) / len(fss)
+	if n*len(fss) != len(src) {
+		return errors.New("redigo.ScanSlice: length not a multiple of struct field count")
+	}
+
+	ensureLen(d, n)
+	for i := 0; i < n; i++ {
+		d := d.Index(i)
+		if isPtr {
+			if d.IsNil() {
+				d.Set(reflect.New(t))
+			}
+			d = d.Elem()
+		}
+		for j, fs := range fss {
+			s := src[i*len(fss)+j]
+			if s == nil {
+				continue
+			}
+			if err := convertAssignValue(d.FieldByIndex(fs.index), s); err != nil {
+				return fmt.Errorf("redigo.ScanSlice: cannot assign element %d to field %s: %v", i*len(fss)+j, fs.name, err)
+			}
+		}
+	}
+	return nil
+}
+
+// Args is a helper for constructing command arguments from structured values.
+type Args []interface{}
+
+// Add returns the result of appending value to args.
+func (args Args) Add(value ...interface{}) Args {
+	return append(args, value...)
+}
+
+// AddFlat returns the result of appending the flattened value of v to args.
+//
+// Maps are flattened by appending the alternating keys and map values to args.
+//
+// Slices are flattened by appending the slice elements to args.
+//
+// Structs are flattened by appending the alternating names and values of
+// exported fields to args. If v is a nil struct pointer, then nothing is
+// appended. The 'redis' field tag overrides struct field names. See ScanStruct
+// for more information on the use of the 'redis' field tag.
+//
+// Other types are appended to args as is.
+func (args Args) AddFlat(v interface{}) Args {
+	rv := reflect.ValueOf(v)
+	switch rv.Kind() {
+	case reflect.Struct:
+		args = flattenStruct(args, rv)
+	case reflect.Slice:
+		for i := 0; i < rv.Len(); i++ {
+			args = append(args, rv.Index(i).Interface())
+		}
+	case reflect.Map:
+		for _, k := range rv.MapKeys() {
+			args = append(args, k.Interface(), rv.MapIndex(k).Interface())
+		}
+	case reflect.Ptr:
+		if rv.Type().Elem().Kind() == reflect.Struct {
+			if !rv.IsNil() {
+				args = flattenStruct(args, rv.Elem())
+			}
+		} else {
+			args = append(args, v)
+		}
+	default:
+		args = append(args, v)
+	}
+	return args
+}
+
+func flattenStruct(args Args, v reflect.Value) Args {
+	ss := structSpecForType(v.Type())
+	for _, fs := range ss.l {
+		fv := v.FieldByIndex(fs.index)
+		if fs.omitEmpty {
+			var empty = false
+			switch fv.Kind() {
+			case reflect.Array, reflect.Map, reflect.Slice, reflect.String:
+				empty = fv.Len() == 0
+			case reflect.Bool:
+				empty = !fv.Bool()
+			case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
+				empty = fv.Int() == 0
+			case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
+				empty = fv.Uint() == 0
+			case reflect.Float32, reflect.Float64:
+				empty = fv.Float() == 0
+			case reflect.Interface, reflect.Ptr:
+				empty = fv.IsNil()
+			}
+			if empty {
+				continue
+			}
+		}
+		args = append(args, fs.name, fv.Interface())
+	}
+	return args
+}
Index: mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/scan_test.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/scan_test.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/scan_test.go	(revision 4485)
@@ -0,0 +1,494 @@
+// Copyright 2012 Gary Burd
+//
+// Licensed under the Apache License, Version 2.0 (the "License"): you may
+// not use this file except in compliance with the License. You may obtain
+// a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+// License for the specific language governing permissions and limitations
+// under the License.
+
+package redis_test
+
+import (
+	"fmt"
+	"math"
+	"reflect"
+	"testing"
+	"time"
+
+	"github.com/garyburd/redigo/redis"
+)
+
+type durationScan struct {
+	time.Duration `redis:"sd"`
+}
+
+func (t *durationScan) RedisScan(src interface{}) (err error) {
+	if t == nil {
+		return fmt.Errorf("nil pointer")
+	}
+	switch src := src.(type) {
+	case string:
+		t.Duration, err = time.ParseDuration(src)
+	case []byte:
+		t.Duration, err = time.ParseDuration(string(src))
+	case int64:
+		t.Duration = time.Duration(src)
+	default:
+		err = fmt.Errorf("cannot convert from %T to %T", src, t)
+	}
+	return err
+}
+
+var scanConversionTests = []struct {
+	src  interface{}
+	dest interface{}
+}{
+	{[]byte("-inf"), math.Inf(-1)},
+	{[]byte("+inf"), math.Inf(1)},
+	{[]byte("0"), float64(0)},
+	{[]byte("3.14159"), float64(3.14159)},
+	{[]byte("3.14"), float32(3.14)},
+	{[]byte("-100"), int(-100)},
+	{[]byte("101"), int(101)},
+	{int64(102), int(102)},
+	{[]byte("103"), uint(103)},
+	{int64(104), uint(104)},
+	{[]byte("105"), int8(105)},
+	{int64(106), int8(106)},
+	{[]byte("107"), uint8(107)},
+	{int64(108), uint8(108)},
+	{[]byte("0"), false},
+	{int64(0), false},
+	{[]byte("f"), false},
+	{[]byte("1"), true},
+	{int64(1), true},
+	{[]byte("t"), true},
+	{"hello", "hello"},
+	{[]byte("hello"), "hello"},
+	{[]byte("world"), []byte("world")},
+	{[]interface{}{[]byte("foo")}, []interface{}{[]byte("foo")}},
+	{[]interface{}{[]byte("foo")}, []string{"foo"}},
+	{[]interface{}{[]byte("hello"), []byte("world")}, []string{"hello", "world"}},
+	{[]interface{}{[]byte("bar")}, [][]byte{[]byte("bar")}},
+	{[]interface{}{[]byte("1")}, []int{1}},
+	{[]interface{}{[]byte("1"), []byte("2")}, []int{1, 2}},
+	{[]interface{}{[]byte("1"), []byte("2")}, []float64{1, 2}},
+	{[]interface{}{[]byte("1")}, []byte{1}},
+	{[]interface{}{[]byte("1")}, []bool{true}},
+	{"1m", durationScan{Duration: time.Minute}},
+	{[]byte("1m"), durationScan{Duration: time.Minute}},
+	{time.Minute.Nanoseconds(), durationScan{Duration: time.Minute}},
+	{[]interface{}{[]byte("1m")}, []durationScan{{Duration: time.Minute}}},
+	{[]interface{}{[]byte("1m")}, []*durationScan{{Duration: time.Minute}}},
+}
+
+func TestScanConversion(t *testing.T) {
+	for _, tt := range scanConversionTests {
+		values := []interface{}{tt.src}
+		dest := reflect.New(reflect.TypeOf(tt.dest))
+		values, err := redis.Scan(values, dest.Interface())
+		if err != nil {
+			t.Errorf("Scan(%v) returned error %v", tt, err)
+			continue
+		}
+		if !reflect.DeepEqual(tt.dest, dest.Elem().Interface()) {
+			t.Errorf("Scan(%v) returned %v, want %v", tt, dest.Elem().Interface(), tt.dest)
+		}
+	}
+}
+
+var scanConversionErrorTests = []struct {
+	src  interface{}
+	dest interface{}
+}{
+	{[]byte("1234"), byte(0)},
+	{int64(1234), byte(0)},
+	{[]byte("-1"), byte(0)},
+	{int64(-1), byte(0)},
+	{[]byte("junk"), false},
+	{redis.Error("blah"), false},
+	{redis.Error("blah"), durationScan{Duration: time.Minute}},
+	{"invalid", durationScan{Duration: time.Minute}},
+}
+
+func TestScanConversionError(t *testing.T) {
+	for _, tt := range scanConversionErrorTests {
+		values := []interface{}{tt.src}
+		dest := reflect.New(reflect.TypeOf(tt.dest))
+		values, err := redis.Scan(values, dest.Interface())
+		if err == nil {
+			t.Errorf("Scan(%v) did not return error", tt)
+		}
+	}
+}
+
+func ExampleScan() {
+	c, err := dial()
+	if err != nil {
+		fmt.Println(err)
+		return
+	}
+	defer c.Close()
+
+	c.Send("HMSET", "album:1", "title", "Red", "rating", 5)
+	c.Send("HMSET", "album:2", "title", "Earthbound", "rating", 1)
+	c.Send("HMSET", "album:3", "title", "Beat")
+	c.Send("LPUSH", "albums", "1")
+	c.Send("LPUSH", "albums", "2")
+	c.Send("LPUSH", "albums", "3")
+	values, err := redis.Values(c.Do("SORT", "albums",
+		"BY", "album:*->rating",
+		"GET", "album:*->title",
+		"GET", "album:*->rating"))
+	if err != nil {
+		fmt.Println(err)
+		return
+	}
+
+	for len(values) > 0 {
+		var title string
+		rating := -1 // initialize to illegal value to detect nil.
+		values, err = redis.Scan(values, &title, &rating)
+		if err != nil {
+			fmt.Println(err)
+			return
+		}
+		if rating == -1 {
+			fmt.Println(title, "not-rated")
+		} else {
+			fmt.Println(title, rating)
+		}
+	}
+	// Output:
+	// Beat not-rated
+	// Earthbound 1
+	// Red 5
+}
+
+type s0 struct {
+	X  int
+	Y  int `redis:"y"`
+	Bt bool
+}
+
+type s1 struct {
+	X  int    `redis:"-"`
+	I  int    `redis:"i"`
+	U  uint   `redis:"u"`
+	S  string `redis:"s"`
+	P  []byte `redis:"p"`
+	B  bool   `redis:"b"`
+	Bt bool
+	Bf bool
+	s0
+	Sd  durationScan  `redis:"sd"`
+	Sdp *durationScan `redis:"sdp"`
+}
+
+var scanStructTests = []struct {
+	title string
+	reply []string
+	value interface{}
+}{
+	{"basic",
+		[]string{
+			"i", "-1234",
+			"u", "5678",
+			"s", "hello",
+			"p", "world",
+			"b", "t",
+			"Bt", "1",
+			"Bf", "0",
+			"X", "123",
+			"y", "456",
+			"sd", "1m",
+			"sdp", "1m",
+		},
+		&s1{
+			I:   -1234,
+			U:   5678,
+			S:   "hello",
+			P:   []byte("world"),
+			B:   true,
+			Bt:  true,
+			Bf:  false,
+			s0:  s0{X: 123, Y: 456},
+			Sd:  durationScan{Duration: time.Minute},
+			Sdp: &durationScan{Duration: time.Minute},
+		},
+	},
+}
+
+func TestScanStruct(t *testing.T) {
+	for _, tt := range scanStructTests {
+
+		var reply []interface{}
+		for _, v := range tt.reply {
+			reply = append(reply, []byte(v))
+		}
+
+		value := reflect.New(reflect.ValueOf(tt.value).Type().Elem())
+
+		if err := redis.ScanStruct(reply, value.Interface()); err != nil {
+			t.Fatalf("ScanStruct(%s) returned error %v", tt.title, err)
+		}
+
+		if !reflect.DeepEqual(value.Interface(), tt.value) {
+			t.Fatalf("ScanStruct(%s) returned %v, want %v", tt.title, value.Interface(), tt.value)
+		}
+	}
+}
+
+func TestBadScanStructArgs(t *testing.T) {
+	x := []interface{}{"A", "b"}
+	test := func(v interface{}) {
+		if err := redis.ScanStruct(x, v); err == nil {
+			t.Errorf("Expect error for ScanStruct(%T, %T)", x, v)
+		}
+	}
+
+	test(nil)
+
+	var v0 *struct{}
+	test(v0)
+
+	var v1 int
+	test(&v1)
+
+	x = x[:1]
+	v2 := struct{ A string }{}
+	test(&v2)
+}
+
+var scanSliceTests = []struct {
+	src        []interface{}
+	fieldNames []string
+	ok         bool
+	dest       interface{}
+}{
+	{
+		[]interface{}{[]byte("1"), nil, []byte("-1")},
+		nil,
+		true,
+		[]int{1, 0, -1},
+	},
+	{
+		[]interface{}{[]byte("1"), nil, []byte("2")},
+		nil,
+		true,
+		[]uint{1, 0, 2},
+	},
+	{
+		[]interface{}{[]byte("-1")},
+		nil,
+		false,
+		[]uint{1},
+	},
+	{
+		[]interface{}{[]byte("hello"), nil, []byte("world")},
+		nil,
+		true,
+		[][]byte{[]byte("hello"), nil, []byte("world")},
+	},
+	{
+		[]interface{}{[]byte("hello"), nil, []byte("world")},
+		nil,
+		true,
+		[]string{"hello", "", "world"},
+	},
+	{
+		[]interface{}{[]byte("a1"), []byte("b1"), []byte("a2"), []byte("b2")},
+		nil,
+		true,
+		[]struct{ A, B string }{{"a1", "b1"}, {"a2", "b2"}},
+	},
+	{
+		[]interface{}{[]byte("a1"), []byte("b1")},
+		nil,
+		false,
+		[]struct{ A, B, C string }{{"a1", "b1", ""}},
+	},
+	{
+		[]interface{}{[]byte("a1"), []byte("b1"), []byte("a2"), []byte("b2")},
+		nil,
+		true,
+		[]*struct{ A, B string }{{A: "a1", B: "b1"}, {A: "a2", B: "b2"}},
+	},
+	{
+		[]interface{}{[]byte("a1"), []byte("b1"), []byte("a2"), []byte("b2")},
+		[]string{"A", "B"},
+		true,
+		[]struct{ A, C, B string }{{"a1", "", "b1"}, {"a2", "", "b2"}},
+	},
+	{
+		[]interface{}{[]byte("a1"), []byte("b1"), []byte("a2"), []byte("b2")},
+		nil,
+		false,
+		[]struct{}{},
+	},
+}
+
+func TestScanSlice(t *testing.T) {
+	for _, tt := range scanSliceTests {
+
+		typ := reflect.ValueOf(tt.dest).Type()
+		dest := reflect.New(typ)
+
+		err := redis.ScanSlice(tt.src, dest.Interface(), tt.fieldNames...)
+		if tt.ok != (err == nil) {
+			t.Errorf("ScanSlice(%v, []%s, %v) returned error %v", tt.src, typ, tt.fieldNames, err)
+			continue
+		}
+		if tt.ok && !reflect.DeepEqual(dest.Elem().Interface(), tt.dest) {
+			t.Errorf("ScanSlice(src, []%s) returned %#v, want %#v", typ, dest.Elem().Interface(), tt.dest)
+		}
+	}
+}
+
+func ExampleScanSlice() {
+	c, err := dial()
+	if err != nil {
+		fmt.Println(err)
+		return
+	}
+	defer c.Close()
+
+	c.Send("HMSET", "album:1", "title", "Red", "rating", 5)
+	c.Send("HMSET", "album:2", "title", "Earthbound", "rating", 1)
+	c.Send("HMSET", "album:3", "title", "Beat", "rating", 4)
+	c.Send("LPUSH", "albums", "1")
+	c.Send("LPUSH", "albums", "2")
+	c.Send("LPUSH", "albums", "3")
+	values, err := redis.Values(c.Do("SORT", "albums",
+		"BY", "album:*->rating",
+		"GET", "album:*->title",
+		"GET", "album:*->rating"))
+	if err != nil {
+		fmt.Println(err)
+		return
+	}
+
+	var albums []struct {
+		Title  string
+		Rating int
+	}
+	if err := redis.ScanSlice(values, &albums); err != nil {
+		fmt.Println(err)
+		return
+	}
+	fmt.Printf("%v\n", albums)
+	// Output:
+	// [{Earthbound 1} {Beat 4} {Red 5}]
+}
+
+var argsTests = []struct {
+	title    string
+	actual   redis.Args
+	expected redis.Args
+}{
+	{"struct ptr",
+		redis.Args{}.AddFlat(&struct {
+			I  int               `redis:"i"`
+			U  uint              `redis:"u"`
+			S  string            `redis:"s"`
+			P  []byte            `redis:"p"`
+			M  map[string]string `redis:"m"`
+			Bt bool
+			Bf bool
+		}{
+			-1234, 5678, "hello", []byte("world"), map[string]string{"hello": "world"}, true, false,
+		}),
+		redis.Args{"i", int(-1234), "u", uint(5678), "s", "hello", "p", []byte("world"), "m", map[string]string{"hello": "world"}, "Bt", true, "Bf", false},
+	},
+	{"struct",
+		redis.Args{}.AddFlat(struct{ I int }{123}),
+		redis.Args{"I", 123},
+	},
+	{"slice",
+		redis.Args{}.Add(1).AddFlat([]string{"a", "b", "c"}).Add(2),
+		redis.Args{1, "a", "b", "c", 2},
+	},
+	{"struct omitempty",
+		redis.Args{}.AddFlat(&struct {
+			I  int               `redis:"i,omitempty"`
+			U  uint              `redis:"u,omitempty"`
+			S  string            `redis:"s,omitempty"`
+			P  []byte            `redis:"p,omitempty"`
+			M  map[string]string `redis:"m,omitempty"`
+			Bt bool              `redis:"Bt,omitempty"`
+			Bf bool              `redis:"Bf,omitempty"`
+		}{
+			0, 0, "", []byte{}, map[string]string{}, true, false,
+		}),
+		redis.Args{"Bt", true},
+	},
+}
+
+func TestArgs(t *testing.T) {
+	for _, tt := range argsTests {
+		if !reflect.DeepEqual(tt.actual, tt.expected) {
+			t.Fatalf("%s is %v, want %v", tt.title, tt.actual, tt.expected)
+		}
+	}
+}
+
+func ExampleArgs() {
+	c, err := dial()
+	if err != nil {
+		fmt.Println(err)
+		return
+	}
+	defer c.Close()
+
+	var p1, p2 struct {
+		Title  string `redis:"title"`
+		Author string `redis:"author"`
+		Body   string `redis:"body"`
+	}
+
+	p1.Title = "Example"
+	p1.Author = "Gary"
+	p1.Body = "Hello"
+
+	if _, err := c.Do("HMSET", redis.Args{}.Add("id1").AddFlat(&p1)...); err != nil {
+		fmt.Println(err)
+		return
+	}
+
+	m := map[string]string{
+		"title":  "Example2",
+		"author": "Steve",
+		"body":   "Map",
+	}
+
+	if _, err := c.Do("HMSET", redis.Args{}.Add("id2").AddFlat(m)...); err != nil {
+		fmt.Println(err)
+		return
+	}
+
+	for _, id := range []string{"id1", "id2"} {
+
+		v, err := redis.Values(c.Do("HGETALL", id))
+		if err != nil {
+			fmt.Println(err)
+			return
+		}
+
+		if err := redis.ScanStruct(v, &p2); err != nil {
+			fmt.Println(err)
+			return
+		}
+
+		fmt.Printf("%+v\n", p2)
+	}
+
+	// Output:
+	// {Title:Example Author:Gary Body:Hello}
+	// {Title:Example2 Author:Steve Body:Map}
+}
Index: mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/script.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/script.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/script.go	(revision 4485)
@@ -0,0 +1,91 @@
+// Copyright 2012 Gary Burd
+//
+// Licensed under the Apache License, Version 2.0 (the "License"): you may
+// not use this file except in compliance with the License. You may obtain
+// a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+// License for the specific language governing permissions and limitations
+// under the License.
+
+package redis
+
+import (
+	"crypto/sha1"
+	"encoding/hex"
+	"io"
+	"strings"
+)
+
+// Script encapsulates the source, hash and key count for a Lua script. See
+// http://redis.io/commands/eval for information on scripts in Redis.
+type Script struct {
+	keyCount int
+	src      string
+	hash     string
+}
+
+// NewScript returns a new script object. If keyCount is greater than or equal
+// to zero, then the count is automatically inserted in the EVAL command
+// argument list. If keyCount is less than zero, then the application supplies
+// the count as the first value in the keysAndArgs argument to the Do, Send and
+// SendHash methods.
+func NewScript(keyCount int, src string) *Script {
+	h := sha1.New()
+	io.WriteString(h, src)
+	return &Script{keyCount, src, hex.EncodeToString(h.Sum(nil))}
+}
+
+func (s *Script) args(spec string, keysAndArgs []interface{}) []interface{} {
+	var args []interface{}
+	if s.keyCount < 0 {
+		args = make([]interface{}, 1+len(keysAndArgs))
+		args[0] = spec
+		copy(args[1:], keysAndArgs)
+	} else {
+		args = make([]interface{}, 2+len(keysAndArgs))
+		args[0] = spec
+		args[1] = s.keyCount
+		copy(args[2:], keysAndArgs)
+	}
+	return args
+}
+
+// Hash returns the script hash.
+func (s *Script) Hash() string {
+	return s.hash
+}
+
+// Do evaluates the script. Under the covers, Do optimistically evaluates the
+// script using the EVALSHA command. If the command fails because the script is
+// not loaded, then Do evaluates the script using the EVAL command (thus
+// causing the script to load).
+func (s *Script) Do(c Conn, keysAndArgs ...interface{}) (interface{}, error) {
+	v, err := c.Do("EVALSHA", s.args(s.hash, keysAndArgs)...)
+	if e, ok := err.(Error); ok && strings.HasPrefix(string(e), "NOSCRIPT ") {
+		v, err = c.Do("EVAL", s.args(s.src, keysAndArgs)...)
+	}
+	return v, err
+}
+
+// SendHash evaluates the script without waiting for the reply. The script is
+// evaluated with the EVALSHA command. The application must ensure that the
+// script is loaded by a previous call to Send, Do or Load methods.
+func (s *Script) SendHash(c Conn, keysAndArgs ...interface{}) error {
+	return c.Send("EVALSHA", s.args(s.hash, keysAndArgs)...)
+}
+
+// Send evaluates the script without waiting for the reply.
+func (s *Script) Send(c Conn, keysAndArgs ...interface{}) error {
+	return c.Send("EVAL", s.args(s.src, keysAndArgs)...)
+}
+
+// Load loads the script without evaluating it.
+func (s *Script) Load(c Conn) error {
+	_, err := c.Do("SCRIPT", "LOAD", s.src)
+	return err
+}
Index: mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/script_test.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/script_test.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/script_test.go	(revision 4485)
@@ -0,0 +1,100 @@
+// Copyright 2012 Gary Burd
+//
+// Licensed under the Apache License, Version 2.0 (the "License"): you may
+// not use this file except in compliance with the License. You may obtain
+// a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+// License for the specific language governing permissions and limitations
+// under the License.
+
+package redis_test
+
+import (
+	"fmt"
+	"reflect"
+	"testing"
+	"time"
+
+	"github.com/garyburd/redigo/redis"
+)
+
+var (
+	// These variables are declared at package level to remove distracting
+	// details from the examples.
+	c     redis.Conn
+	reply interface{}
+	err   error
+)
+
+func ExampleScript() {
+	// Initialize a package-level variable with a script.
+	var getScript = redis.NewScript(1, `return redis.call('get', KEYS[1])`)
+
+	// In a function, use the script Do method to evaluate the script. The Do
+	// method optimistically uses the EVALSHA command. If the script is not
+	// loaded, then the Do method falls back to the EVAL command.
+	reply, err = getScript.Do(c, "foo")
+}
+
+func TestScript(t *testing.T) {
+	c, err := redis.DialDefaultServer()
+	if err != nil {
+		t.Fatalf("error connection to database, %v", err)
+	}
+	defer c.Close()
+
+	// To test fall back in Do, we make script unique by adding comment with current time.
+	script := fmt.Sprintf("--%d\nreturn {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}", time.Now().UnixNano())
+	s := redis.NewScript(2, script)
+	reply := []interface{}{[]byte("key1"), []byte("key2"), []byte("arg1"), []byte("arg2")}
+
+	v, err := s.Do(c, "key1", "key2", "arg1", "arg2")
+	if err != nil {
+		t.Errorf("s.Do(c, ...) returned %v", err)
+	}
+
+	if !reflect.DeepEqual(v, reply) {
+		t.Errorf("s.Do(c, ..); = %v, want %v", v, reply)
+	}
+
+	err = s.Load(c)
+	if err != nil {
+		t.Errorf("s.Load(c) returned %v", err)
+	}
+
+	err = s.SendHash(c, "key1", "key2", "arg1", "arg2")
+	if err != nil {
+		t.Errorf("s.SendHash(c, ...) returned %v", err)
+	}
+
+	err = c.Flush()
+	if err != nil {
+		t.Errorf("c.Flush() returned %v", err)
+	}
+
+	v, err = c.Receive()
+	if !reflect.DeepEqual(v, reply) {
+		t.Errorf("s.SendHash(c, ..); c.Receive() = %v, want %v", v, reply)
+	}
+
+	err = s.Send(c, "key1", "key2", "arg1", "arg2")
+	if err != nil {
+		t.Errorf("s.Send(c, ...) returned %v", err)
+	}
+
+	err = c.Flush()
+	if err != nil {
+		t.Errorf("c.Flush() returned %v", err)
+	}
+
+	v, err = c.Receive()
+	if !reflect.DeepEqual(v, reply) {
+		t.Errorf("s.Send(c, ..); c.Receive() = %v, want %v", v, reply)
+	}
+
+}
Index: mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/test_test.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/test_test.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/test_test.go	(revision 4485)
@@ -0,0 +1,183 @@
+// Copyright 2012 Gary Burd
+//
+// Licensed under the Apache License, Version 2.0 (the "License"): you may
+// not use this file except in compliance with the License. You may obtain
+// a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+// License for the specific language governing permissions and limitations
+// under the License.
+
+package redis
+
+import (
+	"bufio"
+	"errors"
+	"flag"
+	"fmt"
+	"io"
+	"io/ioutil"
+	"os"
+	"os/exec"
+	"strconv"
+	"strings"
+	"sync"
+	"testing"
+	"time"
+)
+
+func SetNowFunc(f func() time.Time) {
+	nowFunc = f
+}
+
+var (
+	ErrNegativeInt = errNegativeInt
+
+	serverPath     = flag.String("redis-server", "redis-server", "Path to redis server binary")
+	serverAddress  = flag.String("redis-address", "127.0.0.1", "The address of the server")
+	serverBasePort = flag.Int("redis-port", 16379, "Beginning of port range for test servers")
+	serverLogName  = flag.String("redis-log", "", "Write Redis server logs to `filename`")
+	serverLog      = ioutil.Discard
+
+	defaultServerMu  sync.Mutex
+	defaultServer    *Server
+	defaultServerErr error
+)
+
+type Server struct {
+	name string
+	cmd  *exec.Cmd
+	done chan struct{}
+}
+
+func NewServer(name string, args ...string) (*Server, error) {
+	s := &Server{
+		name: name,
+		cmd:  exec.Command(*serverPath, args...),
+		done: make(chan struct{}),
+	}
+
+	r, err := s.cmd.StdoutPipe()
+	if err != nil {
+		return nil, err
+	}
+
+	err = s.cmd.Start()
+	if err != nil {
+		return nil, err
+	}
+
+	ready := make(chan error, 1)
+	go s.watch(r, ready)
+
+	select {
+	case err = <-ready:
+	case <-time.After(time.Second * 10):
+		err = errors.New("timeout waiting for server to start")
+	}
+
+	if err != nil {
+		s.Stop()
+		return nil, err
+	}
+
+	return s, nil
+}
+
+func (s *Server) watch(r io.Reader, ready chan error) {
+	fmt.Fprintf(serverLog, "%d START %s \n", s.cmd.Process.Pid, s.name)
+	var listening bool
+	var text string
+	scn := bufio.NewScanner(r)
+	for scn.Scan() {
+		text = scn.Text()
+		fmt.Fprintf(serverLog, "%s\n", text)
+		if !listening {
+			if strings.Contains(text, " * Ready to accept connections") ||
+				strings.Contains(text, " * The server is now ready to accept connections on port") {
+				listening = true
+				ready <- nil
+			}
+		}
+	}
+	if !listening {
+		ready <- fmt.Errorf("server exited: %s", text)
+	}
+	s.cmd.Wait()
+	fmt.Fprintf(serverLog, "%d STOP %s \n", s.cmd.Process.Pid, s.name)
+	close(s.done)
+}
+
+func (s *Server) Stop() {
+	s.cmd.Process.Signal(os.Interrupt)
+	<-s.done
+}
+
+// stopDefaultServer stops the server created by DialDefaultServer.
+func stopDefaultServer() {
+	defaultServerMu.Lock()
+	defer defaultServerMu.Unlock()
+	if defaultServer != nil {
+		defaultServer.Stop()
+		defaultServer = nil
+	}
+}
+
+// DefaultServerAddr starts the test server if not already started and returns
+// the address of that server.
+func DefaultServerAddr() (string, error) {
+	defaultServerMu.Lock()
+	defer defaultServerMu.Unlock()
+	addr := fmt.Sprintf("%v:%d", *serverAddress, *serverBasePort)
+	if defaultServer != nil || defaultServerErr != nil {
+		return addr, defaultServerErr
+	}
+	defaultServer, defaultServerErr = NewServer(
+		"default",
+		"--port", strconv.Itoa(*serverBasePort),
+		"--bind", *serverAddress,
+		"--save", "",
+		"--appendonly", "no")
+	return addr, defaultServerErr
+}
+
+// DialDefaultServer starts the test server if not already started and dials a
+// connection to the server.
+func DialDefaultServer() (Conn, error) {
+	addr, err := DefaultServerAddr()
+	if err != nil {
+		return nil, err
+	}
+	c, err := Dial("tcp", addr, DialReadTimeout(1*time.Second), DialWriteTimeout(1*time.Second))
+	if err != nil {
+		return nil, err
+	}
+	c.Do("FLUSHDB")
+	return c, nil
+}
+
+func TestMain(m *testing.M) {
+	os.Exit(func() int {
+		flag.Parse()
+
+		var f *os.File
+		if *serverLogName != "" {
+			var err error
+			f, err = os.OpenFile(*serverLogName, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0600)
+			if err != nil {
+				fmt.Fprintf(os.Stderr, "Error opening redis-log: %v\n", err)
+				return 1
+			}
+			defer f.Close()
+			serverLog = f
+		}
+
+		defer stopDefaultServer()
+
+		return m.Run()
+	}())
+}
Index: mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/zpop_example_test.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/zpop_example_test.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redis/zpop_example_test.go	(revision 4485)
@@ -0,0 +1,114 @@
+// Copyright 2013 Gary Burd
+//
+// Licensed under the Apache License, Version 2.0 (the "License"): you may
+// not use this file except in compliance with the License. You may obtain
+// a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+// License for the specific language governing permissions and limitations
+// under the License.
+
+package redis_test
+
+import (
+	"fmt"
+
+	"github.com/garyburd/redigo/redis"
+)
+
+// zpop pops a value from the ZSET key using WATCH/MULTI/EXEC commands.
+func zpop(c redis.Conn, key string) (result string, err error) {
+
+	defer func() {
+		// Return connection to normal state on error.
+		if err != nil {
+			c.Do("DISCARD")
+		}
+	}()
+
+	// Loop until transaction is successful.
+	for {
+		if _, err := c.Do("WATCH", key); err != nil {
+			return "", err
+		}
+
+		members, err := redis.Strings(c.Do("ZRANGE", key, 0, 0))
+		if err != nil {
+			return "", err
+		}
+		if len(members) != 1 {
+			return "", redis.ErrNil
+		}
+
+		c.Send("MULTI")
+		c.Send("ZREM", key, members[0])
+		queued, err := c.Do("EXEC")
+		if err != nil {
+			return "", err
+		}
+
+		if queued != nil {
+			result = members[0]
+			break
+		}
+	}
+
+	return result, nil
+}
+
+// zpopScript pops a value from a ZSET.
+var zpopScript = redis.NewScript(1, `
+    local r = redis.call('ZRANGE', KEYS[1], 0, 0)
+    if r ~= nil then
+        r = r[1]
+        redis.call('ZREM', KEYS[1], r)
+    end
+    return r
+`)
+
+// This example implements ZPOP as described at
+// http://redis.io/topics/transactions using WATCH/MULTI/EXEC and scripting.
+func Example_zpop() {
+	c, err := dial()
+	if err != nil {
+		fmt.Println(err)
+		return
+	}
+	defer c.Close()
+
+	// Add test data using a pipeline.
+
+	for i, member := range []string{"red", "blue", "green"} {
+		c.Send("ZADD", "zset", i, member)
+	}
+	if _, err := c.Do(""); err != nil {
+		fmt.Println(err)
+		return
+	}
+
+	// Pop using WATCH/MULTI/EXEC
+
+	v, err := zpop(c, "zset")
+	if err != nil {
+		fmt.Println(err)
+		return
+	}
+	fmt.Println(v)
+
+	// Pop using a script.
+
+	v, err = redis.String(zpopScript.Do(c, "zset"))
+	if err != nil {
+		fmt.Println(err)
+		return
+	}
+	fmt.Println(v)
+
+	// Output:
+	// red
+	// blue
+}
Index: mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redisx/connmux.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redisx/connmux.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redisx/connmux.go	(revision 4485)
@@ -0,0 +1,152 @@
+// Copyright 2014 Gary Burd
+//
+// Licensed under the Apache License, Version 2.0 (the "License"): you may
+// not use this file except in compliance with the License. You may obtain
+// a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+// License for the specific language governing permissions and limitations
+// under the License.
+
+package redisx
+
+import (
+	"errors"
+	"sync"
+
+	"github.com/garyburd/redigo/internal"
+	"github.com/garyburd/redigo/redis"
+)
+
+// ConnMux multiplexes one or more connections to a single underlying
+// connection. The ConnMux connections do not support concurrency, commands
+// that associate server side state with the connection or commands that put
+// the connection in a special mode.
+type ConnMux struct {
+	c redis.Conn
+
+	sendMu sync.Mutex
+	sendID uint
+
+	recvMu   sync.Mutex
+	recvID   uint
+	recvWait map[uint]chan struct{}
+}
+
+func NewConnMux(c redis.Conn) *ConnMux {
+	return &ConnMux{c: c, recvWait: make(map[uint]chan struct{})}
+}
+
+// Get gets a connection. The application must close the returned connection.
+func (p *ConnMux) Get() redis.Conn {
+	c := &muxConn{p: p}
+	c.ids = c.buf[:0]
+	return c
+}
+
+// Close closes the underlying connection.
+func (p *ConnMux) Close() error {
+	return p.c.Close()
+}
+
+type muxConn struct {
+	p   *ConnMux
+	ids []uint
+	buf [8]uint
+}
+
+func (c *muxConn) send(flush bool, cmd string, args ...interface{}) error {
+	if internal.LookupCommandInfo(cmd).Set != 0 {
+		return errors.New("command not supported by mux pool")
+	}
+	p := c.p
+	p.sendMu.Lock()
+	id := p.sendID
+	c.ids = append(c.ids, id)
+	p.sendID++
+	err := p.c.Send(cmd, args...)
+	if flush {
+		err = p.c.Flush()
+	}
+	p.sendMu.Unlock()
+	return err
+}
+
+func (c *muxConn) Send(cmd string, args ...interface{}) error {
+	return c.send(false, cmd, args...)
+}
+
+func (c *muxConn) Flush() error {
+	p := c.p
+	p.sendMu.Lock()
+	err := p.c.Flush()
+	p.sendMu.Unlock()
+	return err
+}
+
+func (c *muxConn) Receive() (interface{}, error) {
+	if len(c.ids) == 0 {
+		return nil, errors.New("mux pool underflow")
+	}
+
+	id := c.ids[0]
+	c.ids = c.ids[1:]
+	if len(c.ids) == 0 {
+		c.ids = c.buf[:0]
+	}
+
+	p := c.p
+	p.recvMu.Lock()
+	if p.recvID != id {
+		ch := make(chan struct{})
+		p.recvWait[id] = ch
+		p.recvMu.Unlock()
+		<-ch
+		p.recvMu.Lock()
+		if p.recvID != id {
+			panic("out of sync")
+		}
+	}
+
+	v, err := p.c.Receive()
+
+	id++
+	p.recvID = id
+	ch, ok := p.recvWait[id]
+	if ok {
+		delete(p.recvWait, id)
+	}
+	p.recvMu.Unlock()
+	if ok {
+		ch <- struct{}{}
+	}
+
+	return v, err
+}
+
+func (c *muxConn) Close() error {
+	var err error
+	if len(c.ids) == 0 {
+		return nil
+	}
+	c.Flush()
+	for _ = range c.ids {
+		_, err = c.Receive()
+	}
+	return err
+}
+
+func (c *muxConn) Do(cmd string, args ...interface{}) (interface{}, error) {
+	if err := c.send(true, cmd, args...); err != nil {
+		return nil, err
+	}
+	return c.Receive()
+}
+
+func (c *muxConn) Err() error {
+	return c.p.c.Err()
+}
Index: mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redisx/connmux_test.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redisx/connmux_test.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redisx/connmux_test.go	(revision 4485)
@@ -0,0 +1,259 @@
+// Copyright 2014 Gary Burd
+//
+// Licensed under the Apache License, Version 2.0 (the "License"): you may
+// not use this file except in compliance with the License. You may obtain
+// a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+// License for the specific language governing permissions and limitations
+// under the License.
+
+package redisx_test
+
+import (
+	"net/textproto"
+	"sync"
+	"testing"
+
+	"github.com/garyburd/redigo/internal/redistest"
+	"github.com/garyburd/redigo/redis"
+	"github.com/garyburd/redigo/redisx"
+)
+
+func TestConnMux(t *testing.T) {
+	c, err := redistest.Dial()
+	if err != nil {
+		t.Fatalf("error connection to database, %v", err)
+	}
+	m := redisx.NewConnMux(c)
+	defer m.Close()
+
+	c1 := m.Get()
+	c2 := m.Get()
+	c1.Send("ECHO", "hello")
+	c2.Send("ECHO", "world")
+	c1.Flush()
+	c2.Flush()
+	s, err := redis.String(c1.Receive())
+	if err != nil {
+		t.Fatal(err)
+	}
+	if s != "hello" {
+		t.Fatalf("echo returned %q, want %q", s, "hello")
+	}
+	s, err = redis.String(c2.Receive())
+	if err != nil {
+		t.Fatal(err)
+	}
+	if s != "world" {
+		t.Fatalf("echo returned %q, want %q", s, "world")
+	}
+	c1.Close()
+	c2.Close()
+}
+
+func TestConnMuxClose(t *testing.T) {
+	c, err := redistest.Dial()
+	if err != nil {
+		t.Fatalf("error connection to database, %v", err)
+	}
+	m := redisx.NewConnMux(c)
+	defer m.Close()
+
+	c1 := m.Get()
+	c2 := m.Get()
+
+	if err := c1.Send("ECHO", "hello"); err != nil {
+		t.Fatal(err)
+	}
+	if err := c1.Close(); err != nil {
+		t.Fatal(err)
+	}
+
+	if err := c2.Send("ECHO", "world"); err != nil {
+		t.Fatal(err)
+	}
+	if err := c2.Flush(); err != nil {
+		t.Fatal(err)
+	}
+
+	s, err := redis.String(c2.Receive())
+	if err != nil {
+		t.Fatal(err)
+	}
+	if s != "world" {
+		t.Fatalf("echo returned %q, want %q", s, "world")
+	}
+	c2.Close()
+}
+
+func BenchmarkConn(b *testing.B) {
+	b.StopTimer()
+	c, err := redistest.Dial()
+	if err != nil {
+		b.Fatalf("error connection to database, %v", err)
+	}
+	defer c.Close()
+	b.StartTimer()
+
+	for i := 0; i < b.N; i++ {
+		if _, err := c.Do("PING"); err != nil {
+			b.Fatal(err)
+		}
+	}
+}
+
+func BenchmarkConnMux(b *testing.B) {
+	b.StopTimer()
+	c, err := redistest.Dial()
+	if err != nil {
+		b.Fatalf("error connection to database, %v", err)
+	}
+	m := redisx.NewConnMux(c)
+	defer m.Close()
+
+	b.StartTimer()
+
+	for i := 0; i < b.N; i++ {
+		c := m.Get()
+		if _, err := c.Do("PING"); err != nil {
+			b.Fatal(err)
+		}
+		c.Close()
+	}
+}
+
+func BenchmarkPool(b *testing.B) {
+	b.StopTimer()
+
+	p := redis.Pool{Dial: redistest.Dial, MaxIdle: 1}
+	defer p.Close()
+
+	// Fill the pool.
+	c := p.Get()
+	if err := c.Err(); err != nil {
+		b.Fatal(err)
+	}
+	c.Close()
+
+	b.StartTimer()
+
+	for i := 0; i < b.N; i++ {
+		c := p.Get()
+		if _, err := c.Do("PING"); err != nil {
+			b.Fatal(err)
+		}
+		c.Close()
+	}
+}
+
+const numConcurrent = 10
+
+func BenchmarkConnMuxConcurrent(b *testing.B) {
+	b.StopTimer()
+	c, err := redistest.Dial()
+	if err != nil {
+		b.Fatalf("error connection to database, %v", err)
+	}
+	defer c.Close()
+
+	m := redisx.NewConnMux(c)
+
+	var wg sync.WaitGroup
+	wg.Add(numConcurrent)
+
+	b.StartTimer()
+
+	for i := 0; i < numConcurrent; i++ {
+		go func() {
+			defer wg.Done()
+			for i := 0; i < b.N; i++ {
+				c := m.Get()
+				if _, err := c.Do("PING"); err != nil {
+					b.Fatal(err)
+				}
+				c.Close()
+			}
+		}()
+	}
+	wg.Wait()
+}
+
+func BenchmarkPoolConcurrent(b *testing.B) {
+	b.StopTimer()
+
+	p := redis.Pool{Dial: redistest.Dial, MaxIdle: numConcurrent}
+	defer p.Close()
+
+	// Fill the pool.
+	conns := make([]redis.Conn, numConcurrent)
+	for i := range conns {
+		c := p.Get()
+		if err := c.Err(); err != nil {
+			b.Fatal(err)
+		}
+		conns[i] = c
+	}
+	for _, c := range conns {
+		c.Close()
+	}
+
+	var wg sync.WaitGroup
+	wg.Add(numConcurrent)
+
+	b.StartTimer()
+
+	for i := 0; i < numConcurrent; i++ {
+		go func() {
+			defer wg.Done()
+			for i := 0; i < b.N; i++ {
+				c := p.Get()
+				if _, err := c.Do("PING"); err != nil {
+					b.Fatal(err)
+				}
+				c.Close()
+			}
+		}()
+	}
+	wg.Wait()
+}
+
+func BenchmarkPipelineConcurrency(b *testing.B) {
+	b.StopTimer()
+	c, err := redistest.Dial()
+	if err != nil {
+		b.Fatalf("error connection to database, %v", err)
+	}
+	defer c.Close()
+
+	var wg sync.WaitGroup
+	wg.Add(numConcurrent)
+
+	var pipeline textproto.Pipeline
+
+	b.StartTimer()
+
+	for i := 0; i < numConcurrent; i++ {
+		go func() {
+			defer wg.Done()
+			for i := 0; i < b.N; i++ {
+				id := pipeline.Next()
+				pipeline.StartRequest(id)
+				c.Send("PING")
+				c.Flush()
+				pipeline.EndRequest(id)
+				pipeline.StartResponse(id)
+				_, err := c.Receive()
+				if err != nil {
+					b.Fatal(err)
+				}
+				pipeline.EndResponse(id)
+			}
+		}()
+	}
+	wg.Wait()
+}
Index: mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redisx/doc.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redisx/doc.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/garyburd/redigo/redisx/doc.go	(revision 4485)
@@ -0,0 +1,17 @@
+// Copyright 2012 Gary Burd
+//
+// Licensed under the Apache License, Version 2.0 (the "License"): you may
+// not use this file except in compliance with the License. You may obtain
+// a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+// License for the specific language governing permissions and limitations
+// under the License.
+
+// Package redisx contains experimental features for Redigo. Features in this
+// package may be modified or deleted at any time.
+package redisx // import "github.com/garyburd/redigo/redisx"
Index: mattermost-server-7.8.1/vendor/github.com/robfig/cron/.gitignore
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/robfig/cron/.gitignore	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/robfig/cron/.gitignore	(revision 4485)
@@ -0,0 +1,22 @@
+# Compiled Object files, Static and Dynamic libs (Shared Objects)
+*.o
+*.a
+*.so
+
+# Folders
+_obj
+_test
+
+# Architecture specific extensions/prefixes
+*.[568vq]
+[568vq].out
+
+*.cgo1.go
+*.cgo2.c
+_cgo_defun.c
+_cgo_gotypes.go
+_cgo_export.*
+
+_testmain.go
+
+*.exe
Index: mattermost-server-7.8.1/vendor/github.com/robfig/cron/.travis.yml
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/robfig/cron/.travis.yml	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/robfig/cron/.travis.yml	(revision 4485)
@@ -0,0 +1 @@
+language: go
Index: mattermost-server-7.8.1/vendor/github.com/robfig/cron/LICENSE
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/robfig/cron/LICENSE	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/robfig/cron/LICENSE	(revision 4485)
@@ -0,0 +1,21 @@
+Copyright (C) 2012 Rob Figueiredo
+All Rights Reserved.
+
+MIT LICENSE
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of
+this software and associated documentation files (the "Software"), to deal in
+the Software without restriction, including without limitation the rights to
+use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+the Software, and to permit persons to whom the Software is furnished to do so,
+subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
Index: mattermost-server-7.8.1/vendor/github.com/robfig/cron/README.md
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/robfig/cron/README.md	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/robfig/cron/README.md	(revision 4485)
@@ -0,0 +1,125 @@
+[![GoDoc](http://godoc.org/github.com/robfig/cron?status.png)](http://godoc.org/github.com/robfig/cron)
+[![Build Status](https://travis-ci.org/robfig/cron.svg?branch=master)](https://travis-ci.org/robfig/cron)
+
+# cron
+
+Cron V3 has been released!
+
+To download the specific tagged release, run:
+
+	go get github.com/robfig/cron/v3@v3.0.0
+
+Import it in your program as:
+
+	import "github.com/robfig/cron/v3"
+
+It requires Go 1.11 or later due to usage of Go Modules.
+
+Refer to the documentation here:
+http://godoc.org/github.com/robfig/cron
+
+The rest of this document describes the the advances in v3 and a list of
+breaking changes for users that wish to upgrade from an earlier version.
+
+## Upgrading to v3 (June 2019)
+
+cron v3 is a major upgrade to the library that addresses all outstanding bugs,
+feature requests, and rough edges. It is based on a merge of master which
+contains various fixes to issues found over the years and the v2 branch which
+contains some backwards-incompatible features like the ability to remove cron
+jobs. In addition, v3 adds support for Go Modules, cleans up rough edges like
+the timezone support, and fixes a number of bugs.
+
+New features:
+
+- Support for Go modules. Callers must now import this library as
+  `github.com/robfig/cron/v3`, instead of `gopkg.in/...`
+
+- Fixed bugs:
+  - 0f01e6b parser: fix combining of Dow and Dom (#70)
+  - dbf3220 adjust times when rolling the clock forward to handle non-existent midnight (#157)
+  - eeecf15 spec_test.go: ensure an error is returned on 0 increment (#144)
+  - 70971dc cron.Entries(): update request for snapshot to include a reply channel (#97)
+  - 1cba5e6 cron: fix: removing a job causes the next scheduled job to run too late (#206)
+
+- Standard cron spec parsing by default (first field is "minute"), with an easy
+  way to opt into the seconds field (quartz-compatible). Although, note that the
+  year field (optional in Quartz) is not supported.
+
+- Extensible, key/value logging via an interface that complies with
+  the https://github.com/go-logr/logr project.
+
+- The new Chain & JobWrapper types allow you to install "interceptors" to add
+  cross-cutting behavior like the following:
+  - Recover any panics from jobs
+  - Delay a job's execution if the previous run hasn't completed yet
+  - Skip a job's execution if the previous run hasn't completed yet
+  - Log each job's invocations
+  - Notification when jobs are completed
+
+It is backwards incompatible with both v1 and v2. These updates are required:
+
+- The v1 branch accepted an optional seconds field at the beginning of the cron
+  spec. This is non-standard and has led to a lot of confusion. The new default
+  parser conforms to the standard as described by [the Cron wikipedia page].
+
+  UPDATING: To retain the old behavior, construct your Cron with a custom
+  parser:
+
+      // Seconds field, required
+      cron.New(cron.WithSeconds())
+
+      // Seconds field, optional
+      cron.New(
+          cron.WithParser(
+              cron.SecondOptional | cron.Minute | cron.Hour | cron.Dom | cron.Month | cron.Dow | cron.Descriptor))
+
+- The Cron type now accepts functional options on construction rather than the
+  previous ad-hoc behavior modification mechanisms (setting a field, calling a setter).
+
+  UPDATING: Code that sets Cron.ErrorLogger or calls Cron.SetLocation must be
+  updated to provide those values on construction.
+
+- CRON_TZ is now the recommended way to specify the timezone of a single
+  schedule, which is sanctioned by the specification. The legacy "TZ=" prefix
+  will continue to be supported since it is unambiguous and easy to do so.
+
+  UPDATING: No update is required.
+
+- By default, cron will no longer recover panics in jobs that it runs.
+  Recovering can be surprising (see issue #192) and seems to be at odds with
+  typical behavior of libraries. Relatedly, the `cron.WithPanicLogger` option
+  has been removed to accommodate the more general JobWrapper type.
+
+  UPDATING: To opt into panic recovery and configure the panic logger:
+
+      cron.New(cron.WithChain(
+          cron.Recover(logger),  // or use cron.DefaultLogger
+      ))
+
+- In adding support for https://github.com/go-logr/logr, `cron.WithVerboseLogger` was
+  removed, since it is duplicative with the leveled logging.
+
+  UPDATING: Callers should use `WithLogger` and specify a logger that does not
+  discard `Info` logs. For convenience, one is provided that wraps `*log.Logger`:
+
+      cron.New(
+          cron.WithLogger(cron.VerbosePrintfLogger(logger)))
+
+
+### Background - Cron spec format
+
+There are two cron spec formats in common usage:
+
+- The "standard" cron format, described on [the Cron wikipedia page] and used by
+  the cron Linux system utility.
+
+- The cron format used by [the Quartz Scheduler], commonly used for scheduled
+  jobs in Java software
+
+[the Cron wikipedia page]: https://en.wikipedia.org/wiki/Cron
+[the Quartz Scheduler]: http://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/tutorial-lesson-06.html
+
+The original version of this package included an optional "seconds" field, which
+made it incompatible with both of these formats. Now, the "standard" format is
+the default format accepted, and the Quartz format is opt-in.
Index: mattermost-server-7.8.1/vendor/github.com/robfig/cron/chain.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/robfig/cron/chain.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/robfig/cron/chain.go	(revision 4485)
@@ -0,0 +1,92 @@
+package cron
+
+import (
+	"fmt"
+	"runtime"
+	"sync"
+	"time"
+)
+
+// JobWrapper decorates the given Job with some behavior.
+type JobWrapper func(Job) Job
+
+// Chain is a sequence of JobWrappers that decorates submitted jobs with
+// cross-cutting behaviors like logging or synchronization.
+type Chain struct {
+	wrappers []JobWrapper
+}
+
+// NewChain returns a Chain consisting of the given JobWrappers.
+func NewChain(c ...JobWrapper) Chain {
+	return Chain{c}
+}
+
+// Then decorates the given job with all JobWrappers in the chain.
+//
+// This:
+//     NewChain(m1, m2, m3).Then(job)
+// is equivalent to:
+//     m1(m2(m3(job)))
+func (c Chain) Then(j Job) Job {
+	for i := range c.wrappers {
+		j = c.wrappers[len(c.wrappers)-i-1](j)
+	}
+	return j
+}
+
+// Recover panics in wrapped jobs and log them with the provided logger.
+func Recover(logger Logger) JobWrapper {
+	return func(j Job) Job {
+		return FuncJob(func() {
+			defer func() {
+				if r := recover(); r != nil {
+					const size = 64 << 10
+					buf := make([]byte, size)
+					buf = buf[:runtime.Stack(buf, false)]
+					err, ok := r.(error)
+					if !ok {
+						err = fmt.Errorf("%v", r)
+					}
+					logger.Error(err, "panic", "stack", "...\n"+string(buf))
+				}
+			}()
+			j.Run()
+		})
+	}
+}
+
+// DelayIfStillRunning serializes jobs, delaying subsequent runs until the
+// previous one is complete. Jobs running after a delay of more than a minute
+// have the delay logged at Info.
+func DelayIfStillRunning(logger Logger) JobWrapper {
+	return func(j Job) Job {
+		var mu sync.Mutex
+		return FuncJob(func() {
+			start := time.Now()
+			mu.Lock()
+			defer mu.Unlock()
+			if dur := time.Since(start); dur > time.Minute {
+				logger.Info("delay", "duration", dur)
+			}
+			j.Run()
+		})
+	}
+}
+
+// SkipIfStillRunning skips an invocation of the Job if a previous invocation is
+// still running. It logs skips to the given logger at Info level.
+func SkipIfStillRunning(logger Logger) JobWrapper {
+	return func(j Job) Job {
+		var ch = make(chan struct{}, 1)
+		ch <- struct{}{}
+		return FuncJob(func() {
+			select {
+			case v := <-ch:
+				j.Run()
+				ch <- v
+			default:
+				logger.Info("skip")
+			}
+		})
+	}
+}
Index: mattermost-server-7.8.1/vendor/github.com/robfig/cron/chain_test.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/robfig/cron/chain_test.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/robfig/cron/chain_test.go	(revision 4485)
@@ -0,0 +1,242 @@
+package cron
+
+import (
+	"io/ioutil"
+	"log"
+	"reflect"
+	"sync"
+	"testing"
+	"time"
+)
+
+func appendingJob(slice *[]int, value int) Job {
+	var m sync.Mutex
+	return FuncJob(func() {
+		m.Lock()
+		*slice = append(*slice, value)
+		m.Unlock()
+	})
+}
+
+func appendingWrapper(slice *[]int, value int) JobWrapper {
+	return func(j Job) Job {
+		return FuncJob(func() {
+			appendingJob(slice, value).Run()
+			j.Run()
+		})
+	}
+}
+
+func TestChain(t *testing.T) {
+	var nums []int
+	var (
+		append1 = appendingWrapper(&nums, 1)
+		append2 = appendingWrapper(&nums, 2)
+		append3 = appendingWrapper(&nums, 3)
+		append4 = appendingJob(&nums, 4)
+	)
+	NewChain(append1, append2, append3).Then(append4).Run()
+	if !reflect.DeepEqual(nums, []int{1, 2, 3, 4}) {
+		t.Error("unexpected order of calls:", nums)
+	}
+}
+
+func TestChainRecover(t *testing.T) {
+	panickingJob := FuncJob(func() {
+		panic("panickingJob panics")
+	})
+
+	t.Run("panic exits job by default", func(t *testing.T) {
+		defer func() {
+			if err := recover(); err == nil {
+				t.Errorf("panic expected, but none received")
+			}
+		}()
+		NewChain().Then(panickingJob).
+			Run()
+	})
+
+	t.Run("Recovering JobWrapper recovers", func(t *testing.T) {
+		NewChain(Recover(PrintfLogger(log.New(ioutil.Discard, "", 0)))).
+			Then(panickingJob).
+			Run()
+	})
+
+	t.Run("composed with the *IfStillRunning wrappers", func(t *testing.T) {
+		NewChain(Recover(PrintfLogger(log.New(ioutil.Discard, "", 0)))).
+			Then(panickingJob).
+			Run()
+	})
+}
+
+type countJob struct {
+	m       sync.Mutex
+	started int
+	done    int
+	delay   time.Duration
+}
+
+func (j *countJob) Run() {
+	j.m.Lock()
+	j.started++
+	j.m.Unlock()
+	time.Sleep(j.delay)
+	j.m.Lock()
+	j.done++
+	j.m.Unlock()
+}
+
+func (j *countJob) Started() int {
+	defer j.m.Unlock()
+	j.m.Lock()
+	return j.started
+}
+
+func (j *countJob) Done() int {
+	defer j.m.Unlock()
+	j.m.Lock()
+	return j.done
+}
+
+func TestChainDelayIfStillRunning(t *testing.T) {
+
+	t.Run("runs immediately", func(t *testing.T) {
+		var j countJob
+		wrappedJob := NewChain(DelayIfStillRunning(DiscardLogger)).Then(&j)
+		go wrappedJob.Run()
+		time.Sleep(2 * time.Millisecond) // Give the job 2ms to complete.
+		if c := j.Done(); c != 1 {
+			t.Errorf("expected job run once, immediately, got %d", c)
+		}
+	})
+
+	t.Run("second run immediate if first done", func(t *testing.T) {
+		var j countJob
+		wrappedJob := NewChain(DelayIfStillRunning(DiscardLogger)).Then(&j)
+		go func() {
+			go wrappedJob.Run()
+			time.Sleep(time.Millisecond)
+			go wrappedJob.Run()
+		}()
+		time.Sleep(3 * time.Millisecond) // Give both jobs 3ms to complete.
+		if c := j.Done(); c != 2 {
+			t.Errorf("expected job run twice, immediately, got %d", c)
+		}
+	})
+
+	t.Run("second run delayed if first not done", func(t *testing.T) {
+		var j countJob
+		j.delay = 10 * time.Millisecond
+		wrappedJob := NewChain(DelayIfStillRunning(DiscardLogger)).Then(&j)
+		go func() {
+			go wrappedJob.Run()
+			time.Sleep(time.Millisecond)
+			go wrappedJob.Run()
+		}()
+
+		// After 5ms, the first job is still in progress, and the second job was
+		// run but should be waiting for it to finish.
+		time.Sleep(5 * time.Millisecond)
+		started, done := j.Started(), j.Done()
+		if started != 1 || done != 0 {
+			t.Error("expected first job started, but not finished, got", started, done)
+		}
+
+		// Verify that the second job completes.
+		time.Sleep(25 * time.Millisecond)
+		started, done = j.Started(), j.Done()
+		if started != 2 || done != 2 {
+			t.Error("expected both jobs done, got", started, done)
+		}
+	})
+
+}
+
+func TestChainSkipIfStillRunning(t *testing.T) {
+
+	t.Run("runs immediately", func(t *testing.T) {
+		var j countJob
+		wrappedJob := NewChain(SkipIfStillRunning(DiscardLogger)).Then(&j)
+		go wrappedJob.Run()
+		time.Sleep(2 * time.Millisecond) // Give the job 2ms to complete.
+		if c := j.Done(); c != 1 {
+			t.Errorf("expected job run once, immediately, got %d", c)
+		}
+	})
+
+	t.Run("second run immediate if first done", func(t *testing.T) {
+		var j countJob
+		wrappedJob := NewChain(SkipIfStillRunning(DiscardLogger)).Then(&j)
+		go func() {
+			go wrappedJob.Run()
+			time.Sleep(time.Millisecond)
+			go wrappedJob.Run()
+		}()
+		time.Sleep(3 * time.Millisecond) // Give both jobs 3ms to complete.
+		if c := j.Done(); c != 2 {
+			t.Errorf("expected job run twice, immediately, got %d", c)
+		}
+	})
+
+	t.Run("second run skipped if first not done", func(t *testing.T) {
+		var j countJob
+		j.delay = 10 * time.Millisecond
+		wrappedJob := NewChain(SkipIfStillRunning(DiscardLogger)).Then(&j)
+		go func() {
+			go wrappedJob.Run()
+			time.Sleep(time.Millisecond)
+			go wrappedJob.Run()
+		}()
+
+		// After 5ms, the first job is still in progress, and the second job was
+		// aleady skipped.
+		time.Sleep(5 * time.Millisecond)
+		started, done := j.Started(), j.Done()
+		if started != 1 || done != 0 {
+			t.Error("expected first job started, but not finished, got", started, done)
+		}
+
+		// Verify that the first job completes and second does not run.
+		time.Sleep(25 * time.Millisecond)
+		started, done = j.Started(), j.Done()
+		if started != 1 || done != 1 {
+			t.Error("expected second job skipped, got", started, done)
+		}
+	})
+
+	t.Run("skip 10 jobs on rapid fire", func(t *testing.T) {
+		var j countJob
+		j.delay = 10 * time.Millisecond
+		wrappedJob := NewChain(SkipIfStillRunning(DiscardLogger)).Then(&j)
+		for i := 0; i < 11; i++ {
+			go wrappedJob.Run()
+		}
+		time.Sleep(200 * time.Millisecond)
+		done := j.Done()
+		if done != 1 {
+			t.Error("expected 1 jobs executed, 10 jobs dropped, got", done)
+		}
+	})
+
+	t.Run("different jobs independent", func(t *testing.T) {
+		var j1, j2 countJob
+		j1.delay = 10 * time.Millisecond
+		j2.delay = 10 * time.Millisecond
+		chain := NewChain(SkipIfStillRunning(DiscardLogger))
+		wrappedJob1 := chain.Then(&j1)
+		wrappedJob2 := chain.Then(&j2)
+		for i := 0; i < 11; i++ {
+			go wrappedJob1.Run()
+			go wrappedJob2.Run()
+		}
+		time.Sleep(100 * time.Millisecond)
+		var (
+			done1 = j1.Done()
+			done2 = j2.Done()
+		)
+		if done1 != 1 || done2 != 1 {
+			t.Error("expected both jobs executed once, got", done1, "and", done2)
+		}
+	})
+
+}
Index: mattermost-server-7.8.1/vendor/github.com/robfig/cron/constantdelay.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/robfig/cron/constantdelay.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/robfig/cron/constantdelay.go	(revision 4485)
@@ -0,0 +1,27 @@
+package cron
+
+import "time"
+
+// ConstantDelaySchedule represents a simple recurring duty cycle, e.g. "Every 5 minutes".
+// It does not support jobs more frequent than once a second.
+type ConstantDelaySchedule struct {
+	Delay time.Duration
+}
+
+// Every returns a crontab Schedule that activates once every duration.
+// Delays of less than a second are not supported (will round up to 1 second).
+// Any fields less than a Second are truncated.
+func Every(duration time.Duration) ConstantDelaySchedule {
+	if duration < time.Second {
+		duration = time.Second
+	}
+	return ConstantDelaySchedule{
+		Delay: duration - time.Duration(duration.Nanoseconds())%time.Second,
+	}
+}
+
+// Next returns the next time this should be run.
+// This rounds so that the next activation time will be on the second.
+func (schedule ConstantDelaySchedule) Next(t time.Time) time.Time {
+	return t.Add(schedule.Delay - time.Duration(t.Nanosecond())*time.Nanosecond)
+}
Index: mattermost-server-7.8.1/vendor/github.com/robfig/cron/constantdelay_test.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/robfig/cron/constantdelay_test.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/robfig/cron/constantdelay_test.go	(revision 4485)
@@ -0,0 +1,54 @@
+package cron
+
+import (
+	"testing"
+	"time"
+)
+
+func TestConstantDelayNext(t *testing.T) {
+	tests := []struct {
+		time     string
+		delay    time.Duration
+		expected string
+	}{
+		// Simple cases
+		{"Mon Jul 9 14:45 2012", 15*time.Minute + 50*time.Nanosecond, "Mon Jul 9 15:00 2012"},
+		{"Mon Jul 9 14:59 2012", 15 * time.Minute, "Mon Jul 9 15:14 2012"},
+		{"Mon Jul 9 14:59:59 2012", 15 * time.Minute, "Mon Jul 9 15:14:59 2012"},
+
+		// Wrap around hours
+		{"Mon Jul 9 15:45 2012", 35 * time.Minute, "Mon Jul 9 16:20 2012"},
+
+		// Wrap around days
+		{"Mon Jul 9 23:46 2012", 14 * time.Minute, "Tue Jul 10 00:00 2012"},
+		{"Mon Jul 9 23:45 2012", 35 * time.Minute, "Tue Jul 10 00:20 2012"},
+		{"Mon Jul 9 23:35:51 2012", 44*time.Minute + 24*time.Second, "Tue Jul 10 00:20:15 2012"},
+		{"Mon Jul 9 23:35:51 2012", 25*time.Hour + 44*time.Minute + 24*time.Second, "Thu Jul 11 01:20:15 2012"},
+
+		// Wrap around months
+		{"Mon Jul 9 23:35 2012", 91*24*time.Hour + 25*time.Minute, "Thu Oct 9 00:00 2012"},
+
+		// Wrap around minute, hour, day, month, and year
+		{"Mon Dec 31 23:59:45 2012", 15 * time.Second, "Tue Jan 1 00:00:00 2013"},
+
+		// Round to nearest second on the delay
+		{"Mon Jul 9 14:45 2012", 15*time.Minute + 50*time.Nanosecond, "Mon Jul 9 15:00 2012"},
+
+		// Round up to 1 second if the duration is less.
+		{"Mon Jul 9 14:45:00 2012", 15 * time.Millisecond, "Mon Jul 9 14:45:01 2012"},
+
+		// Round to nearest second when calculating the next time.
+		{"Mon Jul 9 14:45:00.005 2012", 15 * time.Minute, "Mon Jul 9 15:00 2012"},
+
+		// Round to nearest second for both.
+		{"Mon Jul 9 14:45:00.005 2012", 15*time.Minute + 50*time.Nanosecond, "Mon Jul 9 15:00 2012"},
+	}
+
+	for _, c := range tests {
+		actual := Every(c.delay).Next(getTime(c.time))
+		expected := getTime(c.expected)
+		if actual != expected {
+			t.Errorf("%s, \"%s\": (expected) %v != %v (actual)", c.time, c.delay, expected, actual)
+		}
+	}
+}
Index: mattermost-server-7.8.1/vendor/github.com/robfig/cron/cron.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/robfig/cron/cron.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/robfig/cron/cron.go	(revision 4485)
@@ -0,0 +1,355 @@
+package cron
+
+import (
+	"context"
+	"sort"
+	"sync"
+	"time"
+)
+
+// Cron keeps track of any number of entries, invoking the associated func as
+// specified by the schedule. It may be started, stopped, and the entries may
+// be inspected while running.
+type Cron struct {
+	entries   []*Entry
+	chain     Chain
+	stop      chan struct{}
+	add       chan *Entry
+	remove    chan EntryID
+	snapshot  chan chan []Entry
+	running   bool
+	logger    Logger
+	runningMu sync.Mutex
+	location  *time.Location
+	parser    ScheduleParser
+	nextID    EntryID
+	jobWaiter sync.WaitGroup
+}
+
+// ScheduleParser is an interface for schedule spec parsers that return a Schedule
+type ScheduleParser interface {
+	Parse(spec string) (Schedule, error)
+}
+
+// Job is an interface for submitted cron jobs.
+type Job interface {
+	Run()
+}
+
+// Schedule describes a job's duty cycle.
+type Schedule interface {
+	// Next returns the next activation time, later than the given time.
+	// Next is invoked initially, and then each time the job is run.
+	Next(time.Time) time.Time
+}
+
+// EntryID identifies an entry within a Cron instance
+type EntryID int
+
+// Entry consists of a schedule and the func to execute on that schedule.
+type Entry struct {
+	// ID is the cron-assigned ID of this entry, which may be used to look up a
+	// snapshot or remove it.
+	ID EntryID
+
+	// Schedule on which this job should be run.
+	Schedule Schedule
+
+	// Next time the job will run, or the zero time if Cron has not been
+	// started or this entry's schedule is unsatisfiable
+	Next time.Time
+
+	// Prev is the last time this job was run, or the zero time if never.
+	Prev time.Time
+
+	// WrappedJob is the thing to run when the Schedule is activated.
+	WrappedJob Job
+
+	// Job is the thing that was submitted to cron.
+	// It is kept around so that user code that needs to get at the job later,
+	// e.g. via Entries() can do so.
+	Job Job
+}
+
+// Valid returns true if this is not the zero entry.
+func (e Entry) Valid() bool { return e.ID != 0 }
+
+// byTime is a wrapper for sorting the entry array by time
+// (with zero time at the end).
+type byTime []*Entry
+
+func (s byTime) Len() int      { return len(s) }
+func (s byTime) Swap(i, j int) { s[i], s[j] = s[j], s[i] }
+func (s byTime) Less(i, j int) bool {
+	// Two zero times should return false.
+	// Otherwise, zero is "greater" than any other time.
+	// (To sort it at the end of the list.)
+	if s[i].Next.IsZero() {
+		return false
+	}
+	if s[j].Next.IsZero() {
+		return true
+	}
+	return s[i].Next.Before(s[j].Next)
+}
+
+// New returns a new Cron job runner, modified by the given options.
+//
+// Available Settings
+//
+//   Time Zone
+//     Description: The time zone in which schedules are interpreted
+//     Default:     time.Local
+//
+//   Parser
+//     Description: Parser converts cron spec strings into cron.Schedules.
+//     Default:     Accepts this spec: https://en.wikipedia.org/wiki/Cron
+//
+//   Chain
+//     Description: Wrap submitted jobs to customize behavior.
+//     Default:     A chain that recovers panics and logs them to stderr.
+//
+// See "cron.With*" to modify the default behavior.
+func New(opts ...Option) *Cron {
+	c := &Cron{
+		entries:   nil,
+		chain:     NewChain(),
+		add:       make(chan *Entry),
+		stop:      make(chan struct{}),
+		snapshot:  make(chan chan []Entry),
+		remove:    make(chan EntryID),
+		running:   false,
+		runningMu: sync.Mutex{},
+		logger:    DefaultLogger,
+		location:  time.Local,
+		parser:    standardParser,
+	}
+	for _, opt := range opts {
+		opt(c)
+	}
+	return c
+}
+
+// FuncJob is a wrapper that turns a func() into a cron.Job
+type FuncJob func()
+
+func (f FuncJob) Run() { f() }
+
+// AddFunc adds a func to the Cron to be run on the given schedule.
+// The spec is parsed using the time zone of this Cron instance as the default.
+// An opaque ID is returned that can be used to later remove it.
+func (c *Cron) AddFunc(spec string, cmd func()) (EntryID, error) {
+	return c.AddJob(spec, FuncJob(cmd))
+}
+
+// AddJob adds a Job to the Cron to be run on the given schedule.
+// The spec is parsed using the time zone of this Cron instance as the default.
+// An opaque ID is returned that can be used to later remove it.
+func (c *Cron) AddJob(spec string, cmd Job) (EntryID, error) {
+	schedule, err := c.parser.Parse(spec)
+	if err != nil {
+		return 0, err
+	}
+	return c.Schedule(schedule, cmd), nil
+}
+
+// Schedule adds a Job to the Cron to be run on the given schedule.
+// The job is wrapped with the configured Chain.
+func (c *Cron) Schedule(schedule Schedule, cmd Job) EntryID {
+	c.runningMu.Lock()
+	defer c.runningMu.Unlock()
+	c.nextID++
+	entry := &Entry{
+		ID:         c.nextID,
+		Schedule:   schedule,
+		WrappedJob: c.chain.Then(cmd),
+		Job:        cmd,
+	}
+	if !c.running {
+		c.entries = append(c.entries, entry)
+	} else {
+		c.add <- entry
+	}
+	return entry.ID
+}
+
+// Entries returns a snapshot of the cron entries.
+func (c *Cron) Entries() []Entry {
+	c.runningMu.Lock()
+	defer c.runningMu.Unlock()
+	if c.running {
+		replyChan := make(chan []Entry, 1)
+		c.snapshot <- replyChan
+		return <-replyChan
+	}
+	return c.entrySnapshot()
+}
+
+// Location gets the time zone location
+func (c *Cron) Location() *time.Location {
+	return c.location
+}
+
+// Entry returns a snapshot of the given entry, or nil if it couldn't be found.
+func (c *Cron) Entry(id EntryID) Entry {
+	for _, entry := range c.Entries() {
+		if id == entry.ID {
+			return entry
+		}
+	}
+	return Entry{}
+}
+
+// Remove an entry from being run in the future.
+func (c *Cron) Remove(id EntryID) {
+	c.runningMu.Lock()
+	defer c.runningMu.Unlock()
+	if c.running {
+		c.remove <- id
+	} else {
+		c.removeEntry(id)
+	}
+}
+
+// Start the cron scheduler in its own goroutine, or no-op if already started.
+func (c *Cron) Start() {
+	c.runningMu.Lock()
+	defer c.runningMu.Unlock()
+	if c.running {
+		return
+	}
+	c.running = true
+	go c.run()
+}
+
+// Run the cron scheduler, or no-op if already running.
+func (c *Cron) Run() {
+	c.runningMu.Lock()
+	if c.running {
+		c.runningMu.Unlock()
+		return
+	}
+	c.running = true
+	c.runningMu.Unlock()
+	c.run()
+}
+
+// run the scheduler.. this is private just due to the need to synchronize
+// access to the 'running' state variable.
+func (c *Cron) run() {
+	c.logger.Info("start")
+
+	// Figure out the next activation times for each entry.
+	now := c.now()
+	for _, entry := range c.entries {
+		entry.Next = entry.Schedule.Next(now)
+		c.logger.Info("schedule", "now", now, "entry", entry.ID, "next", entry.Next)
+	}
+
+	for {
+		// Determine the next entry to run.
+		sort.Sort(byTime(c.entries))
+
+		var timer *time.Timer
+		if len(c.entries) == 0 || c.entries[0].Next.IsZero() {
+			// If there are no entries yet, just sleep - it still handles new entries
+			// and stop requests.
+			timer = time.NewTimer(100000 * time.Hour)
+		} else {
+			timer = time.NewTimer(c.entries[0].Next.Sub(now))
+		}
+
+		for {
+			select {
+			case now = <-timer.C:
+				now = now.In(c.location)
+				c.logger.Info("wake", "now", now)
+
+				// Run every entry whose next time was less than now
+				for _, e := range c.entries {
+					if e.Next.After(now) || e.Next.IsZero() {
+						break
+					}
+					c.startJob(e.WrappedJob)
+					e.Prev = e.Next
+					e.Next = e.Schedule.Next(now)
+					c.logger.Info("run", "now", now, "entry", e.ID, "next", e.Next)
+				}
+
+			case newEntry := <-c.add:
+				timer.Stop()
+				now = c.now()
+				newEntry.Next = newEntry.Schedule.Next(now)
+				c.entries = append(c.entries, newEntry)
+				c.logger.Info("added", "now", now, "entry", newEntry.ID, "next", newEntry.Next)
+
+			case replyChan := <-c.snapshot:
+				replyChan <- c.entrySnapshot()
+				continue
+
+			case <-c.stop:
+				timer.Stop()
+				c.logger.Info("stop")
+				return
+
+			case id := <-c.remove:
+				timer.Stop()
+				now = c.now()
+				c.removeEntry(id)
+				c.logger.Info("removed", "entry", id)
+			}
+
+			break
+		}
+	}
+}
+
+// startJob runs the given job in a new goroutine.
+func (c *Cron) startJob(j Job) {
+	c.jobWaiter.Add(1)
+	go func() {
+		defer c.jobWaiter.Done()
+		j.Run()
+	}()
+}
+
+// now returns current time in c location
+func (c *Cron) now() time.Time {
+	return time.Now().In(c.location)
+}
+
+// Stop stops the cron scheduler if it is running; otherwise it does nothing.
+// A context is returned so the caller can wait for running jobs to complete.
+func (c *Cron) Stop() context.Context {
+	c.runningMu.Lock()
+	defer c.runningMu.Unlock()
+	if c.running {
+		c.stop <- struct{}{}
+		c.running = false
+	}
+	ctx, cancel := context.WithCancel(context.Background())
+	go func() {
+		c.jobWaiter.Wait()
+		cancel()
+	}()
+	return ctx
+}
+
+// entrySnapshot returns a copy of the current cron entry list.
+func (c *Cron) entrySnapshot() []Entry {
+	var entries = make([]Entry, len(c.entries))
+	for i, e := range c.entries {
+		entries[i] = *e
+	}
+	return entries
+}
+
+func (c *Cron) removeEntry(id EntryID) {
+	var entries []*Entry
+	for _, e := range c.entries {
+		if e.ID != id {
+			entries = append(entries, e)
+		}
+	}
+	c.entries = entries
+}
Index: mattermost-server-7.8.1/vendor/github.com/robfig/cron/cron_test.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/robfig/cron/cron_test.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/robfig/cron/cron_test.go	(revision 4485)
@@ -0,0 +1,702 @@
+package cron
+
+import (
+	"bytes"
+	"fmt"
+	"log"
+	"strings"
+	"sync"
+	"sync/atomic"
+	"testing"
+	"time"
+)
+
+// Many tests schedule a job for every second, and then wait at most a second
+// for it to run.  This amount is just slightly larger than 1 second to
+// compensate for a few milliseconds of runtime.
+const OneSecond = 1*time.Second + 50*time.Millisecond
+
+type syncWriter struct {
+	wr bytes.Buffer
+	m  sync.Mutex
+}
+
+func (sw *syncWriter) Write(data []byte) (n int, err error) {
+	sw.m.Lock()
+	n, err = sw.wr.Write(data)
+	sw.m.Unlock()
+	return
+}
+
+func (sw *syncWriter) String() string {
+	sw.m.Lock()
+	defer sw.m.Unlock()
+	return sw.wr.String()
+}
+
+func newBufLogger(sw *syncWriter) Logger {
+	return PrintfLogger(log.New(sw, "", log.LstdFlags))
+}
+
+func TestFuncPanicRecovery(t *testing.T) {
+	var buf syncWriter
+	cron := New(WithParser(secondParser),
+		WithChain(Recover(newBufLogger(&buf))))
+	cron.Start()
+	defer cron.Stop()
+	cron.AddFunc("* * * * * ?", func() {
+		panic("YOLO")
+	})
+
+	select {
+	case <-time.After(OneSecond):
+		if !strings.Contains(buf.String(), "YOLO") {
+			t.Error("expected a panic to be logged, got none")
+		}
+		return
+	}
+}
+
+type DummyJob struct{}
+
+func (d DummyJob) Run() {
+	panic("YOLO")
+}
+
+func TestJobPanicRecovery(t *testing.T) {
+	var job DummyJob
+
+	var buf syncWriter
+	cron := New(WithParser(secondParser),
+		WithChain(Recover(newBufLogger(&buf))))
+	cron.Start()
+	defer cron.Stop()
+	cron.AddJob("* * * * * ?", job)
+
+	select {
+	case <-time.After(OneSecond):
+		if !strings.Contains(buf.String(), "YOLO") {
+			t.Error("expected a panic to be logged, got none")
+		}
+		return
+	}
+}
+
+// Start and stop cron with no entries.
+func TestNoEntries(t *testing.T) {
+	cron := newWithSeconds()
+	cron.Start()
+
+	select {
+	case <-time.After(OneSecond):
+		t.Fatal("expected cron will be stopped immediately")
+	case <-stop(cron):
+	}
+}
+
+// Start, stop, then add an entry. Verify entry doesn't run.
+func TestStopCausesJobsToNotRun(t *testing.T) {
+	wg := &sync.WaitGroup{}
+	wg.Add(1)
+
+	cron := newWithSeconds()
+	cron.Start()
+	cron.Stop()
+	cron.AddFunc("* * * * * ?", func() { wg.Done() })
+
+	select {
+	case <-time.After(OneSecond):
+		// No job ran!
+	case <-wait(wg):
+		t.Fatal("expected stopped cron does not run any job")
+	}
+}
+
+// Add a job, start cron, expect it runs.
+func TestAddBeforeRunning(t *testing.T) {
+	wg := &sync.WaitGroup{}
+	wg.Add(1)
+
+	cron := newWithSeconds()
+	cron.AddFunc("* * * * * ?", func() { wg.Done() })
+	cron.Start()
+	defer cron.Stop()
+
+	// Give cron 2 seconds to run our job (which is always activated).
+	select {
+	case <-time.After(OneSecond):
+		t.Fatal("expected job runs")
+	case <-wait(wg):
+	}
+}
+
+// Start cron, add a job, expect it runs.
+func TestAddWhileRunning(t *testing.T) {
+	wg := &sync.WaitGroup{}
+	wg.Add(1)
+
+	cron := newWithSeconds()
+	cron.Start()
+	defer cron.Stop()
+	cron.AddFunc("* * * * * ?", func() { wg.Done() })
+
+	select {
+	case <-time.After(OneSecond):
+		t.Fatal("expected job runs")
+	case <-wait(wg):
+	}
+}
+
+// Test for #34. Adding a job after calling start results in multiple job invocations
+func TestAddWhileRunningWithDelay(t *testing.T) {
+	cron := newWithSeconds()
+	cron.Start()
+	defer cron.Stop()
+	time.Sleep(5 * time.Second)
+	var calls int64
+	cron.AddFunc("* * * * * *", func() { atomic.AddInt64(&calls, 1) })
+
+	<-time.After(OneSecond)
+	if atomic.LoadInt64(&calls) != 1 {
+		t.Errorf("called %d times, expected 1\n", calls)
+	}
+}
+
+// Add a job, remove a job, start cron, expect nothing runs.
+func TestRemoveBeforeRunning(t *testing.T) {
+	wg := &sync.WaitGroup{}
+	wg.Add(1)
+
+	cron := newWithSeconds()
+	id, _ := cron.AddFunc("* * * * * ?", func() { wg.Done() })
+	cron.Remove(id)
+	cron.Start()
+	defer cron.Stop()
+
+	select {
+	case <-time.After(OneSecond):
+		// Success, shouldn't run
+	case <-wait(wg):
+		t.FailNow()
+	}
+}
+
+// Start cron, add a job, remove it, expect it doesn't run.
+func TestRemoveWhileRunning(t *testing.T) {
+	wg := &sync.WaitGroup{}
+	wg.Add(1)
+
+	cron := newWithSeconds()
+	cron.Start()
+	defer cron.Stop()
+	id, _ := cron.AddFunc("* * * * * ?", func() { wg.Done() })
+	cron.Remove(id)
+
+	select {
+	case <-time.After(OneSecond):
+	case <-wait(wg):
+		t.FailNow()
+	}
+}
+
+// Test timing with Entries.
+func TestSnapshotEntries(t *testing.T) {
+	wg := &sync.WaitGroup{}
+	wg.Add(1)
+
+	cron := New()
+	cron.AddFunc("@every 2s", func() { wg.Done() })
+	cron.Start()
+	defer cron.Stop()
+
+	// Cron should fire in 2 seconds. After 1 second, call Entries.
+	select {
+	case <-time.After(OneSecond):
+		cron.Entries()
+	}
+
+	// Even though Entries was called, the cron should fire at the 2 second mark.
+	select {
+	case <-time.After(OneSecond):
+		t.Error("expected job runs at 2 second mark")
+	case <-wait(wg):
+	}
+}
+
+// Test that the entries are correctly sorted.
+// Add a bunch of long-in-the-future entries, and an immediate entry, and ensure
+// that the immediate entry runs immediately.
+// Also: Test that multiple jobs run in the same instant.
+func TestMultipleEntries(t *testing.T) {
+	wg := &sync.WaitGroup{}
+	wg.Add(2)
+
+	cron := newWithSeconds()
+	cron.AddFunc("0 0 0 1 1 ?", func() {})
+	cron.AddFunc("* * * * * ?", func() { wg.Done() })
+	id1, _ := cron.AddFunc("* * * * * ?", func() { t.Fatal() })
+	id2, _ := cron.AddFunc("* * * * * ?", func() { t.Fatal() })
+	cron.AddFunc("0 0 0 31 12 ?", func() {})
+	cron.AddFunc("* * * * * ?", func() { wg.Done() })
+
+	cron.Remove(id1)
+	cron.Start()
+	cron.Remove(id2)
+	defer cron.Stop()
+
+	select {
+	case <-time.After(OneSecond):
+		t.Error("expected job run in proper order")
+	case <-wait(wg):
+	}
+}
+
+// Test running the same job twice.
+func TestRunningJobTwice(t *testing.T) {
+	wg := &sync.WaitGroup{}
+	wg.Add(2)
+
+	cron := newWithSeconds()
+	cron.AddFunc("0 0 0 1 1 ?", func() {})
+	cron.AddFunc("0 0 0 31 12 ?", func() {})
+	cron.AddFunc("* * * * * ?", func() { wg.Done() })
+
+	cron.Start()
+	defer cron.Stop()
+
+	select {
+	case <-time.After(2 * OneSecond):
+		t.Error("expected job fires 2 times")
+	case <-wait(wg):
+	}
+}
+
+func TestRunningMultipleSchedules(t *testing.T) {
+	wg := &sync.WaitGroup{}
+	wg.Add(2)
+
+	cron := newWithSeconds()
+	cron.AddFunc("0 0 0 1 1 ?", func() {})
+	cron.AddFunc("0 0 0 31 12 ?", func() {})
+	cron.AddFunc("* * * * * ?", func() { wg.Done() })
+	cron.Schedule(Every(time.Minute), FuncJob(func() {}))
+	cron.Schedule(Every(time.Second), FuncJob(func() { wg.Done() }))
+	cron.Schedule(Every(time.Hour), FuncJob(func() {}))
+
+	cron.Start()
+	defer cron.Stop()
+
+	select {
+	case <-time.After(2 * OneSecond):
+		t.Error("expected job fires 2 times")
+	case <-wait(wg):
+	}
+}
+
+// Test that the cron is run in the local time zone (as opposed to UTC).
+func TestLocalTimezone(t *testing.T) {
+	wg := &sync.WaitGroup{}
+	wg.Add(2)
+
+	now := time.Now()
+	// FIX: Issue #205
+	// This calculation doesn't work in seconds 58 or 59.
+	// Take the easy way out and sleep.
+	if now.Second() >= 58 {
+		time.Sleep(2 * time.Second)
+		now = time.Now()
+	}
+	spec := fmt.Sprintf("%d,%d %d %d %d %d ?",
+		now.Second()+1, now.Second()+2, now.Minute(), now.Hour(), now.Day(), now.Month())
+
+	cron := newWithSeconds()
+	cron.AddFunc(spec, func() { wg.Done() })
+	cron.Start()
+	defer cron.Stop()
+
+	select {
+	case <-time.After(OneSecond * 2):
+		t.Error("expected job fires 2 times")
+	case <-wait(wg):
+	}
+}
+
+// Test that the cron is run in the given time zone (as opposed to local).
+func TestNonLocalTimezone(t *testing.T) {
+	wg := &sync.WaitGroup{}
+	wg.Add(2)
+
+	loc, err := time.LoadLocation("Atlantic/Cape_Verde")
+	if err != nil {
+		fmt.Printf("Failed to load time zone Atlantic/Cape_Verde: %+v", err)
+		t.Fail()
+	}
+
+	now := time.Now().In(loc)
+	// FIX: Issue #205
+	// This calculation doesn't work in seconds 58 or 59.
+	// Take the easy way out and sleep.
+	if now.Second() >= 58 {
+		time.Sleep(2 * time.Second)
+		now = time.Now().In(loc)
+	}
+	spec := fmt.Sprintf("%d,%d %d %d %d %d ?",
+		now.Second()+1, now.Second()+2, now.Minute(), now.Hour(), now.Day(), now.Month())
+
+	cron := New(WithLocation(loc), WithParser(secondParser))
+	cron.AddFunc(spec, func() { wg.Done() })
+	cron.Start()
+	defer cron.Stop()
+
+	select {
+	case <-time.After(OneSecond * 2):
+		t.Error("expected job fires 2 times")
+	case <-wait(wg):
+	}
+}
+
+// Test that calling stop before start silently returns without
+// blocking the stop channel.
+func TestStopWithoutStart(t *testing.T) {
+	cron := New()
+	cron.Stop()
+}
+
+type testJob struct {
+	wg   *sync.WaitGroup
+	name string
+}
+
+func (t testJob) Run() {
+	t.wg.Done()
+}
+
+// Test that adding an invalid job spec returns an error
+func TestInvalidJobSpec(t *testing.T) {
+	cron := New()
+	_, err := cron.AddJob("this will not parse", nil)
+	if err == nil {
+		t.Errorf("expected an error with invalid spec, got nil")
+	}
+}
+
+// Test blocking run method behaves as Start()
+func TestBlockingRun(t *testing.T) {
+	wg := &sync.WaitGroup{}
+	wg.Add(1)
+
+	cron := newWithSeconds()
+	cron.AddFunc("* * * * * ?", func() { wg.Done() })
+
+	var unblockChan = make(chan struct{})
+
+	go func() {
+		cron.Run()
+		close(unblockChan)
+	}()
+	defer cron.Stop()
+
+	select {
+	case <-time.After(OneSecond):
+		t.Error("expected job fires")
+	case <-unblockChan:
+		t.Error("expected that Run() blocks")
+	case <-wait(wg):
+	}
+}
+
+// Test that double-running is a no-op
+func TestStartNoop(t *testing.T) {
+	var tickChan = make(chan struct{}, 2)
+
+	cron := newWithSeconds()
+	cron.AddFunc("* * * * * ?", func() {
+		tickChan <- struct{}{}
+	})
+
+	cron.Start()
+	defer cron.Stop()
+
+	// Wait for the first firing to ensure the runner is going
+	<-tickChan
+
+	cron.Start()
+
+	<-tickChan
+
+	// Fail if this job fires again in a short period, indicating a double-run
+	select {
+	case <-time.After(time.Millisecond):
+	case <-tickChan:
+		t.Error("expected job fires exactly twice")
+	}
+}
+
+// Simple test using Runnables.
+func TestJob(t *testing.T) {
+	wg := &sync.WaitGroup{}
+	wg.Add(1)
+
+	cron := newWithSeconds()
+	cron.AddJob("0 0 0 30 Feb ?", testJob{wg, "job0"})
+	cron.AddJob("0 0 0 1 1 ?", testJob{wg, "job1"})
+	job2, _ := cron.AddJob("* * * * * ?", testJob{wg, "job2"})
+	cron.AddJob("1 0 0 1 1 ?", testJob{wg, "job3"})
+	cron.Schedule(Every(5*time.Second+5*time.Nanosecond), testJob{wg, "job4"})
+	job5 := cron.Schedule(Every(5*time.Minute), testJob{wg, "job5"})
+
+	// Test getting an Entry pre-Start.
+	if actualName := cron.Entry(job2).Job.(testJob).name; actualName != "job2" {
+		t.Error("wrong job retrieved:", actualName)
+	}
+	if actualName := cron.Entry(job5).Job.(testJob).name; actualName != "job5" {
+		t.Error("wrong job retrieved:", actualName)
+	}
+
+	cron.Start()
+	defer cron.Stop()
+
+	select {
+	case <-time.After(OneSecond):
+		t.FailNow()
+	case <-wait(wg):
+	}
+
+	// Ensure the entries are in the right order.
+	expecteds := []string{"job2", "job4", "job5", "job1", "job3", "job0"}
+
+	var actuals []string
+	for _, entry := range cron.Entries() {
+		actuals = append(actuals, entry.Job.(testJob).name)
+	}
+
+	for i, expected := range expecteds {
+		if actuals[i] != expected {
+			t.Fatalf("Jobs not in the right order.  (expected) %s != %s (actual)", expecteds, actuals)
+		}
+	}
+
+	// Test getting Entries.
+	if actualName := cron.Entry(job2).Job.(testJob).name; actualName != "job2" {
+		t.Error("wrong job retrieved:", actualName)
+	}
+	if actualName := cron.Entry(job5).Job.(testJob).name; actualName != "job5" {
+		t.Error("wrong job retrieved:", actualName)
+	}
+}
+
+// Issue #206
+// Ensure that the next run of a job after removing an entry is accurate.
+func TestScheduleAfterRemoval(t *testing.T) {
+	var wg1 sync.WaitGroup
+	var wg2 sync.WaitGroup
+	wg1.Add(1)
+	wg2.Add(1)
+
+	// The first time this job is run, set a timer and remove the other job
+	// 750ms later. Correct behavior would be to still run the job again in
+	// 250ms, but the bug would cause it to run instead 1s later.
+
+	var calls int
+	var mu sync.Mutex
+
+	cron := newWithSeconds()
+	hourJob := cron.Schedule(Every(time.Hour), FuncJob(func() {}))
+	cron.Schedule(Every(time.Second), FuncJob(func() {
+		mu.Lock()
+		defer mu.Unlock()
+		switch calls {
+		case 0:
+			wg1.Done()
+			calls++
+		case 1:
+			time.Sleep(750 * time.Millisecond)
+			cron.Remove(hourJob)
+			calls++
+		case 2:
+			calls++
+			wg2.Done()
+		case 3:
+			panic("unexpected 3rd call")
+		}
+	}))
+
+	cron.Start()
+	defer cron.Stop()
+
+	// the first run might be any length of time 0 - 1s, since the schedule
+	// rounds to the second. wait for the first run to true up.
+	wg1.Wait()
+
+	select {
+	case <-time.After(2 * OneSecond):
+		t.Error("expected job fires 2 times")
+	case <-wait(&wg2):
+	}
+}
+
+type ZeroSchedule struct{}
+
+func (*ZeroSchedule) Next(time.Time) time.Time {
+	return time.Time{}
+}
+
+// Tests that job without time does not run
+func TestJobWithZeroTimeDoesNotRun(t *testing.T) {
+	cron := newWithSeconds()
+	var calls int64
+	cron.AddFunc("* * * * * *", func() { atomic.AddInt64(&calls, 1) })
+	cron.Schedule(new(ZeroSchedule), FuncJob(func() { t.Error("expected zero task will not run") }))
+	cron.Start()
+	defer cron.Stop()
+	<-time.After(OneSecond)
+	if atomic.LoadInt64(&calls) != 1 {
+		t.Errorf("called %d times, expected 1\n", calls)
+	}
+}
+
+func TestStopAndWait(t *testing.T) {
+	t.Run("nothing running, returns immediately", func(t *testing.T) {
+		cron := newWithSeconds()
+		cron.Start()
+		ctx := cron.Stop()
+		select {
+		case <-ctx.Done():
+		case <-time.After(time.Millisecond):
+			t.Error("context was not done immediately")
+		}
+	})
+
+	t.Run("repeated calls to Stop", func(t *testing.T) {
+		cron := newWithSeconds()
+		cron.Start()
+		_ = cron.Stop()
+		time.Sleep(time.Millisecond)
+		ctx := cron.Stop()
+		select {
+		case <-ctx.Done():
+		case <-time.After(time.Millisecond):
+			t.Error("context was not done immediately")
+		}
+	})
+
+	t.Run("a couple fast jobs added, still returns immediately", func(t *testing.T) {
+		cron := newWithSeconds()
+		cron.AddFunc("* * * * * *", func() {})
+		cron.Start()
+		cron.AddFunc("* * * * * *", func() {})
+		cron.AddFunc("* * * * * *", func() {})
+		cron.AddFunc("* * * * * *", func() {})
+		time.Sleep(time.Second)
+		ctx := cron.Stop()
+		select {
+		case <-ctx.Done():
+		case <-time.After(time.Millisecond):
+			t.Error("context was not done immediately")
+		}
+	})
+
+	t.Run("a couple fast jobs and a slow job added, waits for slow job", func(t *testing.T) {
+		cron := newWithSeconds()
+		cron.AddFunc("* * * * * *", func() {})
+		cron.Start()
+		cron.AddFunc("* * * * * *", func() { time.Sleep(2 * time.Second) })
+		cron.AddFunc("* * * * * *", func() {})
+		time.Sleep(time.Second)
+
+		ctx := cron.Stop()
+
+		// Verify that it is not done for at least 750ms
+		select {
+		case <-ctx.Done():
+			t.Error("context was done too quickly immediately")
+		case <-time.After(750 * time.Millisecond):
+			// expected, because the job sleeping for 1 second is still running
+		}
+
+		// Verify that it IS done in the next 500ms (giving 250ms buffer)
+		select {
+		case <-ctx.Done():
+			// expected
+		case <-time.After(1500 * time.Millisecond):
+			t.Error("context not done after job should have completed")
+		}
+	})
+
+	t.Run("repeated calls to stop, waiting for completion and after", func(t *testing.T) {
+		cron := newWithSeconds()
+		cron.AddFunc("* * * * * *", func() {})
+		cron.AddFunc("* * * * * *", func() { time.Sleep(2 * time.Second) })
+		cron.Start()
+		cron.AddFunc("* * * * * *", func() {})
+		time.Sleep(time.Second)
+		ctx := cron.Stop()
+		ctx2 := cron.Stop()
+
+		// Verify that it is not done for at least 1500ms
+		select {
+		case <-ctx.Done():
+			t.Error("context was done too quickly immediately")
+		case <-ctx2.Done():
+			t.Error("context2 was done too quickly immediately")
+		case <-time.After(1500 * time.Millisecond):
+			// expected, because the job sleeping for 2 seconds is still running
+		}
+
+		// Verify that it IS done in the next 1s (giving 500ms buffer)
+		select {
+		case <-ctx.Done():
+			// expected
+		case <-time.After(time.Second):
+			t.Error("context not done after job should have completed")
+		}
+
+		// Verify that ctx2 is also done.
+		select {
+		case <-ctx2.Done():
+			// expected
+		case <-time.After(time.Millisecond):
+			t.Error("context2 not done even though context1 is")
+		}
+
+		// Verify that a new context retrieved from stop is immediately done.
+		ctx3 := cron.Stop()
+		select {
+		case <-ctx3.Done():
+			// expected
+		case <-time.After(time.Millisecond):
+			t.Error("context not done even when cron Stop is completed")
+		}
+
+	})
+}
+
+func TestMultiThreadedStartAndStop(t *testing.T) {
+	cron := New()
+	go cron.Run()
+	time.Sleep(2 * time.Millisecond)
+	cron.Stop()
+}
+
+func wait(wg *sync.WaitGroup) chan bool {
+	ch := make(chan bool)
+	go func() {
+		wg.Wait()
+		ch <- true
+	}()
+	return ch
+}
+
+func stop(cron *Cron) chan bool {
+	ch := make(chan bool)
+	go func() {
+		cron.Stop()
+		ch <- true
+	}()
+	return ch
+}
+
+// newWithSeconds returns a Cron with the seconds field enabled.
+func newWithSeconds() *Cron {
+	return New(WithParser(secondParser), WithChain())
+}
Index: mattermost-server-7.8.1/vendor/github.com/robfig/cron/doc.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/robfig/cron/doc.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/robfig/cron/doc.go	(revision 4485)
@@ -0,0 +1,231 @@
+/*
+Package cron implements a cron spec parser and job runner.
+
+Installation
+
+To download the specific tagged release, run:
+
+	go get github.com/robfig/cron/v3@v3.0.0
+
+Import it in your program as:
+
+	import "github.com/robfig/cron/v3"
+
+It requires Go 1.11 or later due to usage of Go Modules.
+
+Usage
+
+Callers may register Funcs to be invoked on a given schedule.  Cron will run
+them in their own goroutines.
+
+	c := cron.New()
+	c.AddFunc("30 * * * *", func() { fmt.Println("Every hour on the half hour") })
+	c.AddFunc("30 3-6,20-23 * * *", func() { fmt.Println(".. in the range 3-6am, 8-11pm") })
+	c.AddFunc("CRON_TZ=Asia/Tokyo 30 04 * * *", func() { fmt.Println("Runs at 04:30 Tokyo time every day") })
+	c.AddFunc("@hourly",      func() { fmt.Println("Every hour, starting an hour from now") })
+	c.AddFunc("@every 1h30m", func() { fmt.Println("Every hour thirty, starting an hour thirty from now") })
+	c.Start()
+	..
+	// Funcs are invoked in their own goroutine, asynchronously.
+	...
+	// Funcs may also be added to a running Cron
+	c.AddFunc("@daily", func() { fmt.Println("Every day") })
+	..
+	// Inspect the cron job entries' next and previous run times.
+	inspect(c.Entries())
+	..
+	c.Stop()  // Stop the scheduler (does not stop any jobs already running).
+
+CRON Expression Format
+
+A cron expression represents a set of times, using 5 space-separated fields.
+
+	Field name   | Mandatory? | Allowed values  | Allowed special characters
+	----------   | ---------- | --------------  | --------------------------
+	Minutes      | Yes        | 0-59            | * / , -
+	Hours        | Yes        | 0-23            | * / , -
+	Day of month | Yes        | 1-31            | * / , - ?
+	Month        | Yes        | 1-12 or JAN-DEC | * / , -
+	Day of week  | Yes        | 0-6 or SUN-SAT  | * / , - ?
+
+Month and Day-of-week field values are case insensitive.  "SUN", "Sun", and
+"sun" are equally accepted.
+
+The specific interpretation of the format is based on the Cron Wikipedia page:
+https://en.wikipedia.org/wiki/Cron
+
+Alternative Formats
+
+Alternative Cron expression formats support other fields like seconds. You can
+implement that by creating a custom Parser as follows.
+
+	cron.New(
+		cron.WithParser(
+			cron.NewParser(
+				cron.SecondOptional | cron.Minute | cron.Hour | cron.Dom | cron.Month | cron.Dow | cron.Descriptor)))
+
+Since adding Seconds is the most common modification to the standard cron spec,
+cron provides a builtin function to do that, which is equivalent to the custom
+parser you saw earlier, except that its seconds field is REQUIRED:
+
+	cron.New(cron.WithSeconds())
+
+That emulates Quartz, the most popular alternative Cron schedule format:
+http://www.quartz-scheduler.org/documentation/quartz-2.x/tutorials/crontrigger.html
+
+Special Characters
+
+Asterisk ( * )
+
+The asterisk indicates that the cron expression will match for all values of the
+field; e.g., using an asterisk in the 5th field (month) would indicate every
+month.
+
+Slash ( / )
+
+Slashes are used to describe increments of ranges. For example 3-59/15 in the
+1st field (minutes) would indicate the 3rd minute of the hour and every 15
+minutes thereafter. The form "*\/..." is equivalent to the form "first-last/...",
+that is, an increment over the largest possible range of the field.  The form
+"N/..." is accepted as meaning "N-MAX/...", that is, starting at N, use the
+increment until the end of that specific range.  It does not wrap around.
+
+Comma ( , )
+
+Commas are used to separate items of a list. For example, using "MON,WED,FRI" in
+the 5th field (day of week) would mean Mondays, Wednesdays and Fridays.
+
+Hyphen ( - )
+
+Hyphens are used to define ranges. For example, 9-17 would indicate every
+hour between 9am and 5pm inclusive.
+
+Question mark ( ? )
+
+Question mark may be used instead of '*' for leaving either day-of-month or
+day-of-week blank.
+
+Predefined schedules
+
+You may use one of several pre-defined schedules in place of a cron expression.
+
+	Entry                  | Description                                | Equivalent To
+	-----                  | -----------                                | -------------
+	@yearly (or @annually) | Run once a year, midnight, Jan. 1st        | 0 0 1 1 *
+	@monthly               | Run once a month, midnight, first of month | 0 0 1 * *
+	@weekly                | Run once a week, midnight between Sat/Sun  | 0 0 * * 0
+	@daily (or @midnight)  | Run once a day, midnight                   | 0 0 * * *
+	@hourly                | Run once an hour, beginning of hour        | 0 * * * *
+
+Intervals
+
+You may also schedule a job to execute at fixed intervals, starting at the time it's added
+or cron is run. This is supported by formatting the cron spec like this:
+
+    @every <duration>
+
+where "duration" is a string accepted by time.ParseDuration
+(http://golang.org/pkg/time/#ParseDuration).
+
+For example, "@every 1h30m10s" would indicate a schedule that activates after
+1 hour, 30 minutes, 10 seconds, and then every interval after that.
+
+Note: The interval does not take the job runtime into account.  For example,
+if a job takes 3 minutes to run, and it is scheduled to run every 5 minutes,
+it will have only 2 minutes of idle time between each run.
+
+Time zones
+
+By default, all interpretation and scheduling is done in the machine's local
+time zone (time.Local). You can specify a different time zone on construction:
+
+      cron.New(
+          cron.WithLocation(time.UTC))
+
+Individual cron schedules may also override the time zone they are to be
+interpreted in by providing an additional space-separated field at the beginning
+of the cron spec, of the form "CRON_TZ=Asia/Tokyo".
+
+For example:
+
+	# Runs at 6am in time.Local
+	cron.New().AddFunc("0 6 * * ?", ...)
+
+	# Runs at 6am in America/New_York
+	nyc, _ := time.LoadLocation("America/New_York")
+	c := cron.New(cron.WithLocation(nyc))
+	c.AddFunc("0 6 * * ?", ...)
+
+	# Runs at 6am in Asia/Tokyo
+	cron.New().AddFunc("CRON_TZ=Asia/Tokyo 0 6 * * ?", ...)
+
+	# Runs at 6am in Asia/Tokyo
+	c := cron.New(cron.WithLocation(nyc))
+	c.SetLocation("America/New_York")
+	c.AddFunc("CRON_TZ=Asia/Tokyo 0 6 * * ?", ...)
+
+The prefix "TZ=(TIME ZONE)" is also supported for legacy compatibility.
+
+Be aware that jobs scheduled during daylight-savings leap-ahead transitions will
+not be run!
+
+Job Wrappers
+
+A Cron runner may be configured with a chain of job wrappers to add
+cross-cutting functionality to all submitted jobs. For example, they may be used
+to achieve the following effects:
+
+  - Recover any panics from jobs (activated by default)
+  - Delay a job's execution if the previous run hasn't completed yet
+  - Skip a job's execution if the previous run hasn't completed yet
+  - Log each job's invocations
+
+Install wrappers for all jobs added to a cron using the `cron.WithChain` option:
+
+	cron.New(cron.WithChain(
+		cron.SkipIfStillRunning(logger),
+	))
+
+Install wrappers for individual jobs by explicitly wrapping them:
+
+	job = cron.NewChain(
+		cron.SkipIfStillRunning(logger),
+	).Then(job)
+
+Thread safety
+
+Since the Cron service runs concurrently with the calling code, some amount of
+care must be taken to ensure proper synchronization.
+
+All cron methods are designed to be correctly synchronized as long as the caller
+ensures that invocations have a clear happens-before ordering between them.
+
+Logging
+
+Cron defines a Logger interface that is a subset of the one defined in
+github.com/go-logr/logr. It has two logging levels (Info and Error), and
+parameters are key/value pairs. This makes it possible for cron logging to plug
+into structured logging systems. An adapter, [Verbose]PrintfLogger, is provided
+to wrap the standard library *log.Logger.
+
+For additional insight into Cron operations, verbose logging may be activated
+which will record job runs, scheduling decisions, and added or removed jobs.
+Activate it with a one-off logger as follows:
+
+	cron.New(
+		cron.WithLogger(
+			cron.VerbosePrintfLogger(log.New(os.Stdout, "cron: ", log.LstdFlags))))
+
+
+Implementation
+
+Cron entries are stored in an array, sorted by their next activation time.  Cron
+sleeps until the next job is due to be run.
+
+Upon waking:
+ - it runs each entry that is active on that second
+ - it calculates the next run times for the jobs that were run
+ - it re-sorts the array of entries by next activation time.
+ - it goes to sleep until the soonest job.
+*/
+package cron
Index: mattermost-server-7.8.1/vendor/github.com/robfig/cron/go.mod
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/robfig/cron/go.mod	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/robfig/cron/go.mod	(revision 4485)
@@ -0,0 +1,3 @@
+module github.com/robfig/cron/v3
+
+go 1.12
Index: mattermost-server-7.8.1/vendor/github.com/robfig/cron/logger.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/robfig/cron/logger.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/robfig/cron/logger.go	(revision 4485)
@@ -0,0 +1,86 @@
+package cron
+
+import (
+	"io/ioutil"
+	"log"
+	"os"
+	"strings"
+	"time"
+)
+
+// DefaultLogger is used by Cron if none is specified.
+var DefaultLogger Logger = PrintfLogger(log.New(os.Stdout, "cron: ", log.LstdFlags))
+
+// DiscardLogger can be used by callers to discard all log messages.
+var DiscardLogger Logger = PrintfLogger(log.New(ioutil.Discard, "", 0))
+
+// Logger is the interface used in this package for logging, so that any backend
+// can be plugged in. It is a subset of the github.com/go-logr/logr interface.
+type Logger interface {
+	// Info logs routine messages about cron's operation.
+	Info(msg string, keysAndValues ...interface{})
+	// Error logs an error condition.
+	Error(err error, msg string, keysAndValues ...interface{})
+}
+
+// PrintfLogger wraps a Printf-based logger (such as the standard library "log")
+// into an implementation of the Logger interface which logs errors only.
+func PrintfLogger(l interface{ Printf(string, ...interface{}) }) Logger {
+	return printfLogger{l, false}
+}
+
+// VerbosePrintfLogger wraps a Printf-based logger (such as the standard library
+// "log") into an implementation of the Logger interface which logs everything.
+func VerbosePrintfLogger(l interface{ Printf(string, ...interface{}) }) Logger {
+	return printfLogger{l, true}
+}
+
+type printfLogger struct {
+	logger  interface{ Printf(string, ...interface{}) }
+	logInfo bool
+}
+
+func (pl printfLogger) Info(msg string, keysAndValues ...interface{}) {
+	if pl.logInfo {
+		keysAndValues = formatTimes(keysAndValues)
+		pl.logger.Printf(
+			formatString(len(keysAndValues)),
+			append([]interface{}{msg}, keysAndValues...)...)
+	}
+}
+
+func (pl printfLogger) Error(err error, msg string, keysAndValues ...interface{}) {
+	keysAndValues = formatTimes(keysAndValues)
+	pl.logger.Printf(
+		formatString(len(keysAndValues)+2),
+		append([]interface{}{msg, "error", err}, keysAndValues...)...)
+}
+
+// formatString returns a logfmt-like format string for the number of
+// key/values.
+func formatString(numKeysAndValues int) string {
+	var sb strings.Builder
+	sb.WriteString("%s")
+	if numKeysAndValues > 0 {
+		sb.WriteString(", ")
+	}
+	for i := 0; i < numKeysAndValues/2; i++ {
+		if i > 0 {
+			sb.WriteString(", ")
+		}
+		sb.WriteString("%v=%v")
+	}
+	return sb.String()
+}
+
+// formatTimes formats any time.Time values as RFC3339.
+func formatTimes(keysAndValues []interface{}) []interface{} {
+	var formattedArgs []interface{}
+	for _, arg := range keysAndValues {
+		if t, ok := arg.(time.Time); ok {
+			arg = t.Format(time.RFC3339)
+		}
+		formattedArgs = append(formattedArgs, arg)
+	}
+	return formattedArgs
+}
Index: mattermost-server-7.8.1/vendor/github.com/robfig/cron/option.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/robfig/cron/option.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/robfig/cron/option.go	(revision 4485)
@@ -0,0 +1,45 @@
+package cron
+
+import (
+	"time"
+)
+
+// Option represents a modification to the default behavior of a Cron.
+type Option func(*Cron)
+
+// WithLocation overrides the timezone of the cron instance.
+func WithLocation(loc *time.Location) Option {
+	return func(c *Cron) {
+		c.location = loc
+	}
+}
+
+// WithSeconds overrides the parser used for interpreting job schedules to
+// include a seconds field as the first one.
+func WithSeconds() Option {
+	return WithParser(NewParser(
+		Second | Minute | Hour | Dom | Month | Dow | Descriptor,
+	))
+}
+
+// WithParser overrides the parser used for interpreting job schedules.
+func WithParser(p ScheduleParser) Option {
+	return func(c *Cron) {
+		c.parser = p
+	}
+}
+
+// WithChain specifies Job wrappers to apply to all jobs added to this cron.
+// Refer to the Chain* functions in this package for provided wrappers.
+func WithChain(wrappers ...JobWrapper) Option {
+	return func(c *Cron) {
+		c.chain = NewChain(wrappers...)
+	}
+}
+
+// WithLogger uses the provided logger.
+func WithLogger(logger Logger) Option {
+	return func(c *Cron) {
+		c.logger = logger
+	}
+}
Index: mattermost-server-7.8.1/vendor/github.com/robfig/cron/option_test.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/robfig/cron/option_test.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/robfig/cron/option_test.go	(revision 4485)
@@ -0,0 +1,42 @@
+package cron
+
+import (
+	"log"
+	"strings"
+	"testing"
+	"time"
+)
+
+func TestWithLocation(t *testing.T) {
+	c := New(WithLocation(time.UTC))
+	if c.location != time.UTC {
+		t.Errorf("expected UTC, got %v", c.location)
+	}
+}
+
+func TestWithParser(t *testing.T) {
+	var parser = NewParser(Dow)
+	c := New(WithParser(parser))
+	if c.parser != parser {
+		t.Error("expected provided parser")
+	}
+}
+
+func TestWithVerboseLogger(t *testing.T) {
+	var buf syncWriter
+	var logger = log.New(&buf, "", log.LstdFlags)
+	c := New(WithLogger(VerbosePrintfLogger(logger)))
+	if c.logger.(printfLogger).logger != logger {
+		t.Error("expected provided logger")
+	}
+
+	c.AddFunc("@every 1s", func() {})
+	c.Start()
+	time.Sleep(OneSecond)
+	c.Stop()
+	out := buf.String()
+	if !strings.Contains(out, "schedule,") ||
+		!strings.Contains(out, "run,") {
+		t.Error("expected to see some actions, got:", out)
+	}
+}
Index: mattermost-server-7.8.1/vendor/github.com/robfig/cron/parser.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/robfig/cron/parser.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/robfig/cron/parser.go	(revision 4485)
@@ -0,0 +1,434 @@
+package cron
+
+import (
+	"fmt"
+	"math"
+	"strconv"
+	"strings"
+	"time"
+)
+
+// Configuration options for creating a parser. Most options specify which
+// fields should be included, while others enable features. If a field is not
+// included the parser will assume a default value. These options do not change
+// the order fields are parse in.
+type ParseOption int
+
+const (
+	Second         ParseOption = 1 << iota // Seconds field, default 0
+	SecondOptional                         // Optional seconds field, default 0
+	Minute                                 // Minutes field, default 0
+	Hour                                   // Hours field, default 0
+	Dom                                    // Day of month field, default *
+	Month                                  // Month field, default *
+	Dow                                    // Day of week field, default *
+	DowOptional                            // Optional day of week field, default *
+	Descriptor                             // Allow descriptors such as @monthly, @weekly, etc.
+)
+
+var places = []ParseOption{
+	Second,
+	Minute,
+	Hour,
+	Dom,
+	Month,
+	Dow,
+}
+
+var defaults = []string{
+	"0",
+	"0",
+	"0",
+	"*",
+	"*",
+	"*",
+}
+
+// A custom Parser that can be configured.
+type Parser struct {
+	options ParseOption
+}
+
+// NewParser creates a Parser with custom options.
+//
+// It panics if more than one Optional is given, since it would be impossible to
+// correctly infer which optional is provided or missing in general.
+//
+// Examples
+//
+//  // Standard parser without descriptors
+//  specParser := NewParser(Minute | Hour | Dom | Month | Dow)
+//  sched, err := specParser.Parse("0 0 15 */3 *")
+//
+//  // Same as above, just excludes time fields
+//  subsParser := NewParser(Dom | Month | Dow)
+//  sched, err := specParser.Parse("15 */3 *")
+//
+//  // Same as above, just makes Dow optional
+//  subsParser := NewParser(Dom | Month | DowOptional)
+//  sched, err := specParser.Parse("15 */3")
+//
+func NewParser(options ParseOption) Parser {
+	optionals := 0
+	if options&DowOptional > 0 {
+		optionals++
+	}
+	if options&SecondOptional > 0 {
+		optionals++
+	}
+	if optionals > 1 {
+		panic("multiple optionals may not be configured")
+	}
+	return Parser{options}
+}
+
+// Parse returns a new crontab schedule representing the given spec.
+// It returns a descriptive error if the spec is not valid.
+// It accepts crontab specs and features configured by NewParser.
+func (p Parser) Parse(spec string) (Schedule, error) {
+	if len(spec) == 0 {
+		return nil, fmt.Errorf("empty spec string")
+	}
+
+	// Extract timezone if present
+	var loc = time.Local
+	if strings.HasPrefix(spec, "TZ=") || strings.HasPrefix(spec, "CRON_TZ=") {
+		var err error
+		i := strings.Index(spec, " ")
+		eq := strings.Index(spec, "=")
+		if loc, err = time.LoadLocation(spec[eq+1 : i]); err != nil {
+			return nil, fmt.Errorf("provided bad location %s: %v", spec[eq+1:i], err)
+		}
+		spec = strings.TrimSpace(spec[i:])
+	}
+
+	// Handle named schedules (descriptors), if configured
+	if strings.HasPrefix(spec, "@") {
+		if p.options&Descriptor == 0 {
+			return nil, fmt.Errorf("parser does not accept descriptors: %v", spec)
+		}
+		return parseDescriptor(spec, loc)
+	}
+
+	// Split on whitespace.
+	fields := strings.Fields(spec)
+
+	// Validate & fill in any omitted or optional fields
+	var err error
+	fields, err = normalizeFields(fields, p.options)
+	if err != nil {
+		return nil, err
+	}
+
+	field := func(field string, r bounds) uint64 {
+		if err != nil {
+			return 0
+		}
+		var bits uint64
+		bits, err = getField(field, r)
+		return bits
+	}
+
+	var (
+		second     = field(fields[0], seconds)
+		minute     = field(fields[1], minutes)
+		hour       = field(fields[2], hours)
+		dayofmonth = field(fields[3], dom)
+		month      = field(fields[4], months)
+		dayofweek  = field(fields[5], dow)
+	)
+	if err != nil {
+		return nil, err
+	}
+
+	return &SpecSchedule{
+		Second:   second,
+		Minute:   minute,
+		Hour:     hour,
+		Dom:      dayofmonth,
+		Month:    month,
+		Dow:      dayofweek,
+		Location: loc,
+	}, nil
+}
+
+// normalizeFields takes a subset set of the time fields and returns the full set
+// with defaults (zeroes) populated for unset fields.
+//
+// As part of performing this function, it also validates that the provided
+// fields are compatible with the configured options.
+func normalizeFields(fields []string, options ParseOption) ([]string, error) {
+	// Validate optionals & add their field to options
+	optionals := 0
+	if options&SecondOptional > 0 {
+		options |= Second
+		optionals++
+	}
+	if options&DowOptional > 0 {
+		options |= Dow
+		optionals++
+	}
+	if optionals > 1 {
+		return nil, fmt.Errorf("multiple optionals may not be configured")
+	}
+
+	// Figure out how many fields we need
+	max := 0
+	for _, place := range places {
+		if options&place > 0 {
+			max++
+		}
+	}
+	min := max - optionals
+
+	// Validate number of fields
+	if count := len(fields); count < min || count > max {
+		if min == max {
+			return nil, fmt.Errorf("expected exactly %d fields, found %d: %s", min, count, fields)
+		}
+		return nil, fmt.Errorf("expected %d to %d fields, found %d: %s", min, max, count, fields)
+	}
+
+	// Populate the optional field if not provided
+	if min < max && len(fields) == min {
+		switch {
+		case options&DowOptional > 0:
+			fields = append(fields, defaults[5]) // TODO: improve access to default
+		case options&SecondOptional > 0:
+			fields = append([]string{defaults[0]}, fields...)
+		default:
+			return nil, fmt.Errorf("unknown optional field")
+		}
+	}
+
+	// Populate all fields not part of options with their defaults
+	n := 0
+	expandedFields := make([]string, len(places))
+	copy(expandedFields, defaults)
+	for i, place := range places {
+		if options&place > 0 {
+			expandedFields[i] = fields[n]
+			n++
+		}
+	}
+	return expandedFields, nil
+}
+
+var standardParser = NewParser(
+	Minute | Hour | Dom | Month | Dow | Descriptor,
+)
+
+// ParseStandard returns a new crontab schedule representing the given
+// standardSpec (https://en.wikipedia.org/wiki/Cron). It requires 5 entries
+// representing: minute, hour, day of month, month and day of week, in that
+// order. It returns a descriptive error if the spec is not valid.
+//
+// It accepts
+//   - Standard crontab specs, e.g. "* * * * ?"
+//   - Descriptors, e.g. "@midnight", "@every 1h30m"
+func ParseStandard(standardSpec string) (Schedule, error) {
+	return standardParser.Parse(standardSpec)
+}
+
+// getField returns an Int with the bits set representing all of the times that
+// the field represents or error parsing field value.  A "field" is a comma-separated
+// list of "ranges".
+func getField(field string, r bounds) (uint64, error) {
+	var bits uint64
+	ranges := strings.FieldsFunc(field, func(r rune) bool { return r == ',' })
+	for _, expr := range ranges {
+		bit, err := getRange(expr, r)
+		if err != nil {
+			return bits, err
+		}
+		bits |= bit
+	}
+	return bits, nil
+}
+
+// getRange returns the bits indicated by the given expression:
+//   number | number "-" number [ "/" number ]
+// or error parsing range.
+func getRange(expr string, r bounds) (uint64, error) {
+	var (
+		start, end, step uint
+		rangeAndStep     = strings.Split(expr, "/")
+		lowAndHigh       = strings.Split(rangeAndStep[0], "-")
+		singleDigit      = len(lowAndHigh) == 1
+		err              error
+	)
+
+	var extra uint64
+	if lowAndHigh[0] == "*" || lowAndHigh[0] == "?" {
+		start = r.min
+		end = r.max
+		extra = starBit
+	} else {
+		start, err = parseIntOrName(lowAndHigh[0], r.names)
+		if err != nil {
+			return 0, err
+		}
+		switch len(lowAndHigh) {
+		case 1:
+			end = start
+		case 2:
+			end, err = parseIntOrName(lowAndHigh[1], r.names)
+			if err != nil {
+				return 0, err
+			}
+		default:
+			return 0, fmt.Errorf("too many hyphens: %s", expr)
+		}
+	}
+
+	switch len(rangeAndStep) {
+	case 1:
+		step = 1
+	case 2:
+		step, err = mustParseInt(rangeAndStep[1])
+		if err != nil {
+			return 0, err
+		}
+
+		// Special handling: "N/step" means "N-max/step".
+		if singleDigit {
+			end = r.max
+		}
+		if step > 1 {
+			extra = 0
+		}
+	default:
+		return 0, fmt.Errorf("too many slashes: %s", expr)
+	}
+
+	if start < r.min {
+		return 0, fmt.Errorf("beginning of range (%d) below minimum (%d): %s", start, r.min, expr)
+	}
+	if end > r.max {
+		return 0, fmt.Errorf("end of range (%d) above maximum (%d): %s", end, r.max, expr)
+	}
+	if start > end {
+		return 0, fmt.Errorf("beginning of range (%d) beyond end of range (%d): %s", start, end, expr)
+	}
+	if step == 0 {
+		return 0, fmt.Errorf("step of range should be a positive number: %s", expr)
+	}
+
+	return getBits(start, end, step) | extra, nil
+}
+
+// parseIntOrName returns the (possibly-named) integer contained in expr.
+func parseIntOrName(expr string, names map[string]uint) (uint, error) {
+	if names != nil {
+		if namedInt, ok := names[strings.ToLower(expr)]; ok {
+			return namedInt, nil
+		}
+	}
+	return mustParseInt(expr)
+}
+
+// mustParseInt parses the given expression as an int or returns an error.
+func mustParseInt(expr string) (uint, error) {
+	num, err := strconv.Atoi(expr)
+	if err != nil {
+		return 0, fmt.Errorf("failed to parse int from %s: %s", expr, err)
+	}
+	if num < 0 {
+		return 0, fmt.Errorf("negative number (%d) not allowed: %s", num, expr)
+	}
+
+	return uint(num), nil
+}
+
+// getBits sets all bits in the range [min, max], modulo the given step size.
+func getBits(min, max, step uint) uint64 {
+	var bits uint64
+
+	// If step is 1, use shifts.
+	if step == 1 {
+		return ^(math.MaxUint64 << (max + 1)) & (math.MaxUint64 << min)
+	}
+
+	// Else, use a simple loop.
+	for i := min; i <= max; i += step {
+		bits |= 1 << i
+	}
+	return bits
+}
+
+// all returns all bits within the given bounds.  (plus the star bit)
+func all(r bounds) uint64 {
+	return getBits(r.min, r.max, 1) | starBit
+}
+
+// parseDescriptor returns a predefined schedule for the expression, or error if none matches.
+func parseDescriptor(descriptor string, loc *time.Location) (Schedule, error) {
+	switch descriptor {
+	case "@yearly", "@annually":
+		return &SpecSchedule{
+			Second:   1 << seconds.min,
+			Minute:   1 << minutes.min,
+			Hour:     1 << hours.min,
+			Dom:      1 << dom.min,
+			Month:    1 << months.min,
+			Dow:      all(dow),
+			Location: loc,
+		}, nil
+
+	case "@monthly":
+		return &SpecSchedule{
+			Second:   1 << seconds.min,
+			Minute:   1 << minutes.min,
+			Hour:     1 << hours.min,
+			Dom:      1 << dom.min,
+			Month:    all(months),
+			Dow:      all(dow),
+			Location: loc,
+		}, nil
+
+	case "@weekly":
+		return &SpecSchedule{
+			Second:   1 << seconds.min,
+			Minute:   1 << minutes.min,
+			Hour:     1 << hours.min,
+			Dom:      all(dom),
+			Month:    all(months),
+			Dow:      1 << dow.min,
+			Location: loc,
+		}, nil
+
+	case "@daily", "@midnight":
+		return &SpecSchedule{
+			Second:   1 << seconds.min,
+			Minute:   1 << minutes.min,
+			Hour:     1 << hours.min,
+			Dom:      all(dom),
+			Month:    all(months),
+			Dow:      all(dow),
+			Location: loc,
+		}, nil
+
+	case "@hourly":
+		return &SpecSchedule{
+			Second:   1 << seconds.min,
+			Minute:   1 << minutes.min,
+			Hour:     all(hours),
+			Dom:      all(dom),
+			Month:    all(months),
+			Dow:      all(dow),
+			Location: loc,
+		}, nil
+
+	}
+
+	const every = "@every "
+	if strings.HasPrefix(descriptor, every) {
+		duration, err := time.ParseDuration(descriptor[len(every):])
+		if err != nil {
+			return nil, fmt.Errorf("failed to parse duration %s: %s", descriptor, err)
+		}
+		return Every(duration), nil
+	}
+
+	return nil, fmt.Errorf("unrecognized descriptor: %s", descriptor)
+}
Index: mattermost-server-7.8.1/vendor/github.com/robfig/cron/parser_test.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/robfig/cron/parser_test.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/robfig/cron/parser_test.go	(revision 4485)
@@ -0,0 +1,383 @@
+package cron
+
+import (
+	"reflect"
+	"strings"
+	"testing"
+	"time"
+)
+
+var secondParser = NewParser(Second | Minute | Hour | Dom | Month | DowOptional | Descriptor)
+
+func TestRange(t *testing.T) {
+	zero := uint64(0)
+	ranges := []struct {
+		expr     string
+		min, max uint
+		expected uint64
+		err      string
+	}{
+		{"5", 0, 7, 1 << 5, ""},
+		{"0", 0, 7, 1 << 0, ""},
+		{"7", 0, 7, 1 << 7, ""},
+
+		{"5-5", 0, 7, 1 << 5, ""},
+		{"5-6", 0, 7, 1<<5 | 1<<6, ""},
+		{"5-7", 0, 7, 1<<5 | 1<<6 | 1<<7, ""},
+
+		{"5-6/2", 0, 7, 1 << 5, ""},
+		{"5-7/2", 0, 7, 1<<5 | 1<<7, ""},
+		{"5-7/1", 0, 7, 1<<5 | 1<<6 | 1<<7, ""},
+
+		{"*", 1, 3, 1<<1 | 1<<2 | 1<<3 | starBit, ""},
+		{"*/2", 1, 3, 1<<1 | 1<<3, ""},
+
+		{"5--5", 0, 0, zero, "too many hyphens"},
+		{"jan-x", 0, 0, zero, "failed to parse int from"},
+		{"2-x", 1, 5, zero, "failed to parse int from"},
+		{"*/-12", 0, 0, zero, "negative number"},
+		{"*//2", 0, 0, zero, "too many slashes"},
+		{"1", 3, 5, zero, "below minimum"},
+		{"6", 3, 5, zero, "above maximum"},
+		{"5-3", 3, 5, zero, "beyond end of range"},
+		{"*/0", 0, 0, zero, "should be a positive number"},
+	}
+
+	for _, c := range ranges {
+		actual, err := getRange(c.expr, bounds{c.min, c.max, nil})
+		if len(c.err) != 0 && (err == nil || !strings.Contains(err.Error(), c.err)) {
+			t.Errorf("%s => expected %v, got %v", c.expr, c.err, err)
+		}
+		if len(c.err) == 0 && err != nil {
+			t.Errorf("%s => unexpected error %v", c.expr, err)
+		}
+		if actual != c.expected {
+			t.Errorf("%s => expected %d, got %d", c.expr, c.expected, actual)
+		}
+	}
+}
+
+func TestField(t *testing.T) {
+	fields := []struct {
+		expr     string
+		min, max uint
+		expected uint64
+	}{
+		{"5", 1, 7, 1 << 5},
+		{"5,6", 1, 7, 1<<5 | 1<<6},
+		{"5,6,7", 1, 7, 1<<5 | 1<<6 | 1<<7},
+		{"1,5-7/2,3", 1, 7, 1<<1 | 1<<5 | 1<<7 | 1<<3},
+	}
+
+	for _, c := range fields {
+		actual, _ := getField(c.expr, bounds{c.min, c.max, nil})
+		if actual != c.expected {
+			t.Errorf("%s => expected %d, got %d", c.expr, c.expected, actual)
+		}
+	}
+}
+
+func TestAll(t *testing.T) {
+	allBits := []struct {
+		r        bounds
+		expected uint64
+	}{
+		{minutes, 0xfffffffffffffff}, // 0-59: 60 ones
+		{hours, 0xffffff},            // 0-23: 24 ones
+		{dom, 0xfffffffe},            // 1-31: 31 ones, 1 zero
+		{months, 0x1ffe},             // 1-12: 12 ones, 1 zero
+		{dow, 0x7f},                  // 0-6: 7 ones
+	}
+
+	for _, c := range allBits {
+		actual := all(c.r) // all() adds the starBit, so compensate for that..
+		if c.expected|starBit != actual {
+			t.Errorf("%d-%d/%d => expected %b, got %b",
+				c.r.min, c.r.max, 1, c.expected|starBit, actual)
+		}
+	}
+}
+
+func TestBits(t *testing.T) {
+	bits := []struct {
+		min, max, step uint
+		expected       uint64
+	}{
+		{0, 0, 1, 0x1},
+		{1, 1, 1, 0x2},
+		{1, 5, 2, 0x2a}, // 101010
+		{1, 4, 2, 0xa},  // 1010
+	}
+
+	for _, c := range bits {
+		actual := getBits(c.min, c.max, c.step)
+		if c.expected != actual {
+			t.Errorf("%d-%d/%d => expected %b, got %b",
+				c.min, c.max, c.step, c.expected, actual)
+		}
+	}
+}
+
+func TestParseScheduleErrors(t *testing.T) {
+	var tests = []struct{ expr, err string }{
+		{"* 5 j * * *", "failed to parse int from"},
+		{"@every Xm", "failed to parse duration"},
+		{"@unrecognized", "unrecognized descriptor"},
+		{"* * * *", "expected 5 to 6 fields"},
+		{"", "empty spec string"},
+	}
+	for _, c := range tests {
+		actual, err := secondParser.Parse(c.expr)
+		if err == nil || !strings.Contains(err.Error(), c.err) {
+			t.Errorf("%s => expected %v, got %v", c.expr, c.err, err)
+		}
+		if actual != nil {
+			t.Errorf("expected nil schedule on error, got %v", actual)
+		}
+	}
+}
+
+func TestParseSchedule(t *testing.T) {
+	tokyo, _ := time.LoadLocation("Asia/Tokyo")
+	entries := []struct {
+		parser   Parser
+		expr     string
+		expected Schedule
+	}{
+		{secondParser, "0 5 * * * *", every5min(time.Local)},
+		{standardParser, "5 * * * *", every5min(time.Local)},
+		{secondParser, "CRON_TZ=UTC  0 5 * * * *", every5min(time.UTC)},
+		{standardParser, "CRON_TZ=UTC  5 * * * *", every5min(time.UTC)},
+		{secondParser, "CRON_TZ=Asia/Tokyo 0 5 * * * *", every5min(tokyo)},
+		{secondParser, "@every 5m", ConstantDelaySchedule{5 * time.Minute}},
+		{secondParser, "@midnight", midnight(time.Local)},
+		{secondParser, "TZ=UTC  @midnight", midnight(time.UTC)},
+		{secondParser, "TZ=Asia/Tokyo @midnight", midnight(tokyo)},
+		{secondParser, "@yearly", annual(time.Local)},
+		{secondParser, "@annually", annual(time.Local)},
+		{
+			parser: secondParser,
+			expr:   "* 5 * * * *",
+			expected: &SpecSchedule{
+				Second:   all(seconds),
+				Minute:   1 << 5,
+				Hour:     all(hours),
+				Dom:      all(dom),
+				Month:    all(months),
+				Dow:      all(dow),
+				Location: time.Local,
+			},
+		},
+	}
+
+	for _, c := range entries {
+		actual, err := c.parser.Parse(c.expr)
+		if err != nil {
+			t.Errorf("%s => unexpected error %v", c.expr, err)
+		}
+		if !reflect.DeepEqual(actual, c.expected) {
+			t.Errorf("%s => expected %b, got %b", c.expr, c.expected, actual)
+		}
+	}
+}
+
+func TestOptionalSecondSchedule(t *testing.T) {
+	parser := NewParser(SecondOptional | Minute | Hour | Dom | Month | Dow | Descriptor)
+	entries := []struct {
+		expr     string
+		expected Schedule
+	}{
+		{"0 5 * * * *", every5min(time.Local)},
+		{"5 5 * * * *", every5min5s(time.Local)},
+		{"5 * * * *", every5min(time.Local)},
+	}
+
+	for _, c := range entries {
+		actual, err := parser.Parse(c.expr)
+		if err != nil {
+			t.Errorf("%s => unexpected error %v", c.expr, err)
+		}
+		if !reflect.DeepEqual(actual, c.expected) {
+			t.Errorf("%s => expected %b, got %b", c.expr, c.expected, actual)
+		}
+	}
+}
+
+func TestNormalizeFields(t *testing.T) {
+	tests := []struct {
+		name     string
+		input    []string
+		options  ParseOption
+		expected []string
+	}{
+		{
+			"AllFields_NoOptional",
+			[]string{"0", "5", "*", "*", "*", "*"},
+			Second | Minute | Hour | Dom | Month | Dow | Descriptor,
+			[]string{"0", "5", "*", "*", "*", "*"},
+		},
+		{
+			"AllFields_SecondOptional_Provided",
+			[]string{"0", "5", "*", "*", "*", "*"},
+			SecondOptional | Minute | Hour | Dom | Month | Dow | Descriptor,
+			[]string{"0", "5", "*", "*", "*", "*"},
+		},
+		{
+			"AllFields_SecondOptional_NotProvided",
+			[]string{"5", "*", "*", "*", "*"},
+			SecondOptional | Minute | Hour | Dom | Month | Dow | Descriptor,
+			[]string{"0", "5", "*", "*", "*", "*"},
+		},
+		{
+			"SubsetFields_NoOptional",
+			[]string{"5", "15", "*"},
+			Hour | Dom | Month,
+			[]string{"0", "0", "5", "15", "*", "*"},
+		},
+		{
+			"SubsetFields_DowOptional_Provided",
+			[]string{"5", "15", "*", "4"},
+			Hour | Dom | Month | DowOptional,
+			[]string{"0", "0", "5", "15", "*", "4"},
+		},
+		{
+			"SubsetFields_DowOptional_NotProvided",
+			[]string{"5", "15", "*"},
+			Hour | Dom | Month | DowOptional,
+			[]string{"0", "0", "5", "15", "*", "*"},
+		},
+		{
+			"SubsetFields_SecondOptional_NotProvided",
+			[]string{"5", "15", "*"},
+			SecondOptional | Hour | Dom | Month,
+			[]string{"0", "0", "5", "15", "*", "*"},
+		},
+	}
+
+	for _, test := range tests {
+		t.Run(test.name, func(t *testing.T) {
+			actual, err := normalizeFields(test.input, test.options)
+			if err != nil {
+				t.Errorf("unexpected error: %v", err)
+			}
+			if !reflect.DeepEqual(actual, test.expected) {
+				t.Errorf("expected %v, got %v", test.expected, actual)
+			}
+		})
+	}
+}
+
+func TestNormalizeFields_Errors(t *testing.T) {
+	tests := []struct {
+		name    string
+		input   []string
+		options ParseOption
+		err     string
+	}{
+		{
+			"TwoOptionals",
+			[]string{"0", "5", "*", "*", "*", "*"},
+			SecondOptional | Minute | Hour | Dom | Month | DowOptional,
+			"",
+		},
+		{
+			"TooManyFields",
+			[]string{"0", "5", "*", "*"},
+			SecondOptional | Minute | Hour,
+			"",
+		},
+		{
+			"NoFields",
+			[]string{},
+			SecondOptional | Minute | Hour,
+			"",
+		},
+		{
+			"TooFewFields",
+			[]string{"*"},
+			SecondOptional | Minute | Hour,
+			"",
+		},
+	}
+	for _, test := range tests {
+		t.Run(test.name, func(t *testing.T) {
+			actual, err := normalizeFields(test.input, test.options)
+			if err == nil {
+				t.Errorf("expected an error, got none. results: %v", actual)
+			}
+			if !strings.Contains(err.Error(), test.err) {
+				t.Errorf("expected error %q, got %q", test.err, err.Error())
+			}
+		})
+	}
+}
+
+func TestStandardSpecSchedule(t *testing.T) {
+	entries := []struct {
+		expr     string
+		expected Schedule
+		err      string
+	}{
+		{
+			expr:     "5 * * * *",
+			expected: &SpecSchedule{1 << seconds.min, 1 << 5, all(hours), all(dom), all(months), all(dow), time.Local},
+		},
+		{
+			expr:     "@every 5m",
+			expected: ConstantDelaySchedule{time.Duration(5) * time.Minute},
+		},
+		{
+			expr: "5 j * * *",
+			err:  "failed to parse int from",
+		},
+		{
+			expr: "* * * *",
+			err:  "expected exactly 5 fields",
+		},
+	}
+
+	for _, c := range entries {
+		actual, err := ParseStandard(c.expr)
+		if len(c.err) != 0 && (err == nil || !strings.Contains(err.Error(), c.err)) {
+			t.Errorf("%s => expected %v, got %v", c.expr, c.err, err)
+		}
+		if len(c.err) == 0 && err != nil {
+			t.Errorf("%s => unexpected error %v", c.expr, err)
+		}
+		if !reflect.DeepEqual(actual, c.expected) {
+			t.Errorf("%s => expected %b, got %b", c.expr, c.expected, actual)
+		}
+	}
+}
+
+func TestNoDescriptorParser(t *testing.T) {
+	parser := NewParser(Minute | Hour)
+	_, err := parser.Parse("@every 1m")
+	if err == nil {
+		t.Error("expected an error, got none")
+	}
+}
+
+func every5min(loc *time.Location) *SpecSchedule {
+	return &SpecSchedule{1 << 0, 1 << 5, all(hours), all(dom), all(months), all(dow), loc}
+}
+
+func every5min5s(loc *time.Location) *SpecSchedule {
+	return &SpecSchedule{1 << 5, 1 << 5, all(hours), all(dom), all(months), all(dow), loc}
+}
+
+func midnight(loc *time.Location) *SpecSchedule {
+	return &SpecSchedule{1, 1, 1, all(dom), all(months), all(dow), loc}
+}
+
+func annual(loc *time.Location) *SpecSchedule {
+	return &SpecSchedule{
+		Second:   1 << seconds.min,
+		Minute:   1 << minutes.min,
+		Hour:     1 << hours.min,
+		Dom:      1 << dom.min,
+		Month:    1 << months.min,
+		Dow:      all(dow),
+		Location: loc,
+	}
+}
Index: mattermost-server-7.8.1/vendor/github.com/robfig/cron/spec.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/robfig/cron/spec.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/robfig/cron/spec.go	(revision 4485)
@@ -0,0 +1,188 @@
+package cron
+
+import "time"
+
+// SpecSchedule specifies a duty cycle (to the second granularity), based on a
+// traditional crontab specification. It is computed initially and stored as bit sets.
+type SpecSchedule struct {
+	Second, Minute, Hour, Dom, Month, Dow uint64
+
+	// Override location for this schedule.
+	Location *time.Location
+}
+
+// bounds provides a range of acceptable values (plus a map of name to value).
+type bounds struct {
+	min, max uint
+	names    map[string]uint
+}
+
+// The bounds for each field.
+var (
+	seconds = bounds{0, 59, nil}
+	minutes = bounds{0, 59, nil}
+	hours   = bounds{0, 23, nil}
+	dom     = bounds{1, 31, nil}
+	months  = bounds{1, 12, map[string]uint{
+		"jan": 1,
+		"feb": 2,
+		"mar": 3,
+		"apr": 4,
+		"may": 5,
+		"jun": 6,
+		"jul": 7,
+		"aug": 8,
+		"sep": 9,
+		"oct": 10,
+		"nov": 11,
+		"dec": 12,
+	}}
+	dow = bounds{0, 6, map[string]uint{
+		"sun": 0,
+		"mon": 1,
+		"tue": 2,
+		"wed": 3,
+		"thu": 4,
+		"fri": 5,
+		"sat": 6,
+	}}
+)
+
+const (
+	// Set the top bit if a star was included in the expression.
+	starBit = 1 << 63
+)
+
+// Next returns the next time this schedule is activated, greater than the given
+// time.  If no time can be found to satisfy the schedule, return the zero time.
+func (s *SpecSchedule) Next(t time.Time) time.Time {
+	// General approach
+	//
+	// For Month, Day, Hour, Minute, Second:
+	// Check if the time value matches.  If yes, continue to the next field.
+	// If the field doesn't match the schedule, then increment the field until it matches.
+	// While incrementing the field, a wrap-around brings it back to the beginning
+	// of the field list (since it is necessary to re-verify previous field
+	// values)
+
+	// Convert the given time into the schedule's timezone, if one is specified.
+	// Save the original timezone so we can convert back after we find a time.
+	// Note that schedules without a time zone specified (time.Local) are treated
+	// as local to the time provided.
+	origLocation := t.Location()
+	loc := s.Location
+	if loc == time.Local {
+		loc = t.Location()
+	}
+	if s.Location != time.Local {
+		t = t.In(s.Location)
+	}
+
+	// Start at the earliest possible time (the upcoming second).
+	t = t.Add(1*time.Second - time.Duration(t.Nanosecond())*time.Nanosecond)
+
+	// This flag indicates whether a field has been incremented.
+	added := false
+
+	// If no time is found within five years, return zero.
+	yearLimit := t.Year() + 5
+
+WRAP:
+	if t.Year() > yearLimit {
+		return time.Time{}
+	}
+
+	// Find the first applicable month.
+	// If it's this month, then do nothing.
+	for 1<<uint(t.Month())&s.Month == 0 {
+		// If we have to add a month, reset the other parts to 0.
+		if !added {
+			added = true
+			// Otherwise, set the date at the beginning (since the current time is irrelevant).
+			t = time.Date(t.Year(), t.Month(), 1, 0, 0, 0, 0, loc)
+		}
+		t = t.AddDate(0, 1, 0)
+
+		// Wrapped around.
+		if t.Month() == time.January {
+			goto WRAP
+		}
+	}
+
+	// Now get a day in that month.
+	//
+	// NOTE: This causes issues for daylight savings regimes where midnight does
+	// not exist.  For example: Sao Paulo has DST that transforms midnight on
+	// 11/3 into 1am. Handle that by noticing when the Hour ends up != 0.
+	for !dayMatches(s, t) {
+		if !added {
+			added = true
+			t = time.Date(t.Year(), t.Month(), t.Day(), 0, 0, 0, 0, loc)
+		}
+		t = t.AddDate(0, 0, 1)
+		// Notice if the hour is no longer midnight due to DST.
+		// Add an hour if it's 23, subtract an hour if it's 1.
+		if t.Hour() != 0 {
+			if t.Hour() > 12 {
+				t = t.Add(time.Duration(24-t.Hour()) * time.Hour)
+			} else {
+				t = t.Add(time.Duration(-t.Hour()) * time.Hour)
+			}
+		}
+
+		if t.Day() == 1 {
+			goto WRAP
+		}
+	}
+
+	for 1<<uint(t.Hour())&s.Hour == 0 {
+		if !added {
+			added = true
+			t = time.Date(t.Year(), t.Month(), t.Day(), t.Hour(), 0, 0, 0, loc)
+		}
+		t = t.Add(1 * time.Hour)
+
+		if t.Hour() == 0 {
+			goto WRAP
+		}
+	}
+
+	for 1<<uint(t.Minute())&s.Minute == 0 {
+		if !added {
+			added = true
+			t = t.Truncate(time.Minute)
+		}
+		t = t.Add(1 * time.Minute)
+
+		if t.Minute() == 0 {
+			goto WRAP
+		}
+	}
+
+	for 1<<uint(t.Second())&s.Second == 0 {
+		if !added {
+			added = true
+			t = t.Truncate(time.Second)
+		}
+		t = t.Add(1 * time.Second)
+
+		if t.Second() == 0 {
+			goto WRAP
+		}
+	}
+
+	return t.In(origLocation)
+}
+
+// dayMatches returns true if the schedule's day-of-week and day-of-month
+// restrictions are satisfied by the given time.
+func dayMatches(s *SpecSchedule, t time.Time) bool {
+	var (
+		domMatch bool = 1<<uint(t.Day())&s.Dom > 0
+		dowMatch bool = 1<<uint(t.Weekday())&s.Dow > 0
+	)
+	if s.Dom&starBit > 0 || s.Dow&starBit > 0 {
+		return domMatch && dowMatch
+	}
+	return domMatch || dowMatch
+}
Index: mattermost-server-7.8.1/vendor/github.com/robfig/cron/spec_test.go
===================================================================
--- mattermost-server-7.8.1/vendor/github.com/robfig/cron/spec_test.go	(nonexistent)
+++ mattermost-server-7.8.1/vendor/github.com/robfig/cron/spec_test.go	(revision 4485)
@@ -0,0 +1,300 @@
+package cron
+
+import (
+	"strings"
+	"testing"
+	"time"
+)
+
+func TestActivation(t *testing.T) {
+	tests := []struct {
+		time, spec string
+		expected   bool
+	}{
+		// Every fifteen minutes.
+		{"Mon Jul 9 15:00 2012", "0/15 * * * *", true},
+		{"Mon Jul 9 15:45 2012", "0/15 * * * *", true},
+		{"Mon Jul 9 15:40 2012", "0/15 * * * *", false},
+
+		// Every fifteen minutes, starting at 5 minutes.
+		{"Mon Jul 9 15:05 2012", "5/15 * * * *", true},
+		{"Mon Jul 9 15:20 2012", "5/15 * * * *", true},
+		{"Mon Jul 9 15:50 2012", "5/15 * * * *", true},
+
+		// Named months
+		{"Sun Jul 15 15:00 2012", "0/15 * * Jul *", true},
+		{"Sun Jul 15 15:00 2012", "0/15 * * Jun *", false},
+
+		// Everything set.
+		{"Sun Jul 15 08:30 2012", "30 08 ? Jul Sun", true},
+		{"Sun Jul 15 08:30 2012", "30 08 15 Jul ?", true},
+		{"Mon Jul 16 08:30 2012", "30 08 ? Jul Sun", false},
+		{"Mon Jul 16 08:30 2012", "30 08 15 Jul ?", false},
+
+		// Predefined schedules
+		{"Mon Jul 9 15:00 2012", "@hourly", true},
+		{"Mon Jul 9 15:04 2012", "@hourly", false},
+		{"Mon Jul 9 15:00 2012", "@daily", false},
+		{"Mon Jul 9 00:00 2012", "@daily", true},
+		{"Mon Jul 9 00:00 2012", "@weekly", false},
+		{"Sun Jul 8 00:00 2012", "@weekly", true},
+		{"Sun Jul 8 01:00 2012", "@weekly", false},
+		{"Sun Jul 8 00:00 2012", "@monthly", false},
+		{"Sun Jul 1 00:00 2012", "@monthly", true},
+
+		// Test interaction of DOW and DOM.
+		// If both are restricted, then only one needs to match.
+		{"Sun Jul 15 00:00 2012", "* * 1,15 * Sun", true},
+		{"Fri Jun 15 00:00 2012", "* * 1,15 * Sun", true},
+		{"Wed Aug 1 00:00 2012", "* * 1,15 * Sun", true},
+		{"Sun Jul 15 00:00 2012", "* * */10 * Sun", true}, // verifies #70
+
+		// However, if one has a star, then both need to match.
+		{"Sun Jul 15 00:00 2012", "* * * * Mon", false},
+		{"Mon Jul 9 00:00 2012", "* * 1,15 * *", false},
+		{"Sun Jul 15 00:00 2012", "* * 1,15 * *", true},
+		{"Sun Jul 15 00:00 2012", "* * */2 * Sun", true},
+	}
+
+	for _, test := range tests {
+		sched, err := ParseStandard(test.spec)
+		if err != nil {
+			t.Error(err)
+			continue
+		}
+		actual := sched.Next(getTime(test.time).Add(-1 * time.Second))
+		expected := getTime(test.time)
+		if test.expected && expected != actual || !test.expected && expected == actual {
+			t.Errorf("Fail evaluating %s on %s: (expected) %s != %s (actual)",
+				test.spec, test.time, expected, actual)
+		}
+	}
+}
+
+func TestNext(t *testing.T) {
+	runs := []struct {
+		time, spec string
+		expected   string
+	}{
+		// Simple cases
+		{"Mon Jul 9 14:45 2012", "0 0/15 * * * *", "Mon Jul 9 15:00 2012"},
+		{"Mon Jul 9 14:59 2012", "0 0/15 * * * *", "Mon Jul 9 15:00 2012"},
+		{"Mon Jul 9 14:59:59 2012", "0 0/15 * * * *", "Mon Jul 9 15:00 2012"},
+
+		// Wrap around hours
+		{"Mon Jul 9 15:45 2012", "0 20-35/15 * * * *", "Mon Jul 9 16:20 2012"},
+
+		// Wrap around days
+		{"Mon Jul 9 23:46 2012", "0 */15 * * * *", "Tue Jul 10 00:00 2012"},
+		{"Mon Jul 9 23:45 2012", "0 20-35/15 * * * *", "Tue Jul 10 00:20 2012"},
+		{"Mon Jul 9 23:35:51 2012", "15/35 20-35/15 * * * *", "Tue Jul 10 00:20:15 2012"},
+		{"Mon Jul 9 23:35:51 2012", "15/35 20-35/15 1/2 * * *", "Tue Jul 10 01:20:15 2012"},
+		{"Mon Jul 9 23:35:51 2012", "15/35 20-35/15 10-12 * * *", "Tue Jul 10 10:20:15 2012"},
+
+		{"Mon Jul 9 23:35:51 2012", "15/35 20-35/15 1/2 */2 * *", "Thu Jul 11 01:20:15 2012"},
+		{"Mon Jul 9 23:35:51 2012", "15/35 20-35/15 * 9-20 * *", "Wed Jul 10 00:20:15 2012"},
+		{"Mon Jul 9 23:35:51 2012", "15/35 20-35/15 * 9-20 Jul *", "Wed Jul 10 00:20:15 2012"},
+
+		// Wrap around months
+		{"Mon Jul 9 23:35 2012", "0 0 0 9 Apr-Oct ?", "Thu Aug 9 00:00 2012"},
+		{"Mon Jul 9 23:35 2012", "0 0 0 */5 Apr,Aug,Oct Mon", "Tue Aug 1 00:00 2012"},
+		{"Mon Jul 9 23:35 2012", "0 0 0 */5 Oct Mon", "Mon Oct 1 00:00 2012"},
+
+		// Wrap around years
+		{"Mon Jul 9 23:35 2012", "0 0 0 * Feb Mon", "Mon Feb 4 00:00 2013"},
+		{"Mon Jul 9 23:35 2012", "0 0 0 * Feb Mon/2", "Fri Feb 1 00:00 2013"},
+
+		// Wrap around minute, hour, day, month, and year
+		{"Mon Dec 31 23:59:45 2012", "0 * * * * *", "Tue Jan 1 00:00:00 2013"},
+
+		// Leap year
+		{"Mon Jul 9 23:35 2012", "0 0 0 29 Feb ?", "Mon Feb 29 00:00 2016"},
+
+		// Daylight savings time 2am EST (-5) -> 3am EDT (-4)
+		{"2012-03-11T00:00:00-0500", "TZ=America/New_York 0 30 2 11 Mar ?", "2013-03-11T02:30:00-0400"},
+
+		// hourly job
+		{"2012-03-11T00:00:00-0500", "TZ=America/New_York 0 0 * * * ?", "2012-03-11T01:00:00-0500"},
+		{"2012-03-11T01:00:00-0500", "TZ=America/New_York 0 0 * * * ?", "2012-03-11T03:00:00-0400"},
+		{"2012-03-11T03:00:00-0400", "TZ=America/New_York 0 0 * * * ?", "2012-03-11T04:00:00-0400"},
+		{"2012-03-11T04:00:00-0400", "TZ=America/New_York 0 0 * * * ?", "2012-03-11T05:00:00-0400"},
+
+		// hourly job using CRON_TZ
+		{"2012-03-11T00:00:00-0500", "CRON_TZ=America/New_York 0 0 * * * ?", "2012-03-11T01:00:00-0500"},
+		{"2012-03-11T01:00:00-0500", "CRON_TZ=America/New_York 0 0 * * * ?", "2012-03-11T03:00:00-0400"},
+		{"2012-03-11T03:00:00-0400", "CRON_TZ=America/New_York 0 0 * * * ?", "2012-03-11T04:00:00-0400"},
+		{"2012-03-11T04:00:00-0400", "CRON_TZ=America/New_York 0 0 * * * ?", "2012-03-11T05:00:00-0400"},
+
+		// 1am nightly job
+		{"2012-03-11T00:00:00-0500", "TZ=America/New_York 0 0 1 * * ?", "2012-03-11T01:00:00-0500"},
+		{"2012-03-11T01:00:00-0500", "TZ=America/New_York 0 0 1 * * ?", "2012-03-12T01:00:00-0400"},
+
+		// 2am nightly job (skipped)
+		{"2012-03-11T00:00:00-0500", "TZ=America/New_York 0 0 2 * * ?", "2012-03-12T02:00:00-0400"},
+
+		// Daylight savings time 2am EDT (-4) => 1am EST (-5)
+		{"2012-11-04T00:00:00-0400", "TZ=America/New_York 0 30 2 04 Nov ?", "2012-11-04T02:30:00-0500"},
+		{"2012-11-04T01:45:00-0400", "TZ=America/New_York 0 30 1 04 Nov ?", "2012-11-04T01:30:00-0500"},
+
+		// hourly job
+		{"2012-11-04T00:00:00-0400", "TZ=America/New_York 0 0 * * * ?", "2012-11-04T01:00:00-0400"},
+		{"2012-11-04T01:00:00-0400", "TZ=America/New_York 0 0 * * * ?", "2012-11-04T01:00:00-0500"},
+		{"2012-11-04T01:00:00-0500", "TZ=America/New_York 0 0 * * * ?", "2012-11-04T02:00:00-0500"},
+
+		// 1am nightly job (runs twice)
+		{"2012-11-04T00:00:00-0400", "TZ=America/New_York 0 0 1 * * ?", "2012-11-04T01:00:00-0400"},
+		{"2012-11-04T01:00:00-0400", "TZ=America/New_York 0 0 1 * * ?", "2012-11-04T01:00:00-0500"},
+		{"2012-11-04T01:00:00-0500", "TZ=America/New_York 0 0 1 * * ?", "2012-11-05T01:00:00-0500"},
+
+		// 2am nightly job
+		{"2012-11-04T00:00:00-0400", "TZ=America/New_York 0 0 2 * * ?", "2012-11-04T02:00:00-0500"},
+		{"2012-11-04T02:00:00-0500", "TZ=America/New_York 0 0 2 * * ?", "2012-11-05T02:00:00-0500"},
+
+		// 3am nightly job
+		{"2012-11-04T00:00:00-0400", "TZ=America/New_York 0 0 3 * * ?", "2012-11-04T03:00:00-0500"},
+		{"2012-11-04T03:00:00-0500", "TZ=America/New_York 0 0 3 * * ?", "2012-11-05T03:00:00-0500"},
+
+		// hourly job
+		{"TZ=America/New_York 2012-11-04T00:00:00-0400", "0 0 * * * ?", "2012-11-04T01:00:00-0400"},
+		{"TZ=America/New_York 2012-11-04T01:00:00-0400", "0 0 * * * ?", "2012-11-04T01:00:00-0500"},
+		{"TZ=America/New_York 2012-11-04T01:00:00-0500", "0 0 * * * ?", "2012-11-04T02:00:00-0500"},
+
+		// 1am nightly job (runs twice)
+		{"TZ=America/New_York 2012-11-04T00:00:00-0400", "0 0 1 * * ?", "2012-11-04T01:00:00-0400"},
+		{"TZ=America/New_York 2012-11-04T01:00:00-0400", "0 0 1 * * ?", "2012-11-04T01:00:00-0500"},
+		{"TZ=America/New_York 2012-11-04T01:00:00-0500", "0 0 1 * * ?", "2012-11-05T01:00:00-0500"},
+
+		// 2am nightly job
+		{"TZ=America/New_York 2012-11-04T00:00:00-0400", "0 0 2 * * ?", "2012-11-04T02:00:00-0500"},
+		{"TZ=America/New_York 2012-11-04T02:00:00-0500", "0 0 2 * * ?", "2012-11-05T02:00:00-0500"},
+
+		// 3am nightly job
+		{"TZ=America/New_York 2012-11-04T00:00:00-0400", "0 0 3 * * ?", "2012-11-04T03:00:00-0500"},
+		{"TZ=America/New_York 2012-11-04T03:00:00-0500", "0 0 3 * * ?", "2012-11-05T03:00:00-0500"},
+
+		// Unsatisfiable
+		{"Mon Jul 9 23:35 2012", "0 0 0 30 Feb ?", ""},
+		{"Mon Jul 9 23:35 2012", "0 0 0 31 Apr ?", ""},
+
+		// Monthly job
+		{"TZ=America/New_York 2012-11-04T00:00:00-0400", "0 0 3 3 * ?", "2012-12-03T03:00:00-0500"},
+
+		// Test the scenario of DST resulting in midnight not being a valid time.
+		// https://github.com/robfig/cron/issues/157
+		{"2018-10-17T05:00:00-0400", "TZ=America/Sao_Paulo 0 0 9 10 * ?", "2018-11-10T06:00:00-0500"},
+		{"2018-02-14T05:00:00-0500", "TZ=America/Sao_Paulo 0 0 9 22 * ?", "2018-02-22T07:00:00-0500"},
+	}
+
+	for _, c := range runs {
+		sched, err := secondParser.Parse(c.spec)
+		if err != nil {
+			t.Error(err)
+			continue
+		}
+		actual := sched.Next(getTime(c.time))
+		expected := getTime(c.expected)
+		if !actual.Equal(expected) {
+			t.Errorf("%s, \"%s\": (expected) %v != %v (actual)", c.time, c.spec, expected, actual)
+		}
+	}
+}
+
+func TestErrors(t *testing.T) {
+	invalidSpecs := []string{
+		"xyz",
+		"60 0 * * *",
+		"0 60 * * *",
+		"0 0 * * XYZ",
+	}
+	for _, spec := range invalidSpecs {
+		_, err := ParseStandard(spec)
+		if err == nil {
+			t.Error("expected an error parsing: ", spec)
+		}
+	}
+}
+
+func getTime(value string) time.Time {
+	if value == "" {
+		return time.Time{}
+	}
+
+	var location = time.Local
+	if strings.HasPrefix(value, "TZ=") {
+		parts := strings.Fields(value)
+		loc, err := time.LoadLocation(parts[0][len("TZ="):])
+		if err != nil {
+			panic("could not parse location:" + err.Error())
+		}
+		location = loc
+		value = parts[1]
+	}
+
+	var layouts = []string{
+		"Mon Jan 2 15:04 2006",
+		"Mon Jan 2 15:04:05 2006",
+	}
+	for _, layout := range layouts {
+		if t, err := time.ParseInLocation(layout, value, location); err == nil {
+			return t
+		}
+	}
+	if t, err := time.ParseInLocation("2006-01-02T15:04:05-0700", value, location); err == nil {
+		return t
+	}
+	panic("could not parse time value " + value)
+}
+
+func TestNextWithTz(t *testing.T) {
+	runs := []struct {
+		time, spec string
+		expected   string
+	}{
+		// Failing tests
+		{"2016-01-03T13:09:03+0530", "14 14 * * *", "2016-01-03T14:14:00+0530"},
+		{"2016-01-03T04:09:03+0530", "14 14 * * ?", "2016-01-03T14:14:00+0530"},
+
+		// Passing tests
+		{"2016-01-03T14:09:03+0530", "14 14 * * *", "2016-01-03T14:14:00+0530"},
+		{"2016-01-03T14:00:00+0530", "14 14 * * ?", "2016-01-03T14:14:00+0530"},
+	}
+	for _, c := range runs {
+		sched, err := ParseStandard(c.spec)
+		if err != nil {
+			t.Error(err)
+			continue
+		}
+		actual := sched.Next(getTimeTZ(c.time))
+		expected := getTimeTZ(c.expected)
+		if !actual.Equal(expected) {
+			t.Errorf("%s, \"%s\": (expected) %v != %v (actual)", c.time, c.spec, expected, actual)
+		}
+	}
+}
+
+func getTimeTZ(value string) time.Time {
+	if value == "" {
+		return time.Time{}
+	}
+	t, err := time.Parse("Mon Jan 2 15:04 2006", value)
+	if err != nil {
+		t, err = time.Parse("Mon Jan 2 15:04:05 2006", value)
+		if err != nil {
+			t, err = time.Parse("2006-01-02T15:04:05-0700", value)
+			if err != nil {
+				panic(err)
+			}
+		}
+	}
+
+	return t
+}
+
+// https://github.com/robfig/cron/issues/144
+func TestSlash0NoHang(t *testing.T) {
+	schedule := "TZ=America/New_York 15/0 * * * *"
+	_, err := ParseStandard(schedule)
+	if err == nil {
+		t.Error("expected an error on 0 increment")
+	}
+}
Index: mattermost-server-7.8.1/web/handlers.go
===================================================================
--- mattermost-server-7.8.1/web/handlers.go	(revision 4484)
+++ mattermost-server-7.8.1/web/handlers.go	(revision 4485)
@@ -229,8 +229,23 @@
 	c.SetSiteURLHeader(siteURLHeader)
 
 	w.Header().Set(model.HeaderRequestId, c.AppContext.RequestId())
-	w.Header().Set(model.HeaderVersionId, fmt.Sprintf("%v.%v.%v.%v", model.CurrentVersion, model.BuildNumber, c.App.ClientConfigHash(), c.App.Channels().License() != nil))
+	/* Ryobi Systems CloudOffice Get Service-version Mod 20211108 start */
+	version := model.CurrentVersion
+	pluginOpenStatus := c.App.Config().PluginSettings.PluginStates["extrasrvversionsettingplugin"]
+	if pluginOpenStatus != nil && pluginOpenStatus.Enable {
+		if versionPluginData, ok := c.App.Config().PluginSettings.Plugins["extrasrvversionsettingplugin"]; ok {
+			if versionFromPlugin, isOk := versionPluginData["extrasrvversion"]; isOk {
+				if v, sOk := interface{}(versionFromPlugin).(string); sOk {
+					if v != "" {
+						version = v
+					}
+				}
 
+			}
+		}
+	}
+	w.Header().Set(model.HeaderVersionId, fmt.Sprintf("%v.%v.%v.%v", version, model.BuildNumber, c.App.ClientConfigHash(), c.App.Srv().License() != nil))
+	/* Ryobi Systems CloudOffice Get Service-version Mod 20211108 end */
 	if *c.App.Config().ServiceSettings.TLSStrictTransport {
 		w.Header().Set("Strict-Transport-Security", fmt.Sprintf("max-age=%d", *c.App.Config().ServiceSettings.TLSStrictTransportMaxAge))
 	}
Index: mattermost-server-7.8.1/web/oauth.go
===================================================================
--- mattermost-server-7.8.1/web/oauth.go	(revision 4484)
+++ mattermost-server-7.8.1/web/oauth.go	(revision 4485)
@@ -274,6 +274,7 @@
 	state := r.URL.Query().Get("state")
 
 	uri := c.GetSiteURLHeader() + "/signup/" + service + "/complete"
+	sessionState := r.URL.Query().Get("session_state")
 
 	body, teamId, props, tokenUser, err := c.App.AuthorizeOAuthUser(w, r, service, code, state, uri)
 
@@ -295,6 +296,15 @@
 		if isMobile && hasRedirectURL {
 			utils.RenderMobileError(c.App.Config(), w, err, redirectURL)
 		} else {
+			// 20210604 Ryobi Systems/--
+			// cookieの有効期限切れの場合はエラーにせずトップページにリダイレクトさせる
+			if strings.Index(err.DetailedError, "oauth_cookie_expired") >= 0 {
+				mlog.Info("oauth cookie expired, redirect to page top")
+				w.Header().Set("Content-Type", "text/html; charset=utf-8")
+				http.Redirect(w, r, c.GetSiteURLHeader(), http.StatusTemporaryRedirect)
+				return
+			}
+			// --/20210604 Ryobi Systems
 			utils.RenderWebAppError(c.App.Config(), w, r, err, c.App.AsymmetricSigningKey())
 		}
 	}
@@ -313,7 +323,7 @@
 		renderError(err)
 		return
 	}
-
+	user.Props["session_state"] = sessionState
 	if action == model.OAuthActionEmailToSSO {
 		redirectURL = c.GetSiteURLHeader() + "/login?extra=signin_change"
 	} else if action == model.OAuthActionSSOToEmail {
Index: mattermost-server-7.8.1/web/params.go
===================================================================
--- mattermost-server-7.8.1/web/params.go	(revision 4484)
+++ mattermost-server-7.8.1/web/params.go	(revision 4485)
@@ -94,6 +94,9 @@
 
 	// Cloud
 	InvoiceId string
+	/* Ryobi Systems CloudOffice Meeting Mod 20210325 START */
+	MeetingItemId string
+	/* Ryobi Systems CloudOffice Meeting Mod 20210325 END */
 }
 
 func ParamsFromRequest(r *http.Request) *Params {
@@ -235,7 +238,11 @@
 	}
 
 	params.FilterHasMember = query.Get("filter_has_member")
-
+	/* Ryobi Systems CloudOffice Meeting Mod 20210325 START */
+	if val, ok := props["meeting_item_id"]; ok {
+		params.MeetingItemId = val
+	}
+	/* Ryobi Systems CloudOffice Meeting Mod 20210325 END */
 	return params
 }
 
Index: mattermost-server-7.8.1/web/unsupported_browser.go
===================================================================
--- mattermost-server-7.8.1/web/unsupported_browser.go	(revision 4484)
+++ mattermost-server-7.8.1/web/unsupported_browser.go	(revision 4485)
@@ -49,7 +49,7 @@
 	data := templates.Data{
 		Props: map[string]any{
 			"DownloadAppOrUpgradeBrowserString": ctx.T("web.error.unsupported_browser.download_app_or_upgrade_browser"),
-			"LearnMoreString":                   ctx.T("web.error.unsupported_browser.learn_more"),
+			//"LearnMoreString":                   ctx.T("web.error.unsupported_browser.learn_more"),
 		},
 	}
 
@@ -69,15 +69,16 @@
 
 	// Mattermost app version
 	if isWindows {
-		data.Props["App"] = renderMattermostAppWindows(ctx)
+		//	data.Props["App"] = renderMattermostAppWindows(ctx)
 	} else if isMacOSX {
-		data.Props["App"] = renderMattermostAppMac(ctx)
+		//	data.Props["App"] = renderMattermostAppMac(ctx)
 	}
 
 	// Browsers to download
 	// Show a link to Safari if you're using safari and it's outdated
 	// Can't show on Mac all the time because there's no way to open it via URI
-	browsers := []Browser{renderBrowserChrome(ctx), renderBrowserFirefox(ctx)}
+	//browsers := []Browser{renderBrowserChrome(ctx), renderBrowserFirefox(ctx)}
+	browsers := []Browser{renderBrowserChrome(ctx)}
 	if isSafari {
 		browsers = append(browsers, renderBrowserSafari(ctx))
 	}
